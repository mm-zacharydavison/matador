README.md
  bee7a58d1941ed07 12,91-159
---
{
  "schema_version": "authorship/3.0.0",
  "git_ai_version": "1.0.22",
  "base_commit_sha": "d470619d1057b9d02095e445512f7b2e8a610801",
  "prompts": {
    "4c5bfccc353a642d": {
      "agent_id": {
        "tool": "claude",
        "id": "d90593bc-31bb-44ac-ba7f-f3d996daa3ae",
        "model": "claude-opus-4-5-20251101"
      },
      "human_author": "Zachary Davison <zachary.davison@meetsmore.com>",
      "messages": [
        {
          "type": "user",
          "text": "we want to create a new package called 'matador-nest' in packages/matador-nest\n\nthis package will allow people to use decorators to use matador in nestjs classes\n\nultrathink and write a plan in docs/plans on how to implement\n\nwe want to have decorators like\n\nOnMatadorEvent: for defining subscriber functions",
          "timestamp": "2025-12-11T16:51:56.464Z"
        },
        {
          "type": "assistant",
          "text": "I'll explore the codebase to understand the existing Matador architecture before planning the NestJS integration.",
          "timestamp": "2025-12-11T16:52:02.512Z"
        },
        {
          "type": "tool_use",
          "name": "Task",
          "input": {
            "description": "Explore Matador architecture",
            "prompt": "I need to understand the Matador event processing library architecture to plan a NestJS integration package. Please explore:\n\n1. How events are defined (Event types, EventKey)\n2. How subscribers are defined and registered (Subscriber interface, schema registration)\n3. The core Matador orchestrator API (how to dispatch, consume)\n4. The Schema system (how event-to-subscriber mapping works)\n5. Any existing examples of usage\n\nFocus on the packages/matador/src directory. I need to understand the interfaces and types that the NestJS decorators would need to work with.",
            "subagent_type": "Explore"
          },
          "timestamp": "2025-12-11T16:52:06.625Z"
        },
        {
          "type": "assistant",
          "text": "Now let me check the existing package structure and examine how NestJS decorators typically work for this kind of integration.",
          "timestamp": "2025-12-11T16:53:27.178Z"
        },
        {
          "type": "tool_use",
          "name": "Glob",
          "input": {
            "pattern": "packages/*/package.json"
          },
          "timestamp": "2025-12-11T16:53:27.503Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/types/subscriber.ts"
          },
          "timestamp": "2025-12-11T16:53:28.012Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/types/event.ts"
          },
          "timestamp": "2025-12-11T16:53:28.435Z"
        },
        {
          "type": "user",
          "text": "     1→import type { SubscriberContext } from '../checkpoint/index.js';\n     2→import type { Idempotency, Importance } from './common.js';\n     3→import type { Envelope } from './envelope.js';\n     4→import type { MatadorEvent } from './event.js';\n     5→\n     6→/**\n     7→ * Helper type to get the envelope type for a subscriber callback.\n     8→ * Extracts the data type from a MatadorEvent and wraps it in an Envelope.\n     9→ *\n    10→ * @example\n    11→ * async callback(envelope: EnvelopeOf<MyEvent>) {\n    12→ *   console.log(envelope.data.someField); // Type-safe access\n    13→ * }\n    14→ */\n    15→export type EnvelopeOf<T extends MatadorEvent> = Envelope<T['data']>;\n    16→\n    17→/**\n    18→ * Callback function executed when an event is received (standard subscribers).\n    19→ * Receives the full envelope containing id, data, and docket.\n    20→ */\n    21→export type StandardCallback<T = unknown> = (\n    22→  envelope: Envelope<T>,\n    23→) => Promise<void> | void;\n    24→\n    25→/**\n    26→ * Callback function for resumable subscribers.\n    27→ * Receives the envelope and a SubscriberContext with io() for checkpointed operations.\n    28→ */\n    29→export type ResumableCallback<T = unknown> = (\n    30→  envelope: Envelope<T>,\n    31→  context: SubscriberContext,\n    32→) => Promise<void> | void;\n    33→\n    34→/**\n    35→ * Callback function executed when an event is received.\n    36→ * @deprecated Use StandardCallback or ResumableCallback instead.\n    37→ */\n    38→export type SubscriberCallback<T = unknown> = StandardCallback<T>;\n    39→\n    40→/**\n    41→ * Base configuration options shared by all subscriber types.\n    42→ */\n    43→export interface BaseSubscriberOptions {\n    44→  /** Human-readable description of what this subscriber does */\n    45→  readonly description: string;\n    46→\n    47→  /** Route this subscriber's events to a specific queue */\n    48→  readonly targetQueue?: string | undefined;\n    49→\n    50→  /** Importance level for monitoring and alerting */\n    51→  readonly importance?: Importance | undefined;\n    52→\n    53→  /** Feature flag function to conditionally enable/disable the subscriber */\n    54→  readonly enabled?: (() => boolean | Promise<boolean>) | undefined;\n    55→}\n    56→\n    57→/**\n    58→ * Options for standard (non-resumable) subscribers.\n    59→ */\n    60→export interface StandardSubscriberOptions extends BaseSubscriberOptions {\n    61→  /** Idempotency declaration for retry handling (non-resumable) */\n    62→  readonly idempotent?: 'yes' | 'no' | 'unknown' | undefined;\n    63→}\n    64→\n    65→/**\n    66→ * Options for resumable subscribers that use io() for checkpointed operations.\n    67→ */\n    68→export interface ResumableSubscriberOptions extends BaseSubscriberOptions {\n    69→  /** Must be 'resumable' to enable checkpoint-based idempotency */\n    70→  readonly idempotent: 'resumable';\n    71→}\n    72→\n    73→/**\n    74→ * Configuration options for a subscriber.\n    75→ * Discriminated union based on idempotent value.\n    76→ */\n    77→export type SubscriberOptions =\n    78→  | StandardSubscriberOptions\n    79→  | ResumableSubscriberOptions;\n    80→\n    81→/**\n    82→ * Standard subscriber definition with standard callback.\n    83→ */\n    84→export interface StandardSubscriber<T extends MatadorEvent>\n    85→  extends StandardSubscriberOptions {\n    86→  /** Human-readable name for the subscriber */\n    87→  readonly name: string;\n    88→\n    89→  /** Callback function to execute when event is received */\n    90→  readonly callback: StandardCallback<T['data']>;\n    91→}\n    92→\n    93→/**\n    94→ * Resumable subscriber definition with resumable callback.\n    95→ */\n    96→export interface ResumableSubscriber<T extends MatadorEvent>\n    97→  extends ResumableSubscriberOptions {\n    98→  /** Human-readable name for the subscriber */\n    99→  readonly name: string;\n   100→\n   101→  /** Callback function with SubscriberContext for checkpointed operations */\n   102→  readonly callback: ResumableCallback<T['data']>;\n   103→}\n   104→\n   105→/**\n   106→ * Full subscriber definition with callback (either standard or resumable).\n   107→ */\n   108→export type Subscriber<T extends MatadorEvent> =\n   109→  | StandardSubscriber<T>\n   110→  | ResumableSubscriber<T>;\n   111→\n   112→/**\n   113→ * Subscriber stub for multi-codebase scenarios where subscriber implementation\n   114→ * is in a remote service. Declares the subscriber contract without providing\n   115→ * the callback.\n   116→ */\n   117→export interface SubscriberStub extends StandardSubscriberOptions {\n   118→  /** Human-readable name for the subscriber */\n   119→  readonly name: string;\n   120→\n   121→  /** Indicates this is a stub without implementation */\n   122→  readonly isStub: true;\n   123→}\n   124→\n   125→/**\n   126→ * Union type for any subscriber definition (full or stub).\n   127→ * This is the type-erased version for use in collections and schema.\n   128→ * Uses `any` because Subscriber<T> is contravariant in T (callback parameter),\n   129→ * making it impossible to assign Subscriber<SpecificEvent> to Subscriber<MatadorEvent<unknown>>.\n   130→ */\n   131→// biome-ignore lint/suspicious/noExplicitAny: Required for variance compatibility in heterogeneous collections\n   132→export type AnySubscriber = Subscriber<MatadorEvent<any>> | SubscriberStub;\n   133→\n   134→/**\n   135→ * Type guard to check if a subscriber is a stub.\n   136→ */\n   137→export function isSubscriberStub(\n   138→  subscriber: AnySubscriber,\n   139→): subscriber is SubscriberStub {\n   140→  return 'isStub' in subscriber && subscriber.isStub === true;\n   141→}\n   142→\n   143→/**\n   144→ * Type guard to check if a subscriber has a callback implementation.\n   145→ */\n   146→export function isSubscriber(\n   147→  subscriber: AnySubscriber,\n   148→  // biome-ignore lint/suspicious/noExplicitAny: Required for variance compatibility\n   149→): subscriber is Subscriber<MatadorEvent<any>> {\n   150→  return 'callback' in subscriber && typeof subscriber.callback === 'function';\n   151→}\n   152→\n   153→/**\n   154→ * Type guard to check if a subscriber is resumable.\n   155→ */\n   156→export function isResumableSubscriber(\n   157→  subscriber: AnySubscriber,\n   158→  // biome-ignore lint/suspicious/noExplicitAny: Required for variance compatibility\n   159→): subscriber is ResumableSubscriber<MatadorEvent<any>> {\n   160→  return isSubscriber(subscriber) && subscriber.idempotent === 'resumable';\n   161→}\n   162→\n   163→/**\n   164→ * Type guard to check if a subscriber is a standard (non-resumable) subscriber.\n   165→ */\n   166→export function isStandardSubscriber(\n   167→  subscriber: AnySubscriber,\n   168→  // biome-ignore lint/suspicious/noExplicitAny: Required for variance compatibility\n   169→): subscriber is StandardSubscriber<MatadorEvent<any>> {\n   170→  return isSubscriber(subscriber) && subscriber.idempotent !== 'resumable';\n   171→}\n   172→\n   173→/**\n   174→ * Input options for createSubscriber with standard callback.\n   175→ */\n   176→export interface CreateStandardSubscriberInput<T extends MatadorEvent> {\n   177→  readonly name: string;\n   178→  readonly description: string;\n   179→  readonly callback: StandardCallback<T['data']>;\n   180→  readonly idempotent?: 'yes' | 'no' | 'unknown' | undefined;\n   181→  readonly importance?: Importance | undefined;\n   182→  readonly targetQueue?: string | undefined;\n   183→  readonly enabled?: (() => boolean | Promise<boolean>) | undefined;\n   184→}\n   185→\n   186→/**\n   187→ * Input options for createSubscriber with resumable callback.\n   188→ */\n   189→export interface CreateResumableSubscriberInput<T extends MatadorEvent> {\n   190→  readonly name: string;\n   191→  readonly description: string;\n   192→  readonly callback: ResumableCallback<T['data']>;\n   193→  readonly idempotent: 'resumable';\n   194→  readonly importance?: Importance | undefined;\n   195→  readonly targetQueue?: string | undefined;\n   196→  readonly enabled?: (() => boolean | Promise<boolean>) | undefined;\n   197→}\n   198→\n   199→/**\n   200→ * Input options for createSubscriber (discriminated union).\n   201→ */\n   202→export type CreateSubscriberInput<T extends MatadorEvent> =\n   203→  | CreateStandardSubscriberInput<T>\n   204→  | CreateResumableSubscriberInput<T>;\n   205→\n   206→/**\n   207→ * Creates a subscriber definition.\n   208→ *\n   209→ * @example Standard subscriber\n   210→ * ```typescript\n   211→ * const subscriber = createSubscriber<MyEvent>({\n   212→ *   name: 'my-subscriber',\n   213→ *   description: 'Handles MyEvent by logging the data',\n   214→ *   callback: async (envelope) => {\n   215→ *     console.log(envelope.data);\n   216→ *   },\n   217→ * });\n   218→ * ```\n   219→ *\n   220→ * @example Resumable subscriber with io()\n   221→ * ```typescript\n   222→ * const subscriber = createSubscriber<MyEvent>({\n   223→ *   name: 'my-resumable-subscriber',\n   224→ *   description: 'Processes MyEvent with checkpoint-based idempotency',\n   225→ *   idempotent: 'resumable',\n   226→ *   callback: async (envelope, { io }) => {\n   227→ *     await io('step-1', () => doSomething());\n   228→ *   },\n   229→ * });\n   230→ * ```\n   231→ */\n   232→export function createSubscriber<T extends MatadorEvent>(\n   233→  input: CreateSubscriberInput<T>,\n   234→): Subscriber<T> {\n   235→  const base = {\n   236→    name: input.name,\n   237→    description: input.description,\n   238→    callback: input.callback,\n   239→    importance: input.importance ?? 'should-investigate',\n   240→    ...(input.targetQueue !== undefined && {\n   241→      targetQueue: input.targetQueue,\n   242→    }),\n   243→    ...(input.enabled !== undefined && { enabled: input.enabled }),\n   244→  };\n   245→\n   246→  if (input.idempotent === 'resumable') {\n   247→    return {\n   248→      ...base,\n   249→      idempotent: 'resumable',\n   250→      callback: input.callback,\n   251→    } as ResumableSubscriber<T>;\n   252→  }\n   253→\n   254→  return {\n   255→    ...base,\n   256→    idempotent: input.idempotent ?? 'unknown',\n   257→    callback: input.callback,\n   258→  } as StandardSubscriber<T>;\n   259→}\n   260→\n   261→/**\n   262→ * Input options for createSubscriberStub.\n   263→ */\n   264→export interface CreateSubscriberStubInput {\n   265→  readonly name: string;\n   266→  readonly description: string;\n   267→  readonly idempotent?: 'yes' | 'no' | 'unknown' | undefined;\n   268→  readonly importance?: Importance | undefined;\n   269→  readonly targetQueue?: string | undefined;\n   270→  readonly enabled?: (() => boolean | Promise<boolean>) | undefined;\n   271→}\n   272→\n   273→/**\n   274→ * Creates a subscriber stub for remote implementations.\n   275→ *\n   276→ * @example\n   277→ * ```typescript\n   278→ * const stub = createSubscriberStub({\n   279→ *   name: 'remote-analytics',\n   280→ *   description: 'Sends events to remote analytics service',\n   281→ *   targetQueue: 'analytics-worker',\n   282→ * });\n   283→ * ```\n   284→ */\n   285→export function createSubscriberStub(input: CreateSubscriberStubInput): SubscriberStub {\n   286→  return {\n   287→    name: input.name,\n   288→    description: input.description,\n   289→    isStub: true,\n   290→    idempotent: input.idempotent ?? 'unknown',\n   291→    importance: input.importance ?? 'should-investigate',\n   292→    ...(input.targetQueue !== undefined && {\n   293→      targetQueue: input.targetQueue,\n   294→    }),\n   295→    ...(input.enabled !== undefined && { enabled: input.enabled }),\n   296→  };\n   297→}\n   298→\n   299→/**\n   300→ * Definition interface used by the pipeline (excludes event class reference).\n   301→ */\n   302→export interface SubscriberDefinition {\n   303→  readonly name: string;\n   304→  readonly description: string;\n   305→  readonly idempotent: Idempotency;\n   306→  readonly importance: Importance;\n   307→  readonly targetQueue?: string | undefined;\n   308→}\n   309→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T16:53:28.562Z"
        },
        {
          "type": "user",
          "text": "     1→/**\n     2→ * Unique event routing key type alias.\n     3→ */\n     4→export type EventKey = string;\n     5→\n     6→/**\n     7→ * JSON-serializable primitive types.\n     8→ */\n     9→export type JsonPrimitive = string | number | boolean | null;\n    10→\n    11→/**\n    12→ * JSON-serializable value (recursive type for objects and arrays).\n    13→ */\n    14→export type JsonValue =\n    15→  | JsonPrimitive\n    16→  | JsonValue[]\n    17→  | { [key: string]: JsonValue };\n    18→\n    19→/**\n    20→ * JSON-serializable record type for metadata.\n    21→ */\n    22→export type JsonRecord = Record<string, JsonValue>;\n    23→\n    24→/**\n    25→ * Static properties required on Event classes for schema registration.\n    26→ */\n    27→export interface EventStatic<T = unknown> {\n    28→  /** Unique routing key for the event */\n    29→  readonly key: string;\n    30→\n    31→  /** Human-readable description of the event */\n    32→  readonly description?: string;\n    33→\n    34→  /** Alternative names/keys for backwards compatibility */\n    35→  readonly aliases?: readonly string[];\n    36→\n    37→  /** Create an instance from data (for deserialization) */\n    38→  new (data: T): Event<T>;\n    39→}\n    40→\n    41→/**\n    42→ * Base interface for all events.\n    43→ * Events represent something that happened in the system.\n    44→ */\n    45→export interface Event<T = unknown> {\n    46→  /** The event data/payload */\n    47→  readonly data: T;\n    48→\n    49→  /** Event-specific metadata (merged with EventOptions metadata on dispatch) */\n    50→  readonly metadata?: JsonRecord | undefined;\n    51→}\n    52→\n    53→/**\n    54→ * Options for dispatching an event.\n    55→ */\n    56→export interface EventOptions {\n    57→  /** Delay processing by this many milliseconds */\n    58→  readonly delayMs?: number | undefined;\n    59→\n    60→  /** Correlation ID for request tracing */\n    61→  readonly correlationId?: string | undefined;\n    62→\n    63→  /**\n    64→   * Event-specific metadata to include in the docket.\n    65→   * This metadata will be merged with:\n    66→   * 1. Event instance metadata (if defined on the event)\n    67→   * 2. Universal metadata from the loadUniversalMetadata hook\n    68→   * With EventOptions metadata taking precedence over event metadata,\n    69→   * and both taking precedence over universal metadata.\n    70→   */\n    71→  readonly metadata?: JsonRecord | undefined;\n    72→}\n    73→\n    74→/**\n    75→ * Abstract base class for creating Matador events.\n    76→ * Extend this class to define custom events.\n    77→ *\n    78→ * @example\n    79→ * ```typescript\n    80→ * class UserCreatedEvent extends MatadorEvent {\n    81→ *   static readonly key = 'user.created'\n    82→ *   static readonly description = 'Fired when a new user is created'\n    83→ *\n    84→ *   constructor(\n    85→ *     public data: { userId: string; email: string },\n    86→ *     public metadata?: JsonRecord,\n    87→ *   ) {\n    88→ *     super()\n    89→ *   }\n    90→ * }\n    91→ * ```\n    92→ */\n    93→export abstract class MatadorEvent<T = unknown> implements Event<T> {\n    94→  static readonly key: string;\n    95→  static readonly description?: string;\n    96→  static readonly aliases?: readonly string[];\n    97→\n    98→  /** The event data/payload - must be defined by subclass */\n    99→  abstract readonly data: T;\n   100→\n   101→  /** Event-specific metadata */\n   102→  readonly metadata?: JsonRecord | undefined;\n   103→}\n   104→\n   105→/**\n   106→ * Type helper to extract the data type from an event class.\n   107→ */\n   108→export type EventData<E extends Event<unknown>> = E extends Event<infer T>\n   109→  ? T\n   110→  : never;\n   111→\n   112→/**\n   113→ * Type helper to get the event class type.\n   114→ */\n   115→export type EventClass<T = unknown> = EventStatic<T> &\n   116→  (new (\n   117→    data: T,\n   118→  ) => Event<T>);\n   119→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T16:53:28.563Z"
        },
        {
          "type": "user",
          "text": "/home/z/Desktop/work/matador/packages/matador/package.json",
          "timestamp": "2025-12-11T16:53:28.593Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/package.json"
          },
          "timestamp": "2025-12-11T16:53:33.748Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/package.json"
          },
          "timestamp": "2025-12-11T16:53:34.088Z"
        },
        {
          "type": "tool_use",
          "name": "Glob",
          "input": {
            "pattern": "packages/matador/src/index.ts"
          },
          "timestamp": "2025-12-11T16:53:34.564Z"
        },
        {
          "type": "user",
          "text": "     1→{\n     2→  \"name\": \"@zdavison/matador\",\n     3→  \"version\": \"2.0.0\",\n     4→  \"description\": \"A batteries-included event system.\",\n     5→  \"type\": \"module\",\n     6→  \"main\": \"./dist/index.cjs\",\n     7→  \"module\": \"./dist/index.js\",\n     8→  \"types\": \"./dist/index.d.ts\",\n     9→  \"exports\": {\n    10→    \".\": {\n    11→      \"import\": {\n    12→        \"types\": \"./dist/index.d.ts\",\n    13→        \"default\": \"./dist/index.js\"\n    14→      },\n    15→      \"require\": {\n    16→        \"types\": \"./dist/index.d.cts\",\n    17→        \"default\": \"./dist/index.cjs\"\n    18→      }\n    19→    }\n    20→  },\n    21→  \"bin\": {\n    22→    \"matador\": \"./cli.ts\"\n    23→  },\n    24→  \"scripts\": {\n    25→    \"build\": \"tsup\",\n    26→    \"test\": \"bun test\",\n    27→    \"test:watch\": \"bun test --watch\",\n    28→    \"test:integration\": \"bun test --grep integration\",\n    29→    \"lint\": \"bunx biome check .\",\n    30→    \"lint:fix\": \"bunx biome check . --fix\",\n    31→    \"typecheck\": \"tsc --noEmit\",\n    32→    \"clean\": \"rm -rf dist\",\n    33→    \"cli\": \"bun ./cli.ts\",\n    34→    \"send-test-event\": \"bun ./cli.ts ./examples/config.ts ./examples/event.ts\"\n    35→  },\n    36→  \"dependencies\": {\n    37→    \"amqplib\": \"^0.10.4\"\n    38→  },\n    39→  \"devDependencies\": {\n    40→    \"@testcontainers/rabbitmq\": \"^10.16.0\",\n    41→    \"@types/amqplib\": \"^0.10.5\",\n    42→    \"testcontainers\": \"^10.16.0\",\n    43→    \"tsup\": \"^8.3.5\"\n    44→  },\n    45→  \"peerDependencies\": {\n    46→    \"zod\": \"^3.0.0\"\n    47→  },\n    48→  \"peerDependenciesMeta\": {\n    49→    \"zod\": {\n    50→      \"optional\": true\n    51→    }\n    52→  },\n    53→  \"engines\": {\n    54→    \"node\": \">=18.0.0\"\n    55→  },\n    56→  \"keywords\": [\n    57→    \"events\",\n    58→    \"messaging\",\n    59→    \"queue\",\n    60→    \"rabbitmq\",\n    61→    \"bullmq\",\n    62→    \"kafka\",\n    63→    \"transport\"\n    64→  ],\n    65→  \"license\": \"MIT\"\n    66→}\n    67→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T16:53:34.726Z"
        },
        {
          "type": "user",
          "text": "     1→{\n     2→  \"name\": \"matador-monorepo\",\n     3→  \"private\": true,\n     4→  \"workspaces\": [\"packages/*\"],\n     5→  \"scripts\": {\n     6→    \"build\": \"bun run --filter '*' build\",\n     7→    \"test\": \"bun run --filter '*' test\",\n     8→    \"lint\": \"bunx biome check .\",\n     9→    \"lint:fix\": \"bunx biome check . --fix\",\n    10→    \"typecheck\": \"bun run --filter '*' typecheck\",\n    11→    \"clean\": \"bun run --filter '*' clean\"\n    12→  },\n    13→  \"devDependencies\": {\n    14→    \"@biomejs/biome\": \"^1.9.0\",\n    15→    \"@types/bun\": \"^1.1.0\",\n    16→    \"tsup\": \"^8.3.5\",\n    17→    \"typescript\": \"^5.6.0\"\n    18→  }\n    19→}\n    20→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T16:53:34.727Z"
        },
        {
          "type": "user",
          "text": "/home/z/Desktop/work/matador/packages/matador/src/index.ts",
          "timestamp": "2025-12-11T16:53:34.773Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/index.ts"
          },
          "timestamp": "2025-12-11T16:53:39.256Z"
        },
        {
          "type": "tool_use",
          "name": "Bash",
          "input": {
            "command": "ls -la /home/z/Desktop/work/matador/docs 2>/dev/null || echo \"docs dir does not exist\"",
            "description": "Check if docs directory exists"
          },
          "timestamp": "2025-12-11T16:53:40.117Z"
        },
        {
          "type": "user",
          "text": "     1→// Core\n     2→export type {\n     3→  FanoutConfig,\n     4→  HandlersState,\n     5→  MatadorConfig,\n     6→  SendError,\n     7→  SendResult,\n     8→  ShutdownConfig,\n     9→  ShutdownState,\n    10→} from './core/index.js';\n    11→export {\n    12→  defaultShutdownConfig,\n    13→  FanoutEngine,\n    14→  Matador,\n    15→  ShutdownManager,\n    16→} from './core/index.js';\n    17→\n    18→// Types\n    19→export type {\n    20→  AnySubscriber,\n    21→  CreateEnvelopeOptions,\n    22→  DeliveryMode,\n    23→  Docket,\n    24→  Envelope,\n    25→  EnvelopeOf,\n    26→  Event,\n    27→  EventClass,\n    28→  EventData,\n    29→  EventKey,\n    30→  EventOptions,\n    31→  EventStatic,\n    32→  Idempotency,\n    33→  Importance,\n    34→  JsonRecord,\n    35→  Subscriber,\n    36→  SubscriberCallback,\n    37→  SubscriberDefinition,\n    38→  SubscriberOptions,\n    39→  SubscriberStub,\n    40→  ValidationError,\n    41→  ValidationResult,\n    42→} from './types/index.js';\n    43→export {\n    44→  MatadorEvent,\n    45→  createEnvelope,\n    46→  createSubscriber,\n    47→  createSubscriberStub,\n    48→  invalidResult,\n    49→  isSubscriber,\n    50→  isSubscriberStub,\n    51→  validResult,\n    52→} from './types/index.js';\n    53→\n    54→// Transport\n    55→export type {\n    56→  ConnectFn,\n    57→  ConnectionManagerConfig,\n    58→  ConnectionState,\n    59→  DisconnectFn,\n    60→  MessageHandler,\n    61→  MessageReceipt,\n    62→  RabbitMQSendOptions,\n    63→  RabbitMQSubscribeOptions,\n    64→  RabbitMQTransportConfig,\n    65→  SendOptions,\n    66→  StateChangeCallback,\n    67→  SubscribeOptions,\n    68→  Subscription,\n    69→  Transport,\n    70→  TransportCapabilities,\n    71→  TransportSendOptions,\n    72→  TransportSubscribeOptions,\n    73→} from './transport/index.js';\n    74→export {\n    75→  ConnectionManager,\n    76→  defaultConnectionConfig,\n    77→  hasNativeDeadLetter,\n    78→  LocalTransport,\n    79→  RabbitMQTransport,\n    80→  MultiTransport,\n    81→  type MultiTransportConfig,\n    82→  type MultiTransportHooks,\n    83→  supportsDeliveryMode,\n    84→  supportsDelayedMessages,\n    85→} from './transport/index.js';\n    86→\n    87→// Topology\n    88→export type {\n    89→  DeadLetterConfig,\n    90→  DeadLetterQueueConfig,\n    91→  QueueDefinition,\n    92→  QueueOptions,\n    93→  RetryConfig,\n    94→  Topology,\n    95→} from './topology/index.js';\n    96→export {\n    97→  getDeadLetterQueueName,\n    98→  getQualifiedQueueName,\n    99→  getRetryQueueName,\n   100→  TopologyBuilder,\n   101→  TopologyValidationError,\n   102→} from './topology/index.js';\n   103→\n   104→// Codec\n   105→export type {\n   106→  Codec,\n   107→  EncodedMessage,\n   108→  HeaderAwareCodec,\n   109→} from './codec/index.js';\n   110→export { CodecDecodeError, JsonCodec, RabbitMQCodec } from './codec/index.js';\n   111→\n   112→// Schema\n   113→export type {\n   114→  MatadorSchema,\n   115→  RegisterOptions,\n   116→  SchemaEntry,\n   117→  SchemaEntryTuple,\n   118→  SchemaIssue,\n   119→  SchemaPlugin,\n   120→  SchemaValidationResult,\n   121→} from './schema/index.js';\n   122→export {\n   123→  bind,\n   124→  installPlugins,\n   125→  isSchemaEntryTuple,\n   126→  SchemaError,\n   127→  SchemaRegistry,\n   128→} from './schema/index.js';\n   129→\n   130→// Retry\n   131→export type {\n   132→  RetryContext,\n   133→  RetryDecision,\n   134→  RetryPolicy,\n   135→  StandardRetryPolicyConfig,\n   136→} from './retry/index.js';\n   137→export {\n   138→  defaultRetryConfig,\n   139→  StandardRetryPolicy,\n   140→} from './retry/index.js';\n   141→\n   142→// Hooks\n   143→export type {\n   144→  DecodeErrorContext,\n   145→  EnqueueErrorContext,\n   146→  EnqueueSuccessContext,\n   147→  EnqueueWarningContext,\n   148→  Logger,\n   149→  MatadorHooks,\n   150→  WorkerErrorContext,\n   151→  WorkerExecuteFn,\n   152→  WorkerSuccessContext,\n   153→} from './hooks/index.js';\n   154→export { consoleLogger, SafeHooks } from './hooks/index.js';\n   155→\n   156→// Pipeline\n   157→export type { PipelineConfig, ProcessResult } from './pipeline/index.js';\n   158→export { ProcessingPipeline } from './pipeline/index.js';\n   159→\n   160→// Errors\n   161→export type { HasDescription } from './errors/index.js';\n   162→export {\n   163→  // Retry control errors\n   164→  DontRetry,\n   165→  DoRetry,\n   166→  EventAssertionError,\n   167→  RetryControlError,\n   168→  isAssertionError,\n   169→  isDontRetry,\n   170→  isDoRetry,\n   171→  // Matador errors with descriptions\n   172→  MatadorError,\n   173→  isMatadorError,\n   174→  // Lifecycle errors\n   175→  NotStartedError,\n   176→  isNotStartedError,\n   177→  ShutdownInProgressError,\n   178→  // Transport errors\n   179→  TransportNotConnectedError,\n   180→  isTransportNotConnectedError,\n   181→  TransportClosedError,\n   182→  TransportSendError,\n   183→  AllTransportsFailedError,\n   184→  DelayedMessagesNotSupportedError,\n   185→  // Schema & configuration errors\n   186→  EventNotRegisteredError,\n   187→  isEventNotRegisteredError,\n   188→  SubscriberNotRegisteredError,\n   189→  isSubscriberNotRegisteredError,\n   190→  NoSubscribersExistError,\n   191→  InvalidSchemaError,\n   192→  SubscriberIsStubError,\n   193→  LocalTransportCannotProcessStubError,\n   194→  // Queue errors\n   195→  QueueNotFoundError,\n   196→  // Event validation errors\n   197→  InvalidEventError,\n   198→  // Message processing errors\n   199→  MessageMaybePoisonedError,\n   200→  isMessageMaybePoisonedError,\n   201→  IdempotentMessageCannotRetryError,\n   202→  isIdempotentMessageCannotRetryError,\n   203→  // Timeout errors\n   204→  TimeoutError,\n   205→  // Utility\n   206→  hasDescription,\n   207→} from './errors/index.js';\n   208→\n   209→// Checkpoint (Resumable Subscribers)\n   210→export type {\n   211→  Checkpoint,\n   212→  CheckpointClearedContext,\n   213→  CheckpointHitContext,\n   214→  CheckpointLoadedContext,\n   215→  CheckpointMissContext,\n   216→  CheckpointStore,\n   217→  JsonSerializable,\n   218→  ResumableContextConfig,\n   219→  ResumableContextHooks,\n   220→  SubscriberContext,\n   221→} from './checkpoint/index.js';\n   222→export {\n   223→  CheckpointStoreError,\n   224→  DuplicateIoKeyError,\n   225→  MemoryCheckpointStore,\n   226→  NoOpCheckpointStore,\n   227→  ResumableContext,\n   228→  isCheckpointStoreError,\n   229→  isDuplicateIoKeyError,\n   230→} from './checkpoint/index.js';\n   231→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T16:53:40.252Z"
        },
        {
          "type": "user",
          "text": "total 12\ndrwxrwxr-x 3 z z 4096 Dec 10 16:16 .\ndrwxrwxr-x 9 z z 4096 Dec 11 17:13 ..\ndrwxrwxr-x 2 z z 4096 Dec 11 16:52 plans",
          "timestamp": "2025-12-11T16:53:41.126Z"
        },
        {
          "type": "assistant",
          "text": "Now I have a thorough understanding of the Matador architecture. Let me create the implementation plan.",
          "timestamp": "2025-12-11T16:53:47.641Z"
        },
        {
          "type": "tool_use",
          "name": "Write",
          "input": {
            "content": "# matador-nest Implementation Plan\n\n## Overview\n\n`matador-nest` is a NestJS integration package for Matador that enables decorator-based event subscriber registration. It allows NestJS developers to define event handlers using familiar patterns while leveraging Matador's transport-agnostic event processing capabilities.\n\n## Goals\n\n1. Provide `@OnMatadorEvent()` decorator for defining subscriber methods\n2. Auto-discover and register subscribers at module initialization\n3. Integrate with NestJS dependency injection (inject services into subscriber classes)\n4. Support all Matador subscriber options (idempotency, importance, targetQueue, etc.)\n5. Expose `Matador` instance through DI for sending events\n6. Support both sync and async module configuration\n\n## Package Structure\n\n```\npackages/matador-nest/\n├── src/\n│   ├── index.ts                    # Public exports\n│   ├── decorators/\n│   │   ├── index.ts\n│   │   ├── on-matador-event.decorator.ts   # @OnMatadorEvent()\n│   │   └── matador-subscriber.decorator.ts # @MatadorSubscriber() class decorator\n│   ├── module/\n│   │   ├── index.ts\n│   │   ├── matador.module.ts       # MatadorModule (dynamic module)\n│   │   ├── matador-core.module.ts  # Core module with providers\n│   │   └── matador.interfaces.ts   # Module config interfaces\n│   ├── discovery/\n│   │   ├── index.ts\n│   │   └── subscriber-discovery.service.ts # Discovers decorated methods\n│   ├── services/\n│   │   ├── index.ts\n│   │   └── matador.service.ts      # Injectable wrapper around Matador\n│   ├── constants.ts                # Metadata keys\n│   └── types.ts                    # Package-specific types\n├── package.json\n├── tsconfig.json\n├── tsup.config.ts\n└── README.md\n```\n\n## Core Components\n\n### 1. Decorators\n\n#### `@OnMatadorEvent(eventClass, options?)`\n\nMethod decorator that marks a method as an event subscriber.\n\n```typescript\nimport { OnMatadorEvent } from '@zdavison/matador-nest';\nimport { UserCreatedEvent, OrderPlacedEvent } from './events';\nimport { Envelope } from '@zdavison/matador';\n\n@Injectable()\nexport class NotificationService {\n  constructor(private readonly emailService: EmailService) {}\n\n  @OnMatadorEvent(UserCreatedEvent, {\n    name: 'send-welcome-email',        // Required: unique subscriber name\n    description: 'Sends welcome email', // Required: human-readable description\n    idempotent: 'yes',                  // Optional: 'yes' | 'no' | 'unknown' | 'resumable'\n    importance: 'should-investigate',   // Optional: importance level\n    targetQueue: 'email-worker',        // Optional: route to specific queue\n  })\n  async onUserCreated(envelope: Envelope<UserCreatedEvent['data']>) {\n    await this.emailService.sendWelcome(envelope.data.email);\n  }\n\n  @OnMatadorEvent(OrderPlacedEvent, {\n    name: 'send-order-confirmation',\n    description: 'Sends order confirmation email',\n  })\n  async onOrderPlaced(envelope: Envelope<OrderPlacedEvent['data']>) {\n    await this.emailService.sendOrderConfirmation(envelope.data);\n  }\n}\n```\n\n**Implementation:**\n\n```typescript\n// decorators/on-matador-event.decorator.ts\nimport { SetMetadata } from '@nestjs/common';\nimport type { EventClass, SubscriberOptions } from '@zdavison/matador';\nimport { MATADOR_EVENT_HANDLER } from '../constants';\n\nexport interface OnMatadorEventOptions extends SubscriberOptions {\n  name: string;\n  description: string;\n}\n\nexport interface MatadorEventHandlerMetadata {\n  eventClass: EventClass<unknown>;\n  options: OnMatadorEventOptions;\n  methodName: string;\n}\n\nexport function OnMatadorEvent<T>(\n  eventClass: EventClass<T>,\n  options: OnMatadorEventOptions,\n): MethodDecorator {\n  return (target, propertyKey, descriptor) => {\n    const metadata: MatadorEventHandlerMetadata = {\n      eventClass,\n      options,\n      methodName: String(propertyKey),\n    };\n\n    // Store metadata on the method\n    SetMetadata(MATADOR_EVENT_HANDLER, metadata)(target, propertyKey, descriptor);\n\n    // Also maintain a list on the class for discovery\n    const existingHandlers = Reflect.getMetadata(MATADOR_EVENT_HANDLERS, target.constructor) || [];\n    Reflect.defineMetadata(\n      MATADOR_EVENT_HANDLERS,\n      [...existingHandlers, metadata],\n      target.constructor,\n    );\n\n    return descriptor;\n  };\n}\n```\n\n#### `@MatadorSubscriber()` (Optional Class Decorator)\n\nOptional class decorator for explicit registration. If not used, any class with `@OnMatadorEvent` methods will be auto-discovered.\n\n```typescript\n@MatadorSubscriber()\n@Injectable()\nexport class NotificationService {\n  // ...\n}\n```\n\n### 2. Module Configuration\n\n#### `MatadorModule.forRoot(options)`\n\nSynchronous configuration for simple setups.\n\n```typescript\n// app.module.ts\nimport { Module } from '@nestjs/common';\nimport { MatadorModule } from '@zdavison/matador-nest';\nimport { RabbitMQTransport, TopologyBuilder } from '@zdavison/matador';\n\n@Module({\n  imports: [\n    MatadorModule.forRoot({\n      transport: new RabbitMQTransport({ url: 'amqp://localhost' }),\n      topology: TopologyBuilder.create()\n        .withNamespace('myapp')\n        .addQueue('events', { concurrency: 10 })\n        .build(),\n      consumeFrom: ['events'],\n      // events are auto-discovered from @OnMatadorEvent decorators\n    }),\n  ],\n})\nexport class AppModule {}\n```\n\n#### `MatadorModule.forRootAsync(options)`\n\nAsync configuration for injecting dependencies (ConfigService, etc.).\n\n```typescript\n// app.module.ts\nimport { Module } from '@nestjs/common';\nimport { ConfigModule, ConfigService } from '@nestjs/config';\nimport { MatadorModule } from '@zdavison/matador-nest';\nimport { RabbitMQTransport, TopologyBuilder } from '@zdavison/matador';\n\n@Module({\n  imports: [\n    ConfigModule.forRoot(),\n    MatadorModule.forRootAsync({\n      imports: [ConfigModule],\n      inject: [ConfigService],\n      useFactory: (config: ConfigService) => ({\n        transport: new RabbitMQTransport({\n          url: config.get('RABBITMQ_URL'),\n        }),\n        topology: TopologyBuilder.create()\n          .withNamespace(config.get('APP_NAME'))\n          .addQueue('events', { concurrency: 10 })\n          .build(),\n        consumeFrom: ['events'],\n      }),\n    }),\n  ],\n})\nexport class AppModule {}\n```\n\n### 3. Module Interfaces\n\n```typescript\n// module/matador.interfaces.ts\nimport type {\n  Topology,\n  Transport,\n  MatadorHooks,\n  RetryPolicy,\n  Codec,\n  CheckpointStore,\n  EventClass,\n  AnySubscriber,\n} from '@zdavison/matador';\nimport type { ModuleMetadata, Type } from '@nestjs/common';\n\nexport interface MatadorModuleOptions {\n  /** Transport implementation (RabbitMQTransport, LocalTransport, etc.) */\n  transport: Transport;\n\n  /** Queue topology configuration */\n  topology: Topology;\n\n  /** Queues to consume from (if acting as a consumer) */\n  consumeFrom?: string[];\n\n  /** Optional codec (defaults to JsonCodec) */\n  codec?: Codec;\n\n  /** Optional retry policy */\n  retryPolicy?: RetryPolicy;\n\n  /** Optional lifecycle hooks */\n  hooks?: MatadorHooks;\n\n  /** Optional checkpoint store for resumable subscribers */\n  checkpointStore?: CheckpointStore;\n\n  /**\n   * Additional events to register (for events without decorated subscribers).\n   * Maps event class to subscriber stubs or external subscribers.\n   */\n  additionalEvents?: Map<EventClass<unknown>, AnySubscriber[]>;\n\n  /**\n   * Whether to auto-start consuming on module init.\n   * Default: true\n   */\n  autoStart?: boolean;\n\n  /**\n   * Global subscriber options applied to all discovered subscribers.\n   */\n  globalSubscriberDefaults?: {\n    importance?: 'can-ignore' | 'should-investigate' | 'must-investigate';\n    idempotent?: 'yes' | 'no' | 'unknown';\n  };\n}\n\nexport interface MatadorModuleAsyncOptions extends Pick<ModuleMetadata, 'imports'> {\n  inject?: any[];\n  useFactory: (...args: any[]) => Promise<MatadorModuleOptions> | MatadorModuleOptions;\n  useClass?: Type<MatadorOptionsFactory>;\n  useExisting?: Type<MatadorOptionsFactory>;\n}\n\nexport interface MatadorOptionsFactory {\n  createMatadorOptions(): Promise<MatadorModuleOptions> | MatadorModuleOptions;\n}\n```\n\n### 4. Discovery Service\n\nThe discovery service scans for decorated methods and builds the schema.\n\n```typescript\n// discovery/subscriber-discovery.service.ts\nimport { Injectable, OnModuleInit } from '@nestjs/common';\nimport { DiscoveryService, MetadataScanner, Reflector } from '@nestjs/core';\nimport { InstanceWrapper } from '@nestjs/core/injector/instance-wrapper';\nimport {\n  createSubscriber,\n  type MatadorSchema,\n  type EventClass,\n  type Subscriber,\n  type Envelope,\n} from '@zdavison/matador';\nimport { MATADOR_EVENT_HANDLER, MATADOR_EVENT_HANDLERS } from '../constants';\nimport type { MatadorEventHandlerMetadata } from '../decorators';\n\n@Injectable()\nexport class SubscriberDiscoveryService implements OnModuleInit {\n  private schema: MatadorSchema = {};\n\n  constructor(\n    private readonly discoveryService: DiscoveryService,\n    private readonly metadataScanner: MetadataScanner,\n    private readonly reflector: Reflector,\n  ) {}\n\n  onModuleInit() {\n    this.discoverSubscribers();\n  }\n\n  private discoverSubscribers() {\n    const providers = this.discoveryService.getProviders();\n\n    for (const wrapper of providers) {\n      const { instance } = wrapper;\n      if (!instance || typeof instance !== 'object') continue;\n\n      const handlers: MatadorEventHandlerMetadata[] =\n        Reflect.getMetadata(MATADOR_EVENT_HANDLERS, instance.constructor) || [];\n\n      for (const handler of handlers) {\n        this.registerHandler(instance, handler);\n      }\n    }\n  }\n\n  private registerHandler(instance: object, metadata: MatadorEventHandlerMetadata) {\n    const { eventClass, options, methodName } = metadata;\n    const eventKey = eventClass.key;\n\n    // Create a subscriber that calls the instance method\n    const subscriber = createSubscriber({\n      name: options.name,\n      description: options.description,\n      idempotent: options.idempotent,\n      importance: options.importance,\n      targetQueue: options.targetQueue,\n      enabled: options.enabled,\n      callback: async (envelope: Envelope<unknown>) => {\n        // Call the decorated method on the NestJS-managed instance\n        await (instance as Record<string, Function>)[methodName](envelope);\n      },\n    });\n\n    // Add to schema\n    const existing = this.schema[eventKey];\n    if (existing) {\n      // Add subscriber to existing event entry\n      const [existingEventClass, existingSubscribers] = Array.isArray(existing)\n        ? existing\n        : [existing.eventClass, existing.subscribers];\n      this.schema[eventKey] = [existingEventClass, [...existingSubscribers, subscriber]];\n    } else {\n      // Create new entry\n      this.schema[eventKey] = [eventClass, [subscriber]];\n    }\n  }\n\n  getSchema(): MatadorSchema {\n    return this.schema;\n  }\n}\n```\n\n### 5. Matador Service\n\nInjectable service for sending events.\n\n```typescript\n// services/matador.service.ts\nimport { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';\nimport {\n  Matador,\n  type EventClass,\n  type Event,\n  type EventOptions,\n  type SendResult,\n} from '@zdavison/matador';\n\n@Injectable()\nexport class MatadorService implements OnModuleInit, OnModuleDestroy {\n  private matador!: Matador;\n\n  constructor(\n    @Inject(MATADOR_OPTIONS) private readonly options: MatadorModuleOptions,\n    private readonly discoveryService: SubscriberDiscoveryService,\n  ) {}\n\n  async onModuleInit() {\n    const discoveredSchema = this.discoveryService.getSchema();\n\n    // Merge with additional events from config\n    const mergedSchema = { ...discoveredSchema };\n    if (this.options.additionalEvents) {\n      for (const [eventClass, subscribers] of this.options.additionalEvents) {\n        const existing = mergedSchema[eventClass.key];\n        if (existing) {\n          const [, existingSubscribers] = Array.isArray(existing)\n            ? existing\n            : [existing.eventClass, existing.subscribers];\n          mergedSchema[eventClass.key] = [eventClass, [...existingSubscribers, ...subscribers]];\n        } else {\n          mergedSchema[eventClass.key] = [eventClass, subscribers];\n        }\n      }\n    }\n\n    this.matador = new Matador(\n      {\n        transport: this.options.transport,\n        topology: this.options.topology,\n        schema: mergedSchema,\n        consumeFrom: this.options.consumeFrom,\n        codec: this.options.codec,\n        retryPolicy: this.options.retryPolicy,\n        checkpointStore: this.options.checkpointStore,\n      },\n      this.options.hooks,\n    );\n\n    if (this.options.autoStart !== false) {\n      await this.matador.start();\n    }\n  }\n\n  async onModuleDestroy() {\n    await this.matador.shutdown();\n  }\n\n  /**\n   * Send an event to all registered subscribers.\n   */\n  async send<T>(\n    eventClass: EventClass<T>,\n    data: T,\n    options?: EventOptions,\n  ): Promise<SendResult>;\n  async send<T>(event: Event<T>, options?: EventOptions): Promise<SendResult>;\n  async send<T>(\n    eventOrClass: EventClass<T> | Event<T>,\n    dataOrOptions?: T | EventOptions,\n    options?: EventOptions,\n  ): Promise<SendResult> {\n    return this.matador.send(eventOrClass as EventClass<T>, dataOrOptions as T, options);\n  }\n\n  /**\n   * Get the underlying Matador instance for advanced operations.\n   */\n  getMatador(): Matador {\n    return this.matador;\n  }\n\n  /**\n   * Start consuming (if autoStart was false).\n   */\n  async start(): Promise<void> {\n    return this.matador.start();\n  }\n\n  /**\n   * Check if connected to transport.\n   */\n  isConnected(): boolean {\n    return this.matador.isConnected();\n  }\n\n  /**\n   * Wait for all pending messages to be processed.\n   */\n  async waitForIdle(timeoutMs?: number): Promise<boolean> {\n    return this.matador.waitForIdle(timeoutMs);\n  }\n}\n```\n\n### 6. Dynamic Module\n\n```typescript\n// module/matador.module.ts\nimport { DynamicModule, Module, Global } from '@nestjs/common';\nimport { DiscoveryModule } from '@nestjs/core';\nimport { MatadorService } from '../services/matador.service';\nimport { SubscriberDiscoveryService } from '../discovery/subscriber-discovery.service';\nimport { MATADOR_OPTIONS } from '../constants';\nimport type { MatadorModuleOptions, MatadorModuleAsyncOptions } from './matador.interfaces';\n\n@Global()\n@Module({})\nexport class MatadorModule {\n  static forRoot(options: MatadorModuleOptions): DynamicModule {\n    return {\n      module: MatadorModule,\n      imports: [DiscoveryModule],\n      providers: [\n        {\n          provide: MATADOR_OPTIONS,\n          useValue: options,\n        },\n        SubscriberDiscoveryService,\n        MatadorService,\n      ],\n      exports: [MatadorService],\n    };\n  }\n\n  static forRootAsync(options: MatadorModuleAsyncOptions): DynamicModule {\n    return {\n      module: MatadorModule,\n      imports: [DiscoveryModule, ...(options.imports || [])],\n      providers: [\n        {\n          provide: MATADOR_OPTIONS,\n          useFactory: options.useFactory,\n          inject: options.inject || [],\n        },\n        SubscriberDiscoveryService,\n        MatadorService,\n      ],\n      exports: [MatadorService],\n    };\n  }\n}\n```\n\n## Advanced Features\n\n### 1. Resumable Subscribers\n\nSupport for checkpoint-based idempotency:\n\n```typescript\nimport { OnMatadorEvent, SubscriberContext } from '@zdavison/matador-nest';\n\n@Injectable()\nexport class OrderService {\n  @OnMatadorEvent(OrderPlacedEvent, {\n    name: 'process-order',\n    description: 'Processes order with checkpoints',\n    idempotent: 'resumable',\n  })\n  async processOrder(\n    envelope: Envelope<OrderPlacedEvent['data']>,\n    context: SubscriberContext,  // Injected when idempotent: 'resumable'\n  ) {\n    const validated = await context.io('validate', () =>\n      this.validateOrder(envelope.data)\n    );\n    const charged = await context.io('charge', () =>\n      this.chargeCustomer(validated)\n    );\n    await context.io('ship', () =>\n      this.shipOrder(charged)\n    );\n  }\n}\n```\n\n**Implementation note:** When `idempotent: 'resumable'` is specified, the decorator should use `ResumableCallback` and inject `SubscriberContext` as the second parameter.\n\n### 2. Conditional Subscribers (Feature Flags)\n\n```typescript\n@Injectable()\nexport class AnalyticsService {\n  constructor(private readonly featureFlags: FeatureFlagService) {}\n\n  @OnMatadorEvent(UserCreatedEvent, {\n    name: 'track-signup',\n    description: 'Track user signup in analytics',\n    enabled: () => this.featureFlags.isEnabled('analytics'),\n  })\n  async trackSignup(envelope: Envelope<UserCreatedEvent['data']>) {\n    // ...\n  }\n}\n```\n\n**Problem:** Arrow function can't access `this` in decorator context.\n\n**Solution:** Support a string reference to a method:\n\n```typescript\n@OnMatadorEvent(UserCreatedEvent, {\n  name: 'track-signup',\n  description: 'Track user signup in analytics',\n  enabledMethod: 'isAnalyticsEnabled',  // Method name on this class\n})\nasync trackSignup(envelope) { ... }\n\nisAnalyticsEnabled(): boolean {\n  return this.featureFlags.isEnabled('analytics');\n}\n```\n\n### 3. Multiple Events per Handler\n\nHandle multiple related events with a single method:\n\n```typescript\n@OnMatadorEvent([UserCreatedEvent, UserUpdatedEvent], {\n  name: 'sync-user-to-crm',\n  description: 'Syncs user changes to CRM',\n})\nasync syncUser(envelope: Envelope<UserCreatedEvent['data'] | UserUpdatedEvent['data']>) {\n  // Handle both event types\n}\n```\n\n### 4. Testing Support\n\nProvide testing utilities:\n\n```typescript\n// testing/matador-testing.module.ts\nimport { Module } from '@nestjs/common';\nimport { LocalTransport, TopologyBuilder } from '@zdavison/matador';\nimport { MatadorModule } from '../module/matador.module';\n\n@Module({})\nexport class MatadorTestingModule {\n  static forTest(overrides?: Partial<MatadorModuleOptions>): DynamicModule {\n    return MatadorModule.forRoot({\n      transport: new LocalTransport(),\n      topology: TopologyBuilder.create()\n        .withNamespace('test')\n        .addQueue('events')\n        .build(),\n      consumeFrom: ['events'],\n      autoStart: true,\n      ...overrides,\n    });\n  }\n}\n```\n\nUsage in tests:\n\n```typescript\ndescribe('NotificationService', () => {\n  let module: TestingModule;\n  let matadorService: MatadorService;\n\n  beforeEach(async () => {\n    module = await Test.createTestingModule({\n      imports: [MatadorTestingModule.forTest()],\n      providers: [NotificationService],\n    }).compile();\n\n    matadorService = module.get(MatadorService);\n    await module.init();\n  });\n\n  it('sends welcome email on UserCreatedEvent', async () => {\n    await matadorService.send(UserCreatedEvent, {\n      userId: '123',\n      email: 'test@example.com',\n      name: 'Test User',\n    });\n\n    await matadorService.waitForIdle();\n\n    // Assert email was sent\n  });\n});\n```\n\n## Public API Summary\n\n### Decorators\n\n| Decorator                     | Description                                    |\n|-------------------------------|------------------------------------------------|\n| `@OnMatadorEvent(event, opts)`| Marks method as event subscriber               |\n| `@MatadorSubscriber()`        | Optional: explicitly marks class as subscriber |\n\n### Module\n\n| Method                          | Description                           |\n|---------------------------------|---------------------------------------|\n| `MatadorModule.forRoot(opts)`   | Sync module configuration             |\n| `MatadorModule.forRootAsync()`  | Async module configuration with DI    |\n| `MatadorTestingModule.forTest()`| Testing module with LocalTransport    |\n\n### Services\n\n| Service          | Description                                      |\n|------------------|--------------------------------------------------|\n| `MatadorService` | Injectable service for sending events            |\n\n### MatadorService Methods\n\n| Method                          | Description                                |\n|---------------------------------|--------------------------------------------|\n| `send(eventClass, data, opts?)` | Send event to subscribers                  |\n| `send(event, opts?)`            | Send event instance                        |\n| `getMatador()`                  | Get underlying Matador instance            |\n| `start()`                       | Start consuming (if autoStart=false)       |\n| `isConnected()`                 | Check transport connection                 |\n| `waitForIdle(timeout?)`         | Wait for pending messages to process       |\n\n## Dependencies\n\n```json\n{\n  \"name\": \"@zdavison/matador-nest\",\n  \"peerDependencies\": {\n    \"@nestjs/common\": \"^10.0.0 || ^11.0.0\",\n    \"@nestjs/core\": \"^10.0.0 || ^11.0.0\",\n    \"@zdavison/matador\": \"^2.0.0\",\n    \"reflect-metadata\": \"^0.1.13 || ^0.2.0\"\n  },\n  \"devDependencies\": {\n    \"@nestjs/testing\": \"^10.0.0\",\n    \"tsup\": \"^8.3.5\"\n  }\n}\n```\n\n## Implementation Steps\n\n### Phase 1: Core Foundation\n\n1. **Create package structure**\n   - Initialize `packages/matador-nest`\n   - Set up `package.json`, `tsconfig.json`, `tsup.config.ts`\n   - Configure exports\n\n2. **Implement constants and types**\n   - Define metadata keys (`MATADOR_EVENT_HANDLER`, `MATADOR_EVENT_HANDLERS`, `MATADOR_OPTIONS`)\n   - Define module option interfaces\n\n3. **Implement `@OnMatadorEvent` decorator**\n   - Store metadata on methods\n   - Maintain handler list on class\n\n4. **Implement discovery service**\n   - Scan providers for decorated methods\n   - Build schema from discovered handlers\n\n5. **Implement `MatadorService`**\n   - Initialize Matador with discovered schema\n   - Expose send/lifecycle methods\n\n6. **Implement `MatadorModule`**\n   - `forRoot()` sync configuration\n   - `forRootAsync()` async configuration\n\n### Phase 2: Advanced Features\n\n7. **Add resumable subscriber support**\n   - Detect `idempotent: 'resumable'`\n   - Inject `SubscriberContext` as second parameter\n\n8. **Add `enabledMethod` support**\n   - Resolve method reference at runtime\n   - Bind to instance\n\n9. **Add multi-event handler support**\n   - Accept array of event classes\n   - Register subscriber for each\n\n### Phase 3: Testing & Polish\n\n10. **Implement testing module**\n    - `MatadorTestingModule.forTest()`\n    - LocalTransport defaults\n\n11. **Write unit tests**\n    - Decorator metadata extraction\n    - Discovery service\n    - Module initialization\n\n12. **Write integration tests**\n    - Full event flow with NestJS app\n    - DI injection into handlers\n\n13. **Documentation**\n    - README with examples\n    - JSDoc on public APIs\n\n## Open Questions\n\n1. **Subscriber naming**: Should we auto-generate names from `ClassName.methodName` or require explicit names?\n   - **Recommendation**: Require explicit names for clarity and to match Matador conventions.\n\n2. **Schema validation**: Should we validate the discovered schema at startup and fail fast on issues?\n   - **Recommendation**: Yes, call `SchemaRegistry.validate()` in `onModuleInit`.\n\n3. **Hot reload**: Should we support subscriber hot-reload in development?\n   - **Recommendation**: Defer to future version; initial release assumes static subscriber registration.\n\n4. **Scope**: Should subscribers support request-scoped providers?\n   - **Recommendation**: Default to singleton scope (like most NestJS integrations). Document that request scope requires special handling.\n",
            "file_path": "/home/z/Desktop/work/matador/docs/plans/matador-nest.md"
          },
          "timestamp": "2025-12-11T16:55:44.183Z"
        }
      ],
      "total_additions": 1007,
      "total_deletions": 83,
      "accepted_lines": 924,
      "overriden_lines": 0
    },
    "4da23b0ffab5ea81": {
      "agent_id": {
        "tool": "claude",
        "id": "fcff30ce-2b23-49b5-a0f1-09e9d02b0d47",
        "model": "claude-opus-4-5-20251101"
      },
      "human_author": "Zachary Davison <zachary.davison@meetsmore.com>",
      "messages": [
        {
          "type": "user",
          "text": "start implementing docs/plans/matador-nest.md",
          "timestamp": "2025-12-11T17:05:03.113Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/docs/plans/matador-nest.md"
          },
          "timestamp": "2025-12-11T17:05:06.779Z"
        },
        {
          "type": "user",
          "text": "     1→# matador-nest Implementation Plan\n     2→\n     3→## Overview\n     4→\n     5→`matador-nest` is a NestJS integration package for Matador that enables decorator-based event subscriber registration. It allows NestJS developers to define event handlers using familiar patterns while leveraging Matador's transport-agnostic event processing capabilities.\n     6→\n     7→## Goals\n     8→\n     9→1. Provide `@OnMatadorEvent()` decorator for defining subscriber methods\n    10→2. Auto-discover and register subscribers at module initialization\n    11→3. Integrate with NestJS dependency injection (inject services into subscriber classes)\n    12→4. Support all Matador subscriber options (idempotency, importance, targetQueue, etc.)\n    13→5. Expose `Matador` instance through DI for sending events\n    14→6. Support both sync and async module configuration\n    15→\n    16→## Package Structure\n    17→\n    18→```\n    19→packages/matador-nest/\n    20→├── src/\n    21→│   ├── index.ts                    # Public exports\n    22→│   ├── decorators/\n    23→│   │   ├── index.ts\n    24→│   │   ├── on-matador-event.decorator.ts   # @OnMatadorEvent()\n    25→│   │   └── matador-subscriber.decorator.ts # @MatadorSubscriber() class decorator\n    26→│   ├── module/\n    27→│   │   ├── index.ts\n    28→│   │   ├── matador.module.ts       # MatadorModule (dynamic module)\n    29→│   │   ├── matador-core.module.ts  # Core module with providers\n    30→│   │   └── matador.interfaces.ts   # Module config interfaces\n    31→│   ├── discovery/\n    32→│   │   ├── index.ts\n    33→│   │   └── subscriber-discovery.service.ts # Discovers decorated methods\n    34→│   ├── services/\n    35→│   │   ├── index.ts\n    36→│   │   └── matador.service.ts      # Injectable wrapper around Matador\n    37→│   ├── constants.ts                # Metadata keys\n    38→│   └── types.ts                    # Package-specific types\n    39→├── package.json\n    40→├── tsconfig.json\n    41→├── tsup.config.ts\n    42→└── README.md\n    43→```\n    44→\n    45→## Core Components\n    46→\n    47→### 1. Decorators\n    48→\n    49→#### `@OnMatadorEvent(eventClass, options?)`\n    50→\n    51→Method decorator that marks a method as an event subscriber.\n    52→\n    53→```typescript\n    54→import { OnMatadorEvent } from '@zdavison/matador-nest';\n    55→import { UserCreatedEvent, OrderPlacedEvent } from './events';\n    56→import { Envelope } from '@zdavison/matador';\n    57→\n    58→@Injectable()\n    59→export class NotificationService {\n    60→  constructor(private readonly emailService: EmailService) {}\n    61→\n    62→  @OnMatadorEvent(UserCreatedEvent, {\n    63→    description: 'Sends welcome email',   // Required: human-readable description\n    64→    // name auto-generated as 'NotificationService.onUserCreated'\n    65→    idempotent: 'yes',                    // Optional: 'yes' | 'no' | 'unknown' | 'resumable'\n    66→    importance: 'should-investigate',     // Optional: importance level\n    67→    targetQueue: 'email-worker',          // Optional: route to specific queue\n    68→  })\n    69→  async onUserCreated(envelope: Envelope<UserCreatedEvent['data']>) {\n    70→    await this.emailService.sendWelcome(envelope.data.email);\n    71→  }\n    72→\n    73→  @OnMatadorEvent(OrderPlacedEvent, {\n    74→    name: 'custom-subscriber-name',       // Optional: override auto-generated name\n    75→    description: 'Sends order confirmation email',\n    76→  })\n    77→  async onOrderPlaced(envelope: Envelope<OrderPlacedEvent['data']>) {\n    78→    await this.emailService.sendOrderConfirmation(envelope.data);\n    79→  }\n    80→}\n    81→```\n    82→\n    83→**Implementation:**\n    84→\n    85→```typescript\n    86→// decorators/on-matador-event.decorator.ts\n    87→import { SetMetadata } from '@nestjs/common';\n    88→import type { EventClass, SubscriberOptions } from '@zdavison/matador';\n    89→import { MATADOR_EVENT_HANDLER } from '../constants';\n    90→\n    91→export interface OnMatadorEventOptions extends SubscriberOptions {\n    92→  /** Optional: override auto-generated name (default: ClassName.methodName) */\n    93→  name?: string;\n    94→  /** Required: human-readable description of what this subscriber does */\n    95→  description: string;\n    96→}\n    97→\n    98→export interface MatadorEventHandlerMetadata {\n    99→  eventClass: EventClass<unknown>;\n   100→  options: OnMatadorEventOptions;\n   101→  methodName: string;\n   102→}\n   103→\n   104→export function OnMatadorEvent<T>(\n   105→  eventClass: EventClass<T>,\n   106→  options: OnMatadorEventOptions,\n   107→): MethodDecorator {\n   108→  return (target, propertyKey, descriptor) => {\n   109→    const metadata: MatadorEventHandlerMetadata = {\n   110→      eventClass,\n   111→      options,\n   112→      methodName: String(propertyKey),\n   113→    };\n   114→\n   115→    // Store metadata on the method\n   116→    SetMetadata(MATADOR_EVENT_HANDLER, metadata)(target, propertyKey, descriptor);\n   117→\n   118→    // Also maintain a list on the class for discovery\n   119→    const existingHandlers = Reflect.getMetadata(MATADOR_EVENT_HANDLERS, target.constructor) || [];\n   120→    Reflect.defineMetadata(\n   121→      MATADOR_EVENT_HANDLERS,\n   122→      [...existingHandlers, metadata],\n   123→      target.constructor,\n   124→    );\n   125→\n   126→    return descriptor;\n   127→  };\n   128→}\n   129→```\n   130→\n   131→#### `@MatadorSubscriber()` (Optional Class Decorator)\n   132→\n   133→Optional class decorator for explicit registration. If not used, any class with `@OnMatadorEvent` methods will be auto-discovered.\n   134→\n   135→```typescript\n   136→@MatadorSubscriber()\n   137→@Injectable()\n   138→export class NotificationService {\n   139→  // ...\n   140→}\n   141→```\n   142→\n   143→### 2. Module Configuration\n   144→\n   145→#### `MatadorModule.forRoot(options)`\n   146→\n   147→Synchronous configuration for simple setups.\n   148→\n   149→```typescript\n   150→// app.module.ts\n   151→import { Module } from '@nestjs/common';\n   152→import { MatadorModule } from '@zdavison/matador-nest';\n   153→import { RabbitMQTransport, TopologyBuilder } from '@zdavison/matador';\n   154→\n   155→@Module({\n   156→  imports: [\n   157→    MatadorModule.forRoot({\n   158→      transport: new RabbitMQTransport({ url: 'amqp://localhost' }),\n   159→      topology: TopologyBuilder.create()\n   160→        .withNamespace('myapp')\n   161→        .addQueue('events', { concurrency: 10 })\n   162→        .build(),\n   163→      consumeFrom: ['events'],\n   164→      // events are auto-discovered from @OnMatadorEvent decorators\n   165→    }),\n   166→  ],\n   167→})\n   168→export class AppModule {}\n   169→```\n   170→\n   171→#### `MatadorModule.forRootAsync(options)`\n   172→\n   173→Async configuration for injecting dependencies (ConfigService, etc.).\n   174→\n   175→```typescript\n   176→// app.module.ts\n   177→import { Module } from '@nestjs/common';\n   178→import { ConfigModule, ConfigService } from '@nestjs/config';\n   179→import { MatadorModule } from '@zdavison/matador-nest';\n   180→import { RabbitMQTransport, TopologyBuilder } from '@zdavison/matador';\n   181→\n   182→@Module({\n   183→  imports: [\n   184→    ConfigModule.forRoot(),\n   185→    MatadorModule.forRootAsync({\n   186→      imports: [ConfigModule],\n   187→      inject: [ConfigService],\n   188→      useFactory: (config: ConfigService) => ({\n   189→        transport: new RabbitMQTransport({\n   190→          url: config.get('RABBITMQ_URL'),\n   191→        }),\n   192→        topology: TopologyBuilder.create()\n   193→          .withNamespace(config.get('APP_NAME'))\n   194→          .addQueue('events', { concurrency: 10 })\n   195→          .build(),\n   196→        consumeFrom: ['events'],\n   197→      }),\n   198→    }),\n   199→  ],\n   200→})\n   201→export class AppModule {}\n   202→```\n   203→\n   204→### 3. Module Interfaces\n   205→\n   206→```typescript\n   207→// module/matador.interfaces.ts\n   208→import type {\n   209→  Topology,\n   210→  Transport,\n   211→  MatadorHooks,\n   212→  RetryPolicy,\n   213→  Codec,\n   214→  CheckpointStore,\n   215→  EventClass,\n   216→  AnySubscriber,\n   217→} from '@zdavison/matador';\n   218→import type { ModuleMetadata, Type } from '@nestjs/common';\n   219→\n   220→export interface MatadorModuleOptions {\n   221→  /** Transport implementation (RabbitMQTransport, LocalTransport, etc.) */\n   222→  transport: Transport;\n   223→\n   224→  /** Queue topology configuration */\n   225→  topology: Topology;\n   226→\n   227→  /** Queues to consume from (if acting as a consumer) */\n   228→  consumeFrom?: string[];\n   229→\n   230→  /** Optional codec (defaults to JsonCodec) */\n   231→  codec?: Codec;\n   232→\n   233→  /** Optional retry policy */\n   234→  retryPolicy?: RetryPolicy;\n   235→\n   236→  /** Optional lifecycle hooks */\n   237→  hooks?: MatadorHooks;\n   238→\n   239→  /** Optional checkpoint store for resumable subscribers */\n   240→  checkpointStore?: CheckpointStore;\n   241→\n   242→  /**\n   243→   * Shutdown configuration for graceful shutdown behavior.\n   244→   */\n   245→  shutdownConfig?: {\n   246→    /** Time to wait for in-flight messages to complete (default: 30000ms) */\n   247→    drainTimeoutMs?: number;\n   248→  };\n   249→\n   250→  /**\n   251→   * Additional events to register (for events without decorated subscribers).\n   252→   * Maps event class to subscriber stubs or external subscribers.\n   253→   */\n   254→  additionalEvents?: Map<EventClass<unknown>, AnySubscriber[]>;\n   255→\n   256→  /**\n   257→   * Whether to auto-start consuming.\n   258→   * Default: true\n   259→   */\n   260→  autoStart?: boolean;\n   261→\n   262→  /**\n   263→   * Which NestJS lifecycle hook to start Matador on.\n   264→   * - 'onModuleInit': Start when MatadorModule initializes (earliest)\n   265→   * - 'onApplicationBootstrap': Start after all modules init (default, recommended)\n   266→   *\n   267→   * Use 'onModuleInit' if other modules depend on Matador being connected\n   268→   * during their own onModuleInit/onApplicationBootstrap hooks.\n   269→   *\n   270→   * Default: 'onApplicationBootstrap'\n   271→   */\n   272→  startOn?: 'onModuleInit' | 'onApplicationBootstrap';\n   273→\n   274→  /**\n   275→   * Global subscriber options applied to all discovered subscribers.\n   276→   */\n   277→  globalSubscriberDefaults?: {\n   278→    importance?: 'can-ignore' | 'should-investigate' | 'must-investigate';\n   279→    idempotent?: 'yes' | 'no' | 'unknown';\n   280→  };\n   281→}\n   282→\n   283→export interface MatadorModuleAsyncOptions extends Pick<ModuleMetadata, 'imports'> {\n   284→  inject?: any[];\n   285→  useFactory: (...args: any[]) => Promise<MatadorModuleOptions> | MatadorModuleOptions;\n   286→  useClass?: Type<MatadorOptionsFactory>;\n   287→  useExisting?: Type<MatadorOptionsFactory>;\n   288→}\n   289→\n   290→export interface MatadorOptionsFactory {\n   291→  createMatadorOptions(): Promise<MatadorModuleOptions> | MatadorModuleOptions;\n   292→}\n   293→```\n   294→\n   295→### 4. Discovery Service\n   296→\n   297→The discovery service scans for decorated methods and builds the schema.\n   298→\n   299→```typescript\n   300→// discovery/subscriber-discovery.service.ts\n   301→import { Injectable, OnModuleInit } from '@nestjs/common';\n   302→import { DiscoveryService, MetadataScanner, Reflector } from '@nestjs/core';\n   303→import { InstanceWrapper } from '@nestjs/core/injector/instance-wrapper';\n   304→import {\n   305→  createSubscriber,\n   306→  type MatadorSchema,\n   307→  type EventClass,\n   308→  type Subscriber,\n   309→  type Envelope,\n   310→} from '@zdavison/matador';\n   311→import { MATADOR_EVENT_HANDLER, MATADOR_EVENT_HANDLERS } from '../constants';\n   312→import type { MatadorEventHandlerMetadata } from '../decorators';\n   313→\n   314→@Injectable()\n   315→export class SubscriberDiscoveryService implements OnModuleInit {\n   316→  private schema: MatadorSchema = {};\n   317→\n   318→  constructor(\n   319→    private readonly discoveryService: DiscoveryService,\n   320→    private readonly metadataScanner: MetadataScanner,\n   321→    private readonly reflector: Reflector,\n   322→  ) {}\n   323→\n   324→  onModuleInit() {\n   325→    this.discoverSubscribers();\n   326→  }\n   327→\n   328→  private discoverSubscribers() {\n   329→    const providers = this.discoveryService.getProviders();\n   330→\n   331→    for (const wrapper of providers) {\n   332→      const { instance } = wrapper;\n   333→      if (!instance || typeof instance !== 'object') continue;\n   334→\n   335→      const handlers: MatadorEventHandlerMetadata[] =\n   336→        Reflect.getMetadata(MATADOR_EVENT_HANDLERS, instance.constructor) || [];\n   337→\n   338→      for (const handler of handlers) {\n   339→        this.registerHandler(instance, handler);\n   340→      }\n   341→    }\n   342→  }\n   343→\n   344→  private registerHandler(instance: object, metadata: MatadorEventHandlerMetadata) {\n   345→    const { eventClass, options, methodName } = metadata;\n   346→    const eventKey = eventClass.key;\n   347→    const className = instance.constructor.name;\n   348→\n   349→    // Auto-generate name if not provided: ClassName.methodName\n   350→    const subscriberName = options.name ?? `${className}.${methodName}`;\n   351→\n   352→    // Create a subscriber that calls the instance method\n   353→    const subscriber = createSubscriber({\n   354→      name: subscriberName,\n   355→      description: options.description,\n   356→      idempotent: options.idempotent,\n   357→      importance: options.importance,\n   358→      targetQueue: options.targetQueue,\n   359→      enabled: options.enabled,\n   360→      callback: async (envelope: Envelope<unknown>) => {\n   361→        // Call the decorated method on the NestJS-managed instance\n   362→        await (instance as Record<string, Function>)[methodName](envelope);\n   363→      },\n   364→    });\n   365→\n   366→    // Add to schema\n   367→    const existing = this.schema[eventKey];\n   368→    if (existing) {\n   369→      // Add subscriber to existing event entry\n   370→      const [existingEventClass, existingSubscribers] = Array.isArray(existing)\n   371→        ? existing\n   372→        : [existing.eventClass, existing.subscribers];\n   373→      this.schema[eventKey] = [existingEventClass, [...existingSubscribers, subscriber]];\n   374→    } else {\n   375→      // Create new entry\n   376→      this.schema[eventKey] = [eventClass, [subscriber]];\n   377→    }\n   378→  }\n   379→\n   380→  getSchema(): MatadorSchema {\n   381→    return this.schema;\n   382→  }\n   383→}\n   384→```\n   385→\n   386→### 5. Matador Service\n   387→\n   388→Injectable service for sending events with proper NestJS lifecycle integration.\n   389→\n   390→```typescript\n   391→// services/matador.service.ts\n   392→import {\n   393→  Injectable,\n   394→  Inject,\n   395→  OnModuleInit,\n   396→  OnApplicationBootstrap,\n   397→  BeforeApplicationShutdown,\n   398→  OnApplicationShutdown,\n   399→} from '@nestjs/common';\n   400→import {\n   401→  Matador,\n   402→  type EventClass,\n   403→  type Event,\n   404→  type EventOptions,\n   405→  type SendResult,\n   406→} from '@zdavison/matador';\n   407→import { MATADOR_OPTIONS } from '../constants';\n   408→import type { MatadorModuleOptions } from '../module/matador.interfaces';\n   409→import { SubscriberDiscoveryService } from '../discovery/subscriber-discovery.service';\n   410→\n   411→@Injectable()\n   412→export class MatadorService implements OnModuleInit, OnApplicationBootstrap, BeforeApplicationShutdown, OnApplicationShutdown {\n   413→  private matador!: Matador;\n   414→  private isShuttingDown = false;\n   415→  private isStarted = false;\n   416→\n   417→  constructor(\n   418→    @Inject(MATADOR_OPTIONS) private readonly options: MatadorModuleOptions,\n   419→    private readonly discoveryService: SubscriberDiscoveryService,\n   420→  ) {\n   421→    // Build Matador instance immediately (but don't start yet)\n   422→    this.initializeMatador();\n   423→  }\n   424→\n   425→  /**\n   426→   * Called when MatadorModule is initialized.\n   427→   * Starts Matador if startOn === 'onModuleInit'.\n   428→   */\n   429→  async onModuleInit() {\n   430→    if (this.shouldAutoStart() && this.options.startOn === 'onModuleInit') {\n   431→      await this.doStart();\n   432→    }\n   433→  }\n   434→\n   435→  private initializeMatador() {\n   436→    const discoveredSchema = this.discoveryService.getSchema();\n   437→\n   438→    // Merge with additional events from config\n   439→    const mergedSchema = { ...discoveredSchema };\n   440→    if (this.options.additionalEvents) {\n   441→      for (const [eventClass, subscribers] of this.options.additionalEvents) {\n   442→        const existing = mergedSchema[eventClass.key];\n   443→        if (existing) {\n   444→          const [, existingSubscribers] = Array.isArray(existing)\n   445→            ? existing\n   446→            : [existing.eventClass, existing.subscribers];\n   447→          mergedSchema[eventClass.key] = [eventClass, [...existingSubscribers, ...subscribers]];\n   448→        } else {\n   449→          mergedSchema[eventClass.key] = [eventClass, subscribers];\n   450→        }\n   451→      }\n   452→    }\n   453→\n   454→    // Validate schema at startup\n   455→    const registry = new SchemaRegistry();\n   456→    for (const [key, entry] of Object.entries(mergedSchema)) {\n   457→      const [eventClass, subscribers] = Array.isArray(entry)\n   458→        ? entry\n   459→        : [entry.eventClass, entry.subscribers];\n   460→      registry.register(eventClass, subscribers);\n   461→    }\n   462→    const validation = registry.validate();\n   463→    if (!validation.valid) {\n   464→      throw new Error(\n   465→        `Invalid Matador schema: ${validation.issues.map(i => i.message).join(', ')}`\n   466→      );\n   467→    }\n   468→\n   469→    this.matador = new Matador(\n   470→      {\n   471→        transport: this.options.transport,\n   472→        topology: this.options.topology,\n   473→        schema: mergedSchema,\n   474→        consumeFrom: this.options.consumeFrom,\n   475→        codec: this.options.codec,\n   476→        retryPolicy: this.options.retryPolicy,\n   477→        checkpointStore: this.options.checkpointStore,\n   478→        shutdownConfig: this.options.shutdownConfig,\n   479→      },\n   480→      this.options.hooks,\n   481→    );\n   482→  }\n   483→\n   484→  private shouldAutoStart(): boolean {\n   485→    return this.options.autoStart !== false;\n   486→  }\n   487→\n   488→  private async doStart() {\n   489→    if (this.isStarted) return;\n   490→    await this.matador.start();\n   491→    this.isStarted = true;\n   492→  }\n   493→\n   494→  /**\n   495→   * Called after all modules are initialized and the app is ready to start.\n   496→   * Starts Matador if startOn === 'onApplicationBootstrap' (default).\n   497→   */\n   498→  async onApplicationBootstrap() {\n   499→    const startOn = this.options.startOn ?? 'onApplicationBootstrap';\n   500→    if (this.shouldAutoStart() && startOn === 'onApplicationBootstrap') {\n   501→      await this.doStart();\n   502→    }\n   503→  }\n   504→\n   505→  /**\n   506→   * Called when the application receives a shutdown signal (SIGTERM, etc).\n   507→   * Stop accepting new messages and wait for in-flight messages to complete.\n   508→   */\n   509→  async beforeApplicationShutdown(signal?: string) {\n   510→    this.isShuttingDown = true;\n   511→\n   512→    // Wait for in-flight messages to complete (with configurable timeout)\n   513→    const timeoutMs = this.options.shutdownConfig?.drainTimeoutMs ?? 30000;\n   514→    await this.matador.waitForIdle(timeoutMs);\n   515→  }\n   516→\n   517→  /**\n   518→   * Called after beforeApplicationShutdown completes.\n   519→   * Disconnect from transport and clean up resources.\n   520→   */\n   521→  async onApplicationShutdown(signal?: string) {\n   522→    await this.matador.shutdown();\n   523→  }\n   524→\n   525→  /**\n   526→   * Send an event to all registered subscribers.\n   527→   * Throws if called during shutdown.\n   528→   */\n   529→  async send<T>(\n   530→    eventClass: EventClass<T>,\n   531→    data: T,\n   532→    options?: EventOptions,\n   533→  ): Promise<SendResult>;\n   534→  async send<T>(event: Event<T>, options?: EventOptions): Promise<SendResult>;\n   535→  async send<T>(\n   536→    eventOrClass: EventClass<T> | Event<T>,\n   537→    dataOrOptions?: T | EventOptions,\n   538→    options?: EventOptions,\n   539→  ): Promise<SendResult> {\n   540→    if (this.isShuttingDown) {\n   541→      throw new Error('Cannot send events during shutdown');\n   542→    }\n   543→    return this.matador.send(eventOrClass as EventClass<T>, dataOrOptions as T, options);\n   544→  }\n   545→\n   546→  /**\n   547→   * Get the underlying Matador instance for advanced operations.\n   548→   */\n   549→  getMatador(): Matador {\n   550→    return this.matador;\n   551→  }\n   552→\n   553→  /**\n   554→   * Start consuming (if autoStart was false).\n   555→   */\n   556→  async start(): Promise<void> {\n   557→    return this.matador.start();\n   558→  }\n   559→\n   560→  /**\n   561→   * Check if connected to transport.\n   562→   */\n   563→  isConnected(): boolean {\n   564→    return this.matador.isConnected();\n   565→  }\n   566→\n   567→  /**\n   568→   * Check if shutdown is in progress.\n   569→   */\n   570→  isShutdownInProgress(): boolean {\n   571→    return this.isShuttingDown;\n   572→  }\n   573→\n   574→  /**\n   575→   * Wait for all pending messages to be processed.\n   576→   */\n   577→  async waitForIdle(timeoutMs?: number): Promise<boolean> {\n   578→    return this.matador.waitForIdle(timeoutMs);\n   579→  }\n   580→}\n   581→```\n   582→\n   583→### 6. Dynamic Module\n   584→\n   585→```typescript\n   586→// module/matador.module.ts\n   587→import { DynamicModule, Module, Global } from '@nestjs/common';\n   588→import { DiscoveryModule } from '@nestjs/core';\n   589→import { MatadorService } from '../services/matador.service';\n   590→import { SubscriberDiscoveryService } from '../discovery/subscriber-discovery.service';\n   591→import { MATADOR_OPTIONS } from '../constants';\n   592→import type { MatadorModuleOptions, MatadorModuleAsyncOptions } from './matador.interfaces';\n   593→\n   594→@Global()\n   595→@Module({})\n   596→export class MatadorModule {\n   597→  static forRoot(options: MatadorModuleOptions): DynamicModule {\n   598→    return {\n   599→      module: MatadorModule,\n   600→      imports: [DiscoveryModule],\n   601→      providers: [\n   602→        {\n   603→          provide: MATADOR_OPTIONS,\n   604→          useValue: options,\n   605→        },\n   606→        SubscriberDiscoveryService,\n   607→        MatadorService,\n   608→      ],\n   609→      exports: [MatadorService],\n   610→    };\n   611→  }\n   612→\n   613→  static forRootAsync(options: MatadorModuleAsyncOptions): DynamicModule {\n   614→    return {\n   615→      module: MatadorModule,\n   616→      imports: [DiscoveryModule, ...(options.imports || [])],\n   617→      providers: [\n   618→        {\n   619→          provide: MATADOR_OPTIONS,\n   620→          useFactory: options.useFactory,\n   621→          inject: options.inject || [],\n   622→        },\n   623→        SubscriberDiscoveryService,\n   624→        MatadorService,\n   625→      ],\n   626→      exports: [MatadorService],\n   627→    };\n   628→  }\n   629→}\n   630→```\n   631→\n   632→## Advanced Features\n   633→\n   634→### 1. Resumable Subscribers\n   635→\n   636→Support for checkpoint-based idempotency:\n   637→\n   638→```typescript\n   639→import { OnMatadorEvent, SubscriberContext } from '@zdavison/matador-nest';\n   640→\n   641→@Injectable()\n   642→export class OrderService {\n   643→  @OnMatadorEvent(OrderPlacedEvent, {\n   644→    name: 'process-order',\n   645→    description: 'Processes order with checkpoints',\n   646→    idempotent: 'resumable',\n   647→  })\n   648→  async processOrder(\n   649→    envelope: Envelope<OrderPlacedEvent['data']>,\n   650→    context: SubscriberContext,  // Injected when idempotent: 'resumable'\n   651→  ) {\n   652→    const validated = await context.io('validate', () =>\n   653→      this.validateOrder(envelope.data)\n   654→    );\n   655→    const charged = await context.io('charge', () =>\n   656→      this.chargeCustomer(validated)\n   657→    );\n   658→    await context.io('ship', () =>\n   659→      this.shipOrder(charged)\n   660→    );\n   661→  }\n   662→}\n   663→```\n   664→\n   665→**Implementation note:** When `idempotent: 'resumable'` is specified, the decorator should use `ResumableCallback` and inject `SubscriberContext` as the second parameter.\n   666→\n   667→### 2. Conditional Subscribers (Feature Flags)\n   668→\n   669→```typescript\n   670→@Injectable()\n   671→export class AnalyticsService {\n   672→  constructor(private readonly featureFlags: FeatureFlagService) {}\n   673→\n   674→  @OnMatadorEvent(UserCreatedEvent, {\n   675→    name: 'track-signup',\n   676→    description: 'Track user signup in analytics',\n   677→  })\n   678→  async trackSignup(envelope: Envelope<UserCreatedEvent['data']>) {\n   679→    // ...\n   680→  }\n   681→\n   682→  // Method referenced by symbol for type-safe feature flag\n   683→  @MatadorEnabled(AnalyticsService.prototype.trackSignup)\n   684→  isTrackSignupEnabled(): boolean {\n   685→    return this.featureFlags.isEnabled('analytics');\n   686→  }\n   687→}\n   688→```\n   689→\n   690→**Problem:** Arrow function in decorator can't access `this` context.\n   691→\n   692→**Solution:** Use a separate `@MatadorEnabled()` decorator that links to the handler method via direct reference:\n   693→\n   694→```typescript\n   695→// decorators/matador-enabled.decorator.ts\n   696→export function MatadorEnabled<T>(\n   697→  handlerMethod: (envelope: Envelope<T>) => Promise<void> | void,\n   698→): MethodDecorator {\n   699→  return (target, propertyKey, descriptor) => {\n   700→    // Store a reference from the handler method to this enabled-check method\n   701→    const handlerName = handlerMethod.name;\n   702→    Reflect.defineMetadata(\n   703→      MATADOR_ENABLED_METHOD,\n   704→      propertyKey,\n   705→      target.constructor,\n   706→      handlerName,\n   707→    );\n   708→    return descriptor;\n   709→  };\n   710→}\n   711→```\n   712→\n   713→This approach:\n   714→- Uses direct method reference (refactor-safe)\n   715→- TypeScript will error if `trackSignup` is renamed/removed\n   716→- Discovery service looks up the enabled method at runtime and binds to instance\n   717→\n   718→**Alternative (simpler):** Don't support `enabled` in the decorator at all. Users can handle conditional logic inside the callback or use Matador's global plugin system with exclusions.\n   719→\n   720→### 3. Testing Support\n   721→\n   722→Provide testing utilities:\n   723→\n   724→```typescript\n   725→// testing/matador-testing.module.ts\n   726→import { Module } from '@nestjs/common';\n   727→import { LocalTransport, TopologyBuilder } from '@zdavison/matador';\n   728→import { MatadorModule } from '../module/matador.module';\n   729→\n   730→@Module({})\n   731→export class MatadorTestingModule {\n   732→  static forTest(overrides?: Partial<MatadorModuleOptions>): DynamicModule {\n   733→    return MatadorModule.forRoot({\n   734→      transport: new LocalTransport(),\n   735→      topology: TopologyBuilder.create()\n   736→        .withNamespace('test')\n   737→        .addQueue('events')\n   738→        .build(),\n   739→      consumeFrom: ['events'],\n   740→      autoStart: true,\n   741→      ...overrides,\n   742→    });\n   743→  }\n   744→}\n   745→```\n   746→\n   747→Usage in tests:\n   748→\n   749→```typescript\n   750→describe('NotificationService', () => {\n   751→  let module: TestingModule;\n   752→  let matadorService: MatadorService;\n   753→\n   754→  beforeEach(async () => {\n   755→    module = await Test.createTestingModule({\n   756→      imports: [MatadorTestingModule.forTest()],\n   757→      providers: [NotificationService],\n   758→    }).compile();\n   759→\n   760→    matadorService = module.get(MatadorService);\n   761→    await module.init();\n   762→  });\n   763→\n   764→  it('sends welcome email on UserCreatedEvent', async () => {\n   765→    await matadorService.send(UserCreatedEvent, {\n   766→      userId: '123',\n   767→      email: 'test@example.com',\n   768→      name: 'Test User',\n   769→    });\n   770→\n   771→    await matadorService.waitForIdle();\n   772→\n   773→    // Assert email was sent\n   774→  });\n   775→});\n   776→```\n   777→\n   778→## Public API Summary\n   779→\n   780→### Decorators\n   781→\n   782→| Decorator                     | Description                                    |\n   783→|-------------------------------|------------------------------------------------|\n   784→| `@OnMatadorEvent(event, opts)`| Marks method as event subscriber               |\n   785→| `@MatadorSubscriber()`        | Optional: explicitly marks class as subscriber |\n   786→\n   787→### Module\n   788→\n   789→| Method                          | Description                           |\n   790→|---------------------------------|---------------------------------------|\n   791→| `MatadorModule.forRoot(opts)`   | Sync module configuration             |\n   792→| `MatadorModule.forRootAsync()`  | Async module configuration with DI    |\n   793→| `MatadorTestingModule.forTest()`| Testing module with LocalTransport    |\n   794→\n   795→### Services\n   796→\n   797→| Service          | Description                                      |\n   798→|------------------|--------------------------------------------------|\n   799→| `MatadorService` | Injectable service for sending events            |\n   800→\n   801→### MatadorService Methods\n   802→\n   803→| Method                          | Description                                     |\n   804→|---------------------------------|-------------------------------------------------|\n   805→| `send(eventClass, data, opts?)` | Send event to subscribers                       |\n   806→| `send(event, opts?)`            | Send event instance                             |\n   807→| `getMatador()`                  | Get underlying Matador instance                 |\n   808→| `start()`                       | Start consuming (if autoStart=false)            |\n   809→| `isConnected()`                 | Check transport connection                      |\n   810→| `isShutdownInProgress()`        | Check if graceful shutdown is in progress       |\n   811→| `waitForIdle(timeout?)`         | Wait for pending messages to process            |\n   812→\n   813→### Lifecycle Integration\n   814→\n   815→The `MatadorService` integrates with NestJS lifecycle hooks for graceful startup and shutdown:\n   816→\n   817→| NestJS Hook                  | Matador Action                                          |\n   818→|------------------------------|---------------------------------------------------------|\n   819→| `OnModuleInit`               | Start consuming (if `startOn: 'onModuleInit'`)          |\n   820→| `OnApplicationBootstrap`     | Start consuming (if `startOn: 'onApplicationBootstrap'`, default) |\n   821→| `BeforeApplicationShutdown`  | Stop accepting new events, drain in-flight messages     |\n   822→| `OnApplicationShutdown`      | Disconnect from transport and clean up resources        |\n   823→\n   824→**Startup options:**\n   825→- `startOn: 'onApplicationBootstrap'` (default): Start after all modules are initialized. Recommended for most cases.\n   826→- `startOn: 'onModuleInit'`: Start when MatadorModule initializes. Use when other modules depend on Matador being connected during their initialization.\n   827→\n   828→**Graceful shutdown flow:**\n   829→1. App receives shutdown signal (SIGTERM, etc.)\n   830→2. `beforeApplicationShutdown`: Sets shutdown flag, waits for in-flight messages (configurable `drainTimeoutMs`, default 30s)\n   831→3. `onApplicationShutdown`: Calls `matador.shutdown()` to disconnect transport\n   832→4. Sending events during shutdown throws an error\n   833→\n   834→## Dependencies\n   835→\n   836→```json\n   837→{\n   838→  \"name\": \"@zdavison/matador-nest\",\n   839→  \"peerDependencies\": {\n   840→    \"@nestjs/common\": \"^10.0.0 || ^11.0.0\",\n   841→    \"@nestjs/core\": \"^10.0.0 || ^11.0.0\",\n   842→    \"@zdavison/matador\": \"^2.0.0\",\n   843→    \"reflect-metadata\": \"^0.1.13 || ^0.2.0\"\n   844→  },\n   845→  \"devDependencies\": {\n   846→    \"@nestjs/testing\": \"^10.0.0\",\n   847→    \"tsup\": \"^8.3.5\"\n   848→  }\n   849→}\n   850→```\n   851→\n   852→## Implementation Steps\n   853→\n   854→### Phase 1: Core Foundation\n   855→\n   856→1. **Create package structure**\n   857→   - Initialize `packages/matador-nest`\n   858→   - Set up `package.json`, `tsconfig.json`, `tsup.config.ts`\n   859→   - Configure exports\n   860→\n   861→2. **Implement constants and types**\n   862→   - Define metadata keys (`MATADOR_EVENT_HANDLER`, `MATADOR_EVENT_HANDLERS`, `MATADOR_OPTIONS`)\n   863→   - Define module option interfaces\n   864→\n   865→3. **Implement `@OnMatadorEvent` decorator**\n   866→   - Store metadata on methods\n   867→   - Maintain handler list on class\n   868→\n   869→4. **Implement discovery service**\n   870→   - Scan providers for decorated methods\n   871→   - Build schema from discovered handlers\n   872→\n   873→5. **Implement `MatadorService`**\n   874→   - Initialize Matador with discovered schema\n   875→   - Expose send/lifecycle methods\n   876→\n   877→6. **Implement `MatadorModule`**\n   878→   - `forRoot()` sync configuration\n   879→   - `forRootAsync()` async configuration\n   880→\n   881→### Phase 2: Advanced Features\n   882→\n   883→7. **Add resumable subscriber support**\n   884→   - Detect `idempotent: 'resumable'`\n   885→   - Inject `SubscriberContext` as second parameter\n   886→\n   887→8. **Add `@MatadorEnabled()` decorator** (optional)\n   888→   - Link enabled-check method to handler via method reference\n   889→   - Discover and bind at runtime\n   890→\n   891→### Phase 3: Testing & Polish\n   892→\n   893→9. **Implement testing module**\n   894→    - `MatadorTestingModule.forTest()`\n   895→    - LocalTransport defaults\n   896→\n   897→10. **Write unit tests**\n   898→    - Decorator metadata extraction\n   899→    - Discovery service\n   900→    - Module initialization\n   901→\n   902→11. **Write integration tests**\n   903→    - Full event flow with NestJS app\n   904→    - DI injection into handlers\n   905→\n   906→12. **Documentation**\n   907→    - README with examples\n   908→    - JSDoc on public APIs\n   909→\n   910→## Decisions\n   911→\n   912→1. **Subscriber naming**: Auto-generate using format `ClassName.methodName`, but allow optional `name` override in decorator options.\n   913→\n   914→2. **Multiple events per handler**: Not supported. One `@OnMatadorEvent` decorator = one event type.\n   915→\n   916→3. **Feature flags (`enabled`)**: Two options:\n   917→   - **Option A (recommended for simplicity):** Don't support in decorator. Users handle conditional logic in callback or use Matador's plugin system.\n   918→   - **Option B:** Separate `@MatadorEnabled(handlerMethodRef)` decorator with type-safe method reference (refactor-safe).\n   919→\n   920→4. **Schema validation**: Yes, validate discovered schema at startup and fail fast on issues.\n   921→\n   922→5. **Hot reload**: Not supported. Static subscriber registration only.\n   923→\n   924→6. **Scope**: Singleton scope only. Request-scoped providers not supported.\n   925→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T17:05:07.115Z"
        },
        {
          "type": "assistant",
          "text": "This is a comprehensive implementation plan for `matador-nest`. Let me start implementing it now.",
          "timestamp": "2025-12-11T17:05:10.916Z"
        },
        {
          "type": "tool_use",
          "name": "TodoWrite",
          "input": {
            "todos": [
              {
                "activeForm": "Creating package structure",
                "content": "Create package structure (package.json, tsconfig.json, tsup.config.ts)",
                "status": "in_progress"
              },
              {
                "activeForm": "Implementing constants and types",
                "content": "Implement constants and types",
                "status": "pending"
              },
              {
                "activeForm": "Implementing @OnMatadorEvent decorator",
                "content": "Implement @OnMatadorEvent decorator",
                "status": "pending"
              },
              {
                "activeForm": "Implementing discovery service",
                "content": "Implement discovery service",
                "status": "pending"
              },
              {
                "activeForm": "Implementing MatadorService",
                "content": "Implement MatadorService",
                "status": "pending"
              },
              {
                "activeForm": "Implementing MatadorModule",
                "content": "Implement MatadorModule (forRoot and forRootAsync)",
                "status": "pending"
              },
              {
                "activeForm": "Adding resumable subscriber support",
                "content": "Add resumable subscriber support",
                "status": "pending"
              },
              {
                "activeForm": "Implementing testing module",
                "content": "Implement testing module",
                "status": "pending"
              },
              {
                "activeForm": "Writing unit tests",
                "content": "Write unit tests",
                "status": "pending"
              },
              {
                "activeForm": "Creating index.ts exports",
                "content": "Create index.ts exports",
                "status": "pending"
              }
            ]
          },
          "timestamp": "2025-12-11T17:05:14.259Z"
        },
        {
          "type": "user",
          "text": "Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable",
          "timestamp": "2025-12-11T17:05:14.315Z"
        },
        {
          "type": "assistant",
          "text": "Let me first look at the existing matador package structure to understand the patterns and APIs I need to integrate with.",
          "timestamp": "2025-12-11T17:05:17.955Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/package.json"
          },
          "timestamp": "2025-12-11T17:05:18.848Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/tsconfig.json"
          },
          "timestamp": "2025-12-11T17:05:19.165Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/tsup.config.ts"
          },
          "timestamp": "2025-12-11T17:05:19.610Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/index.ts"
          },
          "timestamp": "2025-12-11T17:05:20.034Z"
        },
        {
          "type": "user",
          "text": "     1→{\n     2→  \"name\": \"@zdavison/matador\",\n     3→  \"version\": \"2.0.0\",\n     4→  \"description\": \"A batteries-included event system.\",\n     5→  \"type\": \"module\",\n     6→  \"main\": \"./dist/index.cjs\",\n     7→  \"module\": \"./dist/index.js\",\n     8→  \"types\": \"./dist/index.d.ts\",\n     9→  \"exports\": {\n    10→    \".\": {\n    11→      \"import\": {\n    12→        \"types\": \"./dist/index.d.ts\",\n    13→        \"default\": \"./dist/index.js\"\n    14→      },\n    15→      \"require\": {\n    16→        \"types\": \"./dist/index.d.cts\",\n    17→        \"default\": \"./dist/index.cjs\"\n    18→      }\n    19→    }\n    20→  },\n    21→  \"bin\": {\n    22→    \"matador\": \"./cli.ts\"\n    23→  },\n    24→  \"scripts\": {\n    25→    \"build\": \"tsup\",\n    26→    \"test\": \"bun test\",\n    27→    \"test:watch\": \"bun test --watch\",\n    28→    \"test:integration\": \"bun test --grep integration\",\n    29→    \"lint\": \"bunx biome check .\",\n    30→    \"lint:fix\": \"bunx biome check . --fix\",\n    31→    \"typecheck\": \"tsc --noEmit\",\n    32→    \"clean\": \"rm -rf dist\",\n    33→    \"cli\": \"bun ./cli.ts\",\n    34→    \"send-test-event\": \"bun ./cli.ts ./examples/config.ts ./examples/event.ts\"\n    35→  },\n    36→  \"dependencies\": {\n    37→    \"amqplib\": \"^0.10.4\"\n    38→  },\n    39→  \"devDependencies\": {\n    40→    \"@testcontainers/rabbitmq\": \"^10.16.0\",\n    41→    \"@types/amqplib\": \"^0.10.5\",\n    42→    \"testcontainers\": \"^10.16.0\",\n    43→    \"tsup\": \"^8.3.5\"\n    44→  },\n    45→  \"peerDependencies\": {\n    46→    \"zod\": \"^3.0.0\"\n    47→  },\n    48→  \"peerDependenciesMeta\": {\n    49→    \"zod\": {\n    50→      \"optional\": true\n    51→    }\n    52→  },\n    53→  \"engines\": {\n    54→    \"node\": \">=18.0.0\"\n    55→  },\n    56→  \"keywords\": [\n    57→    \"events\",\n    58→    \"messaging\",\n    59→    \"queue\",\n    60→    \"rabbitmq\",\n    61→    \"bullmq\",\n    62→    \"kafka\",\n    63→    \"transport\"\n    64→  ],\n    65→  \"license\": \"MIT\"\n    66→}\n    67→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T17:05:20.194Z"
        },
        {
          "type": "user",
          "text": "     1→{\n     2→  \"compilerOptions\": {\n     3→    \"composite\": false,\n     4→    \"incremental\": false,\n     5→    \"target\": \"ES2022\",\n     6→    \"module\": \"NodeNext\",\n     7→    \"moduleResolution\": \"NodeNext\",\n     8→    \"lib\": [\"ES2022\"],\n     9→    \"strict\": true,\n    10→    \"esModuleInterop\": true,\n    11→    \"skipLibCheck\": true,\n    12→    \"forceConsistentCasingInFileNames\": true,\n    13→    \"declaration\": true,\n    14→    \"declarationMap\": true,\n    15→    \"outDir\": \"./dist\",\n    16→    \"rootDir\": \"./src\",\n    17→    \"noEmit\": false,\n    18→    \"noUnusedLocals\": true,\n    19→    \"noUnusedParameters\": true,\n    20→    \"noImplicitReturns\": true,\n    21→    \"noFallthroughCasesInSwitch\": true,\n    22→    \"exactOptionalPropertyTypes\": true,\n    23→    \"noUncheckedIndexedAccess\": true,\n    24→    \"resolveJsonModule\": true,\n    25→    \"isolatedModules\": true,\n    26→    \"verbatimModuleSyntax\": true\n    27→  },\n    28→  \"include\": [\"src/**/*\"],\n    29→  \"exclude\": [\"node_modules\", \"dist\", \"test\"]\n    30→}\n    31→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T17:05:20.194Z"
        },
        {
          "type": "user",
          "text": "     1→import { defineConfig } from 'tsup';\n     2→\n     3→export default defineConfig({\n     4→  entry: ['src/index.ts'],\n     5→  format: ['cjs', 'esm'],\n     6→  dts: true,\n     7→  splitting: false,\n     8→  sourcemap: true,\n     9→  clean: true,\n    10→  outDir: 'dist',\n    11→  target: 'node18',\n    12→  treeshake: true,\n    13→});\n    14→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T17:05:20.195Z"
        },
        {
          "type": "user",
          "text": "     1→// Core\n     2→export type {\n     3→  FanoutConfig,\n     4→  HandlersState,\n     5→  MatadorConfig,\n     6→  SendError,\n     7→  SendResult,\n     8→  ShutdownConfig,\n     9→  ShutdownState,\n    10→} from './core/index.js';\n    11→export {\n    12→  defaultShutdownConfig,\n    13→  FanoutEngine,\n    14→  Matador,\n    15→  ShutdownManager,\n    16→} from './core/index.js';\n    17→\n    18→// Types\n    19→export type {\n    20→  AnySubscriber,\n    21→  CreateEnvelopeOptions,\n    22→  DeliveryMode,\n    23→  Docket,\n    24→  Envelope,\n    25→  EnvelopeOf,\n    26→  Event,\n    27→  EventClass,\n    28→  EventData,\n    29→  EventKey,\n    30→  EventOptions,\n    31→  EventStatic,\n    32→  Idempotency,\n    33→  Importance,\n    34→  JsonRecord,\n    35→  Subscriber,\n    36→  SubscriberCallback,\n    37→  SubscriberDefinition,\n    38→  SubscriberOptions,\n    39→  SubscriberStub,\n    40→  ValidationError,\n    41→  ValidationResult,\n    42→} from './types/index.js';\n    43→export {\n    44→  MatadorEvent,\n    45→  createEnvelope,\n    46→  createSubscriber,\n    47→  createSubscriberStub,\n    48→  invalidResult,\n    49→  isSubscriber,\n    50→  isSubscriberStub,\n    51→  validResult,\n    52→} from './types/index.js';\n    53→\n    54→// Transport\n    55→export type {\n    56→  ConnectFn,\n    57→  ConnectionManagerConfig,\n    58→  ConnectionState,\n    59→  DisconnectFn,\n    60→  MessageHandler,\n    61→  MessageReceipt,\n    62→  RabbitMQSendOptions,\n    63→  RabbitMQSubscribeOptions,\n    64→  RabbitMQTransportConfig,\n    65→  SendOptions,\n    66→  StateChangeCallback,\n    67→  SubscribeOptions,\n    68→  Subscription,\n    69→  Transport,\n    70→  TransportCapabilities,\n    71→  TransportSendOptions,\n    72→  TransportSubscribeOptions,\n    73→} from './transport/index.js';\n    74→export {\n    75→  ConnectionManager,\n    76→  defaultConnectionConfig,\n    77→  hasNativeDeadLetter,\n    78→  LocalTransport,\n    79→  RabbitMQTransport,\n    80→  MultiTransport,\n    81→  type MultiTransportConfig,\n    82→  type MultiTransportHooks,\n    83→  supportsDeliveryMode,\n    84→  supportsDelayedMessages,\n    85→} from './transport/index.js';\n    86→\n    87→// Topology\n    88→export type {\n    89→  DeadLetterConfig,\n    90→  DeadLetterQueueConfig,\n    91→  QueueDefinition,\n    92→  QueueOptions,\n    93→  RetryConfig,\n    94→  Topology,\n    95→} from './topology/index.js';\n    96→export {\n    97→  getDeadLetterQueueName,\n    98→  getQualifiedQueueName,\n    99→  getRetryQueueName,\n   100→  TopologyBuilder,\n   101→  TopologyValidationError,\n   102→} from './topology/index.js';\n   103→\n   104→// Codec\n   105→export type {\n   106→  Codec,\n   107→  EncodedMessage,\n   108→  HeaderAwareCodec,\n   109→} from './codec/index.js';\n   110→export { CodecDecodeError, JsonCodec, RabbitMQCodec } from './codec/index.js';\n   111→\n   112→// Schema\n   113→export type {\n   114→  MatadorSchema,\n   115→  RegisterOptions,\n   116→  SchemaEntry,\n   117→  SchemaEntryTuple,\n   118→  SchemaIssue,\n   119→  SchemaPlugin,\n   120→  SchemaValidationResult,\n   121→} from './schema/index.js';\n   122→export {\n   123→  bind,\n   124→  installPlugins,\n   125→  isSchemaEntryTuple,\n   126→  SchemaError,\n   127→  SchemaRegistry,\n   128→} from './schema/index.js';\n   129→\n   130→// Retry\n   131→export type {\n   132→  RetryContext,\n   133→  RetryDecision,\n   134→  RetryPolicy,\n   135→  StandardRetryPolicyConfig,\n   136→} from './retry/index.js';\n   137→export {\n   138→  defaultRetryConfig,\n   139→  StandardRetryPolicy,\n   140→} from './retry/index.js';\n   141→\n   142→// Hooks\n   143→export type {\n   144→  DecodeErrorContext,\n   145→  EnqueueErrorContext,\n   146→  EnqueueSuccessContext,\n   147→  EnqueueWarningContext,\n   148→  Logger,\n   149→  MatadorHooks,\n   150→  WorkerErrorContext,\n   151→  WorkerExecuteFn,\n   152→  WorkerSuccessContext,\n   153→} from './hooks/index.js';\n   154→export { consoleLogger, SafeHooks } from './hooks/index.js';\n   155→\n   156→// Pipeline\n   157→export type { PipelineConfig, ProcessResult } from './pipeline/index.js';\n   158→export { ProcessingPipeline } from './pipeline/index.js';\n   159→\n   160→// Errors\n   161→export type { HasDescription } from './errors/index.js';\n   162→export {\n   163→  // Retry control errors\n   164→  DontRetry,\n   165→  DoRetry,\n   166→  EventAssertionError,\n   167→  RetryControlError,\n   168→  isAssertionError,\n   169→  isDontRetry,\n   170→  isDoRetry,\n   171→  // Matador errors with descriptions\n   172→  MatadorError,\n   173→  isMatadorError,\n   174→  // Lifecycle errors\n   175→  NotStartedError,\n   176→  isNotStartedError,\n   177→  ShutdownInProgressError,\n   178→  // Transport errors\n   179→  TransportNotConnectedError,\n   180→  isTransportNotConnectedError,\n   181→  TransportClosedError,\n   182→  TransportSendError,\n   183→  AllTransportsFailedError,\n   184→  DelayedMessagesNotSupportedError,\n   185→  // Schema & configuration errors\n   186→  EventNotRegisteredError,\n   187→  isEventNotRegisteredError,\n   188→  SubscriberNotRegisteredError,\n   189→  isSubscriberNotRegisteredError,\n   190→  NoSubscribersExistError,\n   191→  InvalidSchemaError,\n   192→  SubscriberIsStubError,\n   193→  LocalTransportCannotProcessStubError,\n   194→  // Queue errors\n   195→  QueueNotFoundError,\n   196→  // Event validation errors\n   197→  InvalidEventError,\n   198→  // Message processing errors\n   199→  MessageMaybePoisonedError,\n   200→  isMessageMaybePoisonedError,\n   201→  IdempotentMessageCannotRetryError,\n   202→  isIdempotentMessageCannotRetryError,\n   203→  // Timeout errors\n   204→  TimeoutError,\n   205→  // Utility\n   206→  hasDescription,\n   207→} from './errors/index.js';\n   208→\n   209→// Checkpoint (Resumable Subscribers)\n   210→export type {\n   211→  Checkpoint,\n   212→  CheckpointClearedContext,\n   213→  CheckpointHitContext,\n   214→  CheckpointLoadedContext,\n   215→  CheckpointMissContext,\n   216→  CheckpointStore,\n   217→  JsonSerializable,\n   218→  ResumableContextConfig,\n   219→  ResumableContextHooks,\n   220→  SubscriberContext,\n   221→} from './checkpoint/index.js';\n   222→export {\n   223→  CheckpointStoreError,\n   224→  DuplicateIoKeyError,\n   225→  MemoryCheckpointStore,\n   226→  NoOpCheckpointStore,\n   227→  ResumableContext,\n   228→  isCheckpointStoreError,\n   229→  isDuplicateIoKeyError,\n   230→} from './checkpoint/index.js';\n   231→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T17:05:20.198Z"
        },
        {
          "type": "assistant",
          "text": "Now let me check the types to understand the exact structures I need to work with:",
          "timestamp": "2025-12-11T17:05:23.589Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/types/subscriber.ts"
          },
          "timestamp": "2025-12-11T17:05:24.311Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/types/event.ts"
          },
          "timestamp": "2025-12-11T17:05:24.647Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/core/matador.ts"
          },
          "timestamp": "2025-12-11T17:05:25.159Z"
        },
        {
          "type": "user",
          "text": "     1→import type { SubscriberContext } from '../checkpoint/index.js';\n     2→import type { Idempotency, Importance } from './common.js';\n     3→import type { Envelope } from './envelope.js';\n     4→import type { MatadorEvent } from './event.js';\n     5→\n     6→/**\n     7→ * Helper type to get the envelope type for a subscriber callback.\n     8→ * Extracts the data type from a MatadorEvent and wraps it in an Envelope.\n     9→ *\n    10→ * @example\n    11→ * async callback(envelope: EnvelopeOf<MyEvent>) {\n    12→ *   console.log(envelope.data.someField); // Type-safe access\n    13→ * }\n    14→ */\n    15→export type EnvelopeOf<T extends MatadorEvent> = Envelope<T['data']>;\n    16→\n    17→/**\n    18→ * Callback function executed when an event is received (standard subscribers).\n    19→ * Receives the full envelope containing id, data, and docket.\n    20→ */\n    21→export type StandardCallback<T = unknown> = (\n    22→  envelope: Envelope<T>,\n    23→) => Promise<void> | void;\n    24→\n    25→/**\n    26→ * Callback function for resumable subscribers.\n    27→ * Receives the envelope and a SubscriberContext with io() for checkpointed operations.\n    28→ */\n    29→export type ResumableCallback<T = unknown> = (\n    30→  envelope: Envelope<T>,\n    31→  context: SubscriberContext,\n    32→) => Promise<void> | void;\n    33→\n    34→/**\n    35→ * Callback function executed when an event is received.\n    36→ * @deprecated Use StandardCallback or ResumableCallback instead.\n    37→ */\n    38→export type SubscriberCallback<T = unknown> = StandardCallback<T>;\n    39→\n    40→/**\n    41→ * Base configuration options shared by all subscriber types.\n    42→ */\n    43→export interface BaseSubscriberOptions {\n    44→  /** Human-readable description of what this subscriber does */\n    45→  readonly description: string;\n    46→\n    47→  /** Route this subscriber's events to a specific queue */\n    48→  readonly targetQueue?: string | undefined;\n    49→\n    50→  /** Importance level for monitoring and alerting */\n    51→  readonly importance?: Importance | undefined;\n    52→\n    53→  /** Feature flag function to conditionally enable/disable the subscriber */\n    54→  readonly enabled?: (() => boolean | Promise<boolean>) | undefined;\n    55→}\n    56→\n    57→/**\n    58→ * Options for standard (non-resumable) subscribers.\n    59→ */\n    60→export interface StandardSubscriberOptions extends BaseSubscriberOptions {\n    61→  /** Idempotency declaration for retry handling (non-resumable) */\n    62→  readonly idempotent?: 'yes' | 'no' | 'unknown' | undefined;\n    63→}\n    64→\n    65→/**\n    66→ * Options for resumable subscribers that use io() for checkpointed operations.\n    67→ */\n    68→export interface ResumableSubscriberOptions extends BaseSubscriberOptions {\n    69→  /** Must be 'resumable' to enable checkpoint-based idempotency */\n    70→  readonly idempotent: 'resumable';\n    71→}\n    72→\n    73→/**\n    74→ * Configuration options for a subscriber.\n    75→ * Discriminated union based on idempotent value.\n    76→ */\n    77→export type SubscriberOptions =\n    78→  | StandardSubscriberOptions\n    79→  | ResumableSubscriberOptions;\n    80→\n    81→/**\n    82→ * Standard subscriber definition with standard callback.\n    83→ */\n    84→export interface StandardSubscriber<T extends MatadorEvent>\n    85→  extends StandardSubscriberOptions {\n    86→  /** Human-readable name for the subscriber */\n    87→  readonly name: string;\n    88→\n    89→  /** Callback function to execute when event is received */\n    90→  readonly callback: StandardCallback<T['data']>;\n    91→}\n    92→\n    93→/**\n    94→ * Resumable subscriber definition with resumable callback.\n    95→ */\n    96→export interface ResumableSubscriber<T extends MatadorEvent>\n    97→  extends ResumableSubscriberOptions {\n    98→  /** Human-readable name for the subscriber */\n    99→  readonly name: string;\n   100→\n   101→  /** Callback function with SubscriberContext for checkpointed operations */\n   102→  readonly callback: ResumableCallback<T['data']>;\n   103→}\n   104→\n   105→/**\n   106→ * Full subscriber definition with callback (either standard or resumable).\n   107→ */\n   108→export type Subscriber<T extends MatadorEvent> =\n   109→  | StandardSubscriber<T>\n   110→  | ResumableSubscriber<T>;\n   111→\n   112→/**\n   113→ * Subscriber stub for multi-codebase scenarios where subscriber implementation\n   114→ * is in a remote service. Declares the subscriber contract without providing\n   115→ * the callback.\n   116→ */\n   117→export interface SubscriberStub extends StandardSubscriberOptions {\n   118→  /** Human-readable name for the subscriber */\n   119→  readonly name: string;\n   120→\n   121→  /** Indicates this is a stub without implementation */\n   122→  readonly isStub: true;\n   123→}\n   124→\n   125→/**\n   126→ * Union type for any subscriber definition (full or stub).\n   127→ * This is the type-erased version for use in collections and schema.\n   128→ * Uses `any` because Subscriber<T> is contravariant in T (callback parameter),\n   129→ * making it impossible to assign Subscriber<SpecificEvent> to Subscriber<MatadorEvent<unknown>>.\n   130→ */\n   131→// biome-ignore lint/suspicious/noExplicitAny: Required for variance compatibility in heterogeneous collections\n   132→export type AnySubscriber = Subscriber<MatadorEvent<any>> | SubscriberStub;\n   133→\n   134→/**\n   135→ * Type guard to check if a subscriber is a stub.\n   136→ */\n   137→export function isSubscriberStub(\n   138→  subscriber: AnySubscriber,\n   139→): subscriber is SubscriberStub {\n   140→  return 'isStub' in subscriber && subscriber.isStub === true;\n   141→}\n   142→\n   143→/**\n   144→ * Type guard to check if a subscriber has a callback implementation.\n   145→ */\n   146→export function isSubscriber(\n   147→  subscriber: AnySubscriber,\n   148→  // biome-ignore lint/suspicious/noExplicitAny: Required for variance compatibility\n   149→): subscriber is Subscriber<MatadorEvent<any>> {\n   150→  return 'callback' in subscriber && typeof subscriber.callback === 'function';\n   151→}\n   152→\n   153→/**\n   154→ * Type guard to check if a subscriber is resumable.\n   155→ */\n   156→export function isResumableSubscriber(\n   157→  subscriber: AnySubscriber,\n   158→  // biome-ignore lint/suspicious/noExplicitAny: Required for variance compatibility\n   159→): subscriber is ResumableSubscriber<MatadorEvent<any>> {\n   160→  return isSubscriber(subscriber) && subscriber.idempotent === 'resumable';\n   161→}\n   162→\n   163→/**\n   164→ * Type guard to check if a subscriber is a standard (non-resumable) subscriber.\n   165→ */\n   166→export function isStandardSubscriber(\n   167→  subscriber: AnySubscriber,\n   168→  // biome-ignore lint/suspicious/noExplicitAny: Required for variance compatibility\n   169→): subscriber is StandardSubscriber<MatadorEvent<any>> {\n   170→  return isSubscriber(subscriber) && subscriber.idempotent !== 'resumable';\n   171→}\n   172→\n   173→/**\n   174→ * Input options for createSubscriber with standard callback.\n   175→ */\n   176→export interface CreateStandardSubscriberInput<T extends MatadorEvent> {\n   177→  readonly name: string;\n   178→  readonly description: string;\n   179→  readonly callback: StandardCallback<T['data']>;\n   180→  readonly idempotent?: 'yes' | 'no' | 'unknown' | undefined;\n   181→  readonly importance?: Importance | undefined;\n   182→  readonly targetQueue?: string | undefined;\n   183→  readonly enabled?: (() => boolean | Promise<boolean>) | undefined;\n   184→}\n   185→\n   186→/**\n   187→ * Input options for createSubscriber with resumable callback.\n   188→ */\n   189→export interface CreateResumableSubscriberInput<T extends MatadorEvent> {\n   190→  readonly name: string;\n   191→  readonly description: string;\n   192→  readonly callback: ResumableCallback<T['data']>;\n   193→  readonly idempotent: 'resumable';\n   194→  readonly importance?: Importance | undefined;\n   195→  readonly targetQueue?: string | undefined;\n   196→  readonly enabled?: (() => boolean | Promise<boolean>) | undefined;\n   197→}\n   198→\n   199→/**\n   200→ * Input options for createSubscriber (discriminated union).\n   201→ */\n   202→export type CreateSubscriberInput<T extends MatadorEvent> =\n   203→  | CreateStandardSubscriberInput<T>\n   204→  | CreateResumableSubscriberInput<T>;\n   205→\n   206→/**\n   207→ * Creates a subscriber definition.\n   208→ *\n   209→ * @example Standard subscriber\n   210→ * ```typescript\n   211→ * const subscriber = createSubscriber<MyEvent>({\n   212→ *   name: 'my-subscriber',\n   213→ *   description: 'Handles MyEvent by logging the data',\n   214→ *   callback: async (envelope) => {\n   215→ *     console.log(envelope.data);\n   216→ *   },\n   217→ * });\n   218→ * ```\n   219→ *\n   220→ * @example Resumable subscriber with io()\n   221→ * ```typescript\n   222→ * const subscriber = createSubscriber<MyEvent>({\n   223→ *   name: 'my-resumable-subscriber',\n   224→ *   description: 'Processes MyEvent with checkpoint-based idempotency',\n   225→ *   idempotent: 'resumable',\n   226→ *   callback: async (envelope, { io }) => {\n   227→ *     await io('step-1', () => doSomething());\n   228→ *   },\n   229→ * });\n   230→ * ```\n   231→ */\n   232→export function createSubscriber<T extends MatadorEvent>(\n   233→  input: CreateSubscriberInput<T>,\n   234→): Subscriber<T> {\n   235→  const base = {\n   236→    name: input.name,\n   237→    description: input.description,\n   238→    callback: input.callback,\n   239→    importance: input.importance ?? 'should-investigate',\n   240→    ...(input.targetQueue !== undefined && {\n   241→      targetQueue: input.targetQueue,\n   242→    }),\n   243→    ...(input.enabled !== undefined && { enabled: input.enabled }),\n   244→  };\n   245→\n   246→  if (input.idempotent === 'resumable') {\n   247→    return {\n   248→      ...base,\n   249→      idempotent: 'resumable',\n   250→      callback: input.callback,\n   251→    } as ResumableSubscriber<T>;\n   252→  }\n   253→\n   254→  return {\n   255→    ...base,\n   256→    idempotent: input.idempotent ?? 'unknown',\n   257→    callback: input.callback,\n   258→  } as StandardSubscriber<T>;\n   259→}\n   260→\n   261→/**\n   262→ * Input options for createSubscriberStub.\n   263→ */\n   264→export interface CreateSubscriberStubInput {\n   265→  readonly name: string;\n   266→  readonly description: string;\n   267→  readonly idempotent?: 'yes' | 'no' | 'unknown' | undefined;\n   268→  readonly importance?: Importance | undefined;\n   269→  readonly targetQueue?: string | undefined;\n   270→  readonly enabled?: (() => boolean | Promise<boolean>) | undefined;\n   271→}\n   272→\n   273→/**\n   274→ * Creates a subscriber stub for remote implementations.\n   275→ *\n   276→ * @example\n   277→ * ```typescript\n   278→ * const stub = createSubscriberStub({\n   279→ *   name: 'remote-analytics',\n   280→ *   description: 'Sends events to remote analytics service',\n   281→ *   targetQueue: 'analytics-worker',\n   282→ * });\n   283→ * ```\n   284→ */\n   285→export function createSubscriberStub(input: CreateSubscriberStubInput): SubscriberStub {\n   286→  return {\n   287→    name: input.name,\n   288→    description: input.description,\n   289→    isStub: true,\n   290→    idempotent: input.idempotent ?? 'unknown',\n   291→    importance: input.importance ?? 'should-investigate',\n   292→    ...(input.targetQueue !== undefined && {\n   293→      targetQueue: input.targetQueue,\n   294→    }),\n   295→    ...(input.enabled !== undefined && { enabled: input.enabled }),\n   296→  };\n   297→}\n   298→\n   299→/**\n   300→ * Definition interface used by the pipeline (excludes event class reference).\n   301→ */\n   302→export interface SubscriberDefinition {\n   303→  readonly name: string;\n   304→  readonly description: string;\n   305→  readonly idempotent: Idempotency;\n   306→  readonly importance: Importance;\n   307→  readonly targetQueue?: string | undefined;\n   308→}\n   309→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T17:05:25.285Z"
        },
        {
          "type": "user",
          "text": "     1→/**\n     2→ * Unique event routing key type alias.\n     3→ */\n     4→export type EventKey = string;\n     5→\n     6→/**\n     7→ * JSON-serializable primitive types.\n     8→ */\n     9→export type JsonPrimitive = string | number | boolean | null;\n    10→\n    11→/**\n    12→ * JSON-serializable value (recursive type for objects and arrays).\n    13→ */\n    14→export type JsonValue =\n    15→  | JsonPrimitive\n    16→  | JsonValue[]\n    17→  | { [key: string]: JsonValue };\n    18→\n    19→/**\n    20→ * JSON-serializable record type for metadata.\n    21→ */\n    22→export type JsonRecord = Record<string, JsonValue>;\n    23→\n    24→/**\n    25→ * Static properties required on Event classes for schema registration.\n    26→ */\n    27→export interface EventStatic<T = unknown> {\n    28→  /** Unique routing key for the event */\n    29→  readonly key: string;\n    30→\n    31→  /** Human-readable description of the event */\n    32→  readonly description?: string;\n    33→\n    34→  /** Alternative names/keys for backwards compatibility */\n    35→  readonly aliases?: readonly string[];\n    36→\n    37→  /** Create an instance from data (for deserialization) */\n    38→  new (data: T): Event<T>;\n    39→}\n    40→\n    41→/**\n    42→ * Base interface for all events.\n    43→ * Events represent something that happened in the system.\n    44→ */\n    45→export interface Event<T = unknown> {\n    46→  /** The event data/payload */\n    47→  readonly data: T;\n    48→\n    49→  /** Event-specific metadata (merged with EventOptions metadata on dispatch) */\n    50→  readonly metadata?: JsonRecord | undefined;\n    51→}\n    52→\n    53→/**\n    54→ * Options for dispatching an event.\n    55→ */\n    56→export interface EventOptions {\n    57→  /** Delay processing by this many milliseconds */\n    58→  readonly delayMs?: number | undefined;\n    59→\n    60→  /** Correlation ID for request tracing */\n    61→  readonly correlationId?: string | undefined;\n    62→\n    63→  /**\n    64→   * Event-specific metadata to include in the docket.\n    65→   * This metadata will be merged with:\n    66→   * 1. Event instance metadata (if defined on the event)\n    67→   * 2. Universal metadata from the loadUniversalMetadata hook\n    68→   * With EventOptions metadata taking precedence over event metadata,\n    69→   * and both taking precedence over universal metadata.\n    70→   */\n    71→  readonly metadata?: JsonRecord | undefined;\n    72→}\n    73→\n    74→/**\n    75→ * Abstract base class for creating Matador events.\n    76→ * Extend this class to define custom events.\n    77→ *\n    78→ * @example\n    79→ * ```typescript\n    80→ * class UserCreatedEvent extends MatadorEvent {\n    81→ *   static readonly key = 'user.created'\n    82→ *   static readonly description = 'Fired when a new user is created'\n    83→ *\n    84→ *   constructor(\n    85→ *     public data: { userId: string; email: string },\n    86→ *     public metadata?: JsonRecord,\n    87→ *   ) {\n    88→ *     super()\n    89→ *   }\n    90→ * }\n    91→ * ```\n    92→ */\n    93→export abstract class MatadorEvent<T = unknown> implements Event<T> {\n    94→  static readonly key: string;\n    95→  static readonly description?: string;\n    96→  static readonly aliases?: readonly string[];\n    97→\n    98→  /** The event data/payload - must be defined by subclass */\n    99→  abstract readonly data: T;\n   100→\n   101→  /** Event-specific metadata */\n   102→  readonly metadata?: JsonRecord | undefined;\n   103→}\n   104→\n   105→/**\n   106→ * Type helper to extract the data type from an event class.\n   107→ */\n   108→export type EventData<E extends Event<unknown>> = E extends Event<infer T>\n   109→  ? T\n   110→  : never;\n   111→\n   112→/**\n   113→ * Type helper to get the event class type.\n   114→ */\n   115→export type EventClass<T = unknown> = EventStatic<T> &\n   116→  (new (\n   117→    data: T,\n   118→  ) => Event<T>);\n   119→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T17:05:25.286Z"
        },
        {
          "type": "user",
          "text": "     1→import type { CheckpointStore } from '../checkpoint/index.js';\n     2→import type { Codec } from '../codec/index.js';\n     3→import { JsonCodec } from '../codec/index.js';\n     4→import {\n     5→  InvalidSchemaError,\n     6→  NotStartedError,\n     7→  ShutdownInProgressError,\n     8→} from '../errors/index.js';\n     9→import type { MatadorHooks } from '../hooks/index.js';\n    10→import { SafeHooks } from '../hooks/index.js';\n    11→import { ProcessingPipeline } from '../pipeline/index.js';\n    12→import type { RetryPolicy } from '../retry/index.js';\n    13→import { StandardRetryPolicy } from '../retry/index.js';\n    14→import type { MatadorSchema } from '../schema/index.js';\n    15→import { SchemaRegistry, isSchemaEntryTuple } from '../schema/index.js';\n    16→import type { Topology } from '../topology/index.js';\n    17→import { getQualifiedQueueName } from '../topology/index.js';\n    18→import type { Subscription, Transport } from '../transport/index.js';\n    19→import type {\n    20→  AnySubscriber,\n    21→  Event,\n    22→  EventClass,\n    23→  EventOptions,\n    24→} from '../types/index.js';\n    25→import type { SendResult } from './fanout.js';\n    26→import { FanoutEngine } from './fanout.js';\n    27→import type { HandlersState, ShutdownConfig } from './shutdown.js';\n    28→import { ShutdownManager } from './shutdown.js';\n    29→\n    30→/**\n    31→ * Configuration for Matador.\n    32→ */\n    33→export interface MatadorConfig {\n    34→  /** Transport for message delivery */\n    35→  readonly transport: Transport;\n    36→\n    37→  /** Topology configuration */\n    38→  readonly topology: Topology;\n    39→\n    40→  /** Event schema mapping event keys to event classes and subscribers */\n    41→  readonly schema: MatadorSchema;\n    42→\n    43→  /** Queues to consume from (empty = no consumption) */\n    44→  readonly consumeFrom?: readonly string[] | undefined;\n    45→\n    46→  /** Custom codec (defaults to JSON) */\n    47→  readonly codec?: Codec | undefined;\n    48→\n    49→  /** Custom retry policy */\n    50→  readonly retryPolicy?: RetryPolicy | undefined;\n    51→\n    52→  /** Shutdown configuration */\n    53→  readonly shutdownConfig?: Partial<ShutdownConfig> | undefined;\n    54→\n    55→  /**\n    56→   * Checkpoint store for resumable subscribers.\n    57→   * Required for persisting io() results across retries.\n    58→   * If not provided, resumable subscribers will work but checkpoints\n    59→   * won't persist across retries.\n    60→   */\n    61→  readonly checkpointStore?: CheckpointStore | undefined;\n    62→}\n    63→\n    64→/**\n    65→ * Matador - Transport-agnostic event processing library.\n    66→ *\n    67→ * Main orchestrator that wires together:\n    68→ * - Transport: Message delivery\n    69→ * - Schema: Event-subscriber registry\n    70→ * - Pipeline: Message processing\n    71→ * - Fanout: Event sending\n    72→ * - Shutdown: Graceful termination\n    73→ */\n    74→export class Matador {\n    75→  private readonly transport: Transport;\n    76→  private readonly topology: Topology;\n    77→  private readonly schema;\n    78→  private readonly codec: Codec;\n    79→  private readonly retryPolicy: RetryPolicy;\n    80→  private readonly hooks;\n    81→  private readonly pipeline;\n    82→  private readonly fanout;\n    83→  private readonly shutdownManager;\n    84→  private readonly consumeFrom: readonly string[];\n    85→  private readonly subscriptions: Subscription[] = [];\n    86→  private started = false;\n    87→\n    88→  /**\n    89→   * Creates a new Matador instance.\n    90→   *\n    91→   * @param config - Static configuration (transport, topology, schema, etc.)\n    92→   * @param hooks - Lifecycle hooks for logging, monitoring, and dynamic configuration.\n    93→   *                Passed separately to support NestJS dependency injection.\n    94→   */\n    95→  constructor(config: MatadorConfig, hooks?: MatadorHooks) {\n    96→    this.transport = config.transport;\n    97→    this.topology = config.topology;\n    98→    this.consumeFrom = config.consumeFrom ?? [];\n    99→\n   100→    // Initialize components\n   101→    this.schema = new SchemaRegistry();\n   102→    this.codec = config.codec ?? new JsonCodec();\n   103→    this.retryPolicy = config.retryPolicy ?? new StandardRetryPolicy();\n   104→    this.hooks = new SafeHooks(hooks);\n   105→\n   106→    // Register schema from config\n   107→    this.registerSchema(config.schema);\n   108→\n   109→    // Create pipeline\n   110→    this.pipeline = new ProcessingPipeline({\n   111→      transport: this.transport,\n   112→      schema: this.schema,\n   113→      codec: this.codec,\n   114→      retryPolicy: this.retryPolicy,\n   115→      hooks: this.hooks,\n   116→      checkpointStore: config.checkpointStore,\n   117→    });\n   118→\n   119→    // Create fanout engine\n   120→    const defaultQueue = this.topology.queues[0]?.name ?? 'default';\n   121→    this.fanout = new FanoutEngine({\n   122→      transport: this.transport,\n   123→      schema: this.schema,\n   124→      hooks: this.hooks,\n   125→      namespace: this.topology.namespace,\n   126→      defaultQueue,\n   127→    });\n   128→\n   129→    // Create shutdown manager\n   130→    this.shutdownManager = new ShutdownManager(\n   131→      () => this.fanout.eventsBeingEnqueuedCount,\n   132→      () => this.stopReceiving(),\n   133→      () => this.transport.disconnect(),\n   134→      config.shutdownConfig,\n   135→    );\n   136→  }\n   137→\n   138→  /**\n   139→   * Registers an event class with its subscribers.\n   140→   */\n   141→  register<T>(\n   142→    eventClass: EventClass<T>,\n   143→    subscribers: readonly AnySubscriber[],\n   144→  ): this {\n   145→    this.schema.register(eventClass, subscribers);\n   146→    return this;\n   147→  }\n   148→\n   149→  /**\n   150→   * Registers events from a schema object.\n   151→   * Supports both object format and tuple format entries.\n   152→   *\n   153→   * @example\n   154→   * ```typescript\n   155→   * // Tuple format\n   156→   * matador.registerSchema({\n   157→   *   [UserCreatedEvent.key]: [UserCreatedEvent, [emailSubscriber]],\n   158→   *   [OrderPlacedEvent.key]: [OrderPlacedEvent, [invoiceSubscriber]],\n   159→   * });\n   160→   *\n   161→   * // Object format\n   162→   * matador.registerSchema({\n   163→   *   [UserCreatedEvent.key]: { eventClass: UserCreatedEvent, subscribers: [emailSubscriber] },\n   164→   * });\n   165→   * ```\n   166→   */\n   167→  registerSchema(schema: MatadorSchema): this {\n   168→    for (const entry of Object.values(schema)) {\n   169→      if (isSchemaEntryTuple(entry)) {\n   170→        // Tuple format: [EventClass, Subscriber[]]\n   171→        const [eventClass, subscribers] = entry;\n   172→        this.schema.register(eventClass, subscribers);\n   173→      } else {\n   174→        // Object format: { eventClass, subscribers }\n   175→        this.schema.register(entry.eventClass, entry.subscribers);\n   176→      }\n   177→    }\n   178→    return this;\n   179→  }\n   180→\n   181→  /**\n   182→   * Starts Matador - connects transport and begins consuming.\n   183→   * This method is idempotent - calling it multiple times is safe.\n   184→   */\n   185→  async start(): Promise<void> {\n   186→    // Idempotent: if already started, just return\n   187→    if (this.started) {\n   188→      return;\n   189→    }\n   190→\n   191→    // Validate schema\n   192→    const validation = this.schema.validate();\n   193→    if (!validation.valid) {\n   194→      const errors = validation.issues.filter((i) => i.severity === 'error');\n   195→      throw new InvalidSchemaError(\n   196→        'Schema validation failed',\n   197→        errors.map((e) => e.message).join(', '),\n   198→      );\n   199→    }\n   200→\n   201→    // Connect transport\n   202→    await this.transport.connect();\n   203→\n   204→    // Apply topology\n   205→    await this.transport.applyTopology(this.topology);\n   206→\n   207→    // Subscribe to queues\n   208→    for (const queueName of this.consumeFrom) {\n   209→      const qualifiedName = getQualifiedQueueName(\n   210→        this.topology.namespace,\n   211→        queueName,\n   212→      );\n   213→      const queueDef = this.topology.queues.find((q) => q.name === queueName);\n   214→\n   215→      const subscription = await this.transport.subscribe(\n   216→        qualifiedName,\n   217→        async (envelope, receipt) => {\n   218→          this.shutdownManager.incrementProcessing();\n   219→          try {\n   220→            const rawMessage = this.codec.encode(envelope);\n   221→            await this.pipeline.process(rawMessage, receipt);\n   222→          } finally {\n   223→            this.shutdownManager.decrementProcessing();\n   224→          }\n   225→        },\n   226→        queueDef?.concurrency !== undefined\n   227→          ? { concurrency: queueDef.concurrency }\n   228→          : undefined,\n   229→      );\n   230→\n   231→      this.subscriptions.push(subscription);\n   232→    }\n   233→\n   234→    this.started = true;\n   235→  }\n   236→\n   237→  /**\n   238→   * Sends an event to all registered subscribers.\n   239→   *\n   240→   * @example\n   241→   * ```typescript\n   242→   * // Pass the event class and data directly\n   243→   * await matador.send(UserCreatedEvent, { userId: '123' });\n   244→   *\n   245→   * // Or pass an event instance\n   246→   * const event = new UserCreatedEvent({ userId: '123' });\n   247→   * await matador.send(event);\n   248→   * ```\n   249→   */\n   250→  async send<T>(\n   251→    eventClass: EventClass<T>,\n   252→    data: T,\n   253→    options?: EventOptions,\n   254→  ): Promise<SendResult>;\n   255→  async send<T>(event: Event<T>, options?: EventOptions): Promise<SendResult>;\n   256→  async send<T>(\n   257→    eventOrClass: Event<T> | EventClass<T>,\n   258→    dataOrOptions?: T | EventOptions,\n   259→    maybeOptions?: EventOptions,\n   260→  ): Promise<SendResult> {\n   261→    if (!this.started) {\n   262→      throw new NotStartedError('send');\n   263→    }\n   264→\n   265→    if (!this.shutdownManager.isEnqueueAllowed) {\n   266→      throw new ShutdownInProgressError();\n   267→    }\n   268→\n   269→    // Determine if first arg is an event instance or event class\n   270→    const isEventClass =\n   271→      typeof eventOrClass === 'function' && 'key' in eventOrClass;\n   272→\n   273→    if (isEventClass) {\n   274→      // Called as: send(EventClass, data, options?)\n   275→      const eventClass = eventOrClass as EventClass<T>;\n   276→      const data = dataOrOptions as T;\n   277→      const options = maybeOptions;\n   278→      const event = new eventClass(data);\n   279→      return this.fanout.send(eventClass, event, options);\n   280→    } else {\n   281→      // Called as: send(event, options?)\n   282→      const event = eventOrClass as Event<T>;\n   283→      const options = dataOrOptions as EventOptions | undefined;\n   284→      const eventClass = event.constructor as EventClass<T>;\n   285→      return this.fanout.send(eventClass, event, options);\n   286→    }\n   287→  }\n   288→\n   289→  /**\n   290→   * Gets current handler state.\n   291→   */\n   292→  getHandlersState(): HandlersState {\n   293→    return this.shutdownManager.getHandlersState();\n   294→  }\n   295→\n   296→  /**\n   297→   * Checks if Matador is idle (no processing or enqueuing).\n   298→   */\n   299→  isIdle(): boolean {\n   300→    return this.shutdownManager.getHandlersState().isIdle;\n   301→  }\n   302→\n   303→  /**\n   304→   * Waits for all handlers to become idle.\n   305→   */\n   306→  async waitForIdle(timeoutMs = 30000): Promise<boolean> {\n   307→    const deadline = Date.now() + timeoutMs;\n   308→\n   309→    while (!this.isIdle()) {\n   310→      if (Date.now() > deadline) {\n   311→        return false;\n   312→      }\n   313→      await new Promise((resolve) => setTimeout(resolve, 100));\n   314→    }\n   315→\n   316→    return true;\n   317→  }\n   318→\n   319→  /**\n   320→   * Gracefully shuts down Matador.\n   321→   */\n   322→  async shutdown(): Promise<void> {\n   323→    if (!this.started) {\n   324→      return;\n   325→    }\n   326→\n   327→    await this.shutdownManager.shutdown();\n   328→    this.started = false;\n   329→  }\n   330→\n   331→  /**\n   332→   * Checks if transport is connected.\n   333→   */\n   334→  isConnected(): boolean {\n   335→    return this.transport.isConnected();\n   336→  }\n   337→\n   338→  private async stopReceiving(): Promise<void> {\n   339→    for (const subscription of this.subscriptions) {\n   340→      await subscription.unsubscribe();\n   341→    }\n   342→    this.subscriptions.length = 0;\n   343→  }\n   344→}\n   345→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T17:05:25.286Z"
        },
        {
          "type": "assistant",
          "text": "Now I have a good understanding of the matador package. Let me check the schema registry to understand how it works:",
          "timestamp": "2025-12-11T17:05:29.351Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/schema/registry.ts"
          },
          "timestamp": "2025-12-11T17:05:30.242Z"
        },
        {
          "type": "user",
          "text": "     1→import type { HasDescription } from '../errors/index.js';\n     2→import type {\n     3→  AnySubscriber,\n     4→  EventClass,\n     5→  MatadorEvent,\n     6→  Subscriber,\n     7→  SubscriberDefinition,\n     8→} from '../types/index.js';\n     9→import { isSubscriber } from '../types/index.js';\n    10→import type {\n    11→  RegisterOptions,\n    12→  SchemaEntry,\n    13→  SchemaIssue,\n    14→  SchemaValidationResult,\n    15→} from './types.js';\n    16→\n    17→/**\n    18→ * Error thrown when schema operations fail.\n    19→ */\n    20→export class SchemaError extends Error implements HasDescription {\n    21→  readonly description =\n    22→    'A schema operation failed, such as registering a duplicate event or ' +\n    23→    'conflicting alias. This is a configuration error that should be fixed ' +\n    24→    'during development. Review the event and subscriber registrations to ' +\n    25→    'resolve the conflict.';\n    26→\n    27→  constructor(message: string) {\n    28→    super(message);\n    29→    this.name = 'SchemaError';\n    30→  }\n    31→}\n    32→\n    33→/**\n    34→ * Registry for managing event-subscriber relationships.\n    35→ */\n    36→export class SchemaRegistry {\n    37→  private readonly entries = new Map<string, SchemaEntry>();\n    38→  private readonly aliases = new Map<string, string>();\n    39→\n    40→  /**\n    41→   * Registers an event class with its subscribers.\n    42→   */\n    43→  register<T>(\n    44→    eventClass: EventClass<T>,\n    45→    subscribers: readonly AnySubscriber[],\n    46→    options: RegisterOptions = {},\n    47→  ): void {\n    48→    const key = eventClass.key;\n    49→\n    50→    if (this.entries.has(key) && !options.override) {\n    51→      throw new SchemaError(`Event \"${key}\" is already registered`);\n    52→    }\n    53→\n    54→    this.entries.set(key, {\n    55→      eventClass,\n    56→      subscribers,\n    57→    } as SchemaEntry);\n    58→\n    59→    // Register aliases\n    60→    if (eventClass.aliases) {\n    61→      for (const alias of eventClass.aliases) {\n    62→        if (\n    63→          this.aliases.has(alias) &&\n    64→          this.aliases.get(alias) !== key &&\n    65→          !options.override\n    66→        ) {\n    67→          throw new SchemaError(\n    68→            `Alias \"${alias}\" is already registered for event \"${this.aliases.get(alias)}\"`,\n    69→          );\n    70→        }\n    71→        this.aliases.set(alias, key);\n    72→      }\n    73→    }\n    74→  }\n    75→\n    76→  /**\n    77→   * Gets the event class for a given key.\n    78→   */\n    79→  getEventClass(key: string): EventClass | undefined {\n    80→    const entry = this.entries.get(key);\n    81→    if (entry) return entry.eventClass;\n    82→\n    83→    // Check aliases\n    84→    const aliasKey = this.aliases.get(key);\n    85→    if (aliasKey) {\n    86→      return this.entries.get(aliasKey)?.eventClass;\n    87→    }\n    88→\n    89→    return undefined;\n    90→  }\n    91→\n    92→  /**\n    93→   * Gets all subscribers for an event key.\n    94→   */\n    95→  getSubscribers(eventKey: string): readonly AnySubscriber[] {\n    96→    const entry = this.getEntry(eventKey);\n    97→    return entry?.subscribers ?? [];\n    98→  }\n    99→\n   100→  /**\n   101→   * Gets a specific subscriber by event key and subscriber name.\n   102→   */\n   103→  getSubscriber(\n   104→    eventKey: string,\n   105→    subscriberName: string,\n   106→  ): AnySubscriber | undefined {\n   107→    const subscribers = this.getSubscribers(eventKey);\n   108→    return subscribers.find((s) => s.name === subscriberName);\n   109→  }\n   110→\n   111→  /**\n   112→   * Gets a subscriber definition for the pipeline.\n   113→   */\n   114→  getSubscriberDefinition(\n   115→    eventKey: string,\n   116→    subscriberName: string,\n   117→  ): SubscriberDefinition | undefined {\n   118→    const subscriber = this.getSubscriber(eventKey, subscriberName);\n   119→    if (!subscriber) return undefined;\n   120→\n   121→    const def: SubscriberDefinition = {\n   122→      name: subscriber.name,\n   123→      description: subscriber.description,\n   124→      idempotent: subscriber.idempotent ?? 'unknown',\n   125→      importance: subscriber.importance ?? 'should-investigate',\n   126→    };\n   127→\n   128→    if (subscriber.targetQueue !== undefined) {\n   129→      (def as { targetQueue?: string }).targetQueue = subscriber.targetQueue;\n   130→    }\n   131→\n   132→    return def;\n   133→  }\n   134→\n   135→  /**\n   136→   * Gets a subscriber with callback for execution.\n   137→   */\n   138→  getExecutableSubscriber(\n   139→    eventKey: string,\n   140→    subscriberName: string,\n   141→  ): Subscriber<MatadorEvent<unknown>> | undefined {\n   142→    const subscriber = this.getSubscriber(eventKey, subscriberName);\n   143→    if (!subscriber || !isSubscriber(subscriber)) return undefined;\n   144→    return subscriber;\n   145→  }\n   146→\n   147→  /**\n   148→   * Gets the event class by alias.\n   149→   */\n   150→  getEventByAlias(alias: string): EventClass | undefined {\n   151→    const key = this.aliases.get(alias);\n   152→    if (!key) return undefined;\n   153→    return this.entries.get(key)?.eventClass;\n   154→  }\n   155→\n   156→  /**\n   157→   * Checks if an event key is registered.\n   158→   */\n   159→  hasEvent(key: string): boolean {\n   160→    return this.entries.has(key) || this.aliases.has(key);\n   161→  }\n   162→\n   163→  /**\n   164→   * Gets all registered event keys.\n   165→   */\n   166→  getEventKeys(): readonly string[] {\n   167→    return [...this.entries.keys()];\n   168→  }\n   169→\n   170→  /**\n   171→   * Validates the schema for issues.\n   172→   */\n   173→  validate(): SchemaValidationResult {\n   174→    const issues: SchemaIssue[] = [];\n   175→\n   176→    for (const [key, entry] of this.entries) {\n   177→      // Check for duplicate subscriber names\n   178→      const names = new Set<string>();\n   179→      for (const subscriber of entry.subscribers) {\n   180→        if (names.has(subscriber.name)) {\n   181→          issues.push({\n   182→            severity: 'error',\n   183→            eventKey: key,\n   184→            message: `Duplicate subscriber name: \"${subscriber.name}\"`,\n   185→          });\n   186→        }\n   187→        names.add(subscriber.name);\n   188→      }\n   189→\n   190→      // Check for subscribers without callbacks (stubs in consuming instance)\n   191→      const stubs = entry.subscribers.filter((s) => !isSubscriber(s));\n   192→      if (stubs.length === entry.subscribers.length && stubs.length > 0) {\n   193→        issues.push({\n   194→          severity: 'warning',\n   195→          eventKey: key,\n   196→          message: 'All subscribers are stubs, no local handlers',\n   197→        });\n   198→      }\n   199→    }\n   200→\n   201→    return {\n   202→      valid: issues.filter((i) => i.severity === 'error').length === 0,\n   203→      issues,\n   204→    };\n   205→  }\n   206→\n   207→  /**\n   208→   * Clears all registered entries.\n   209→   */\n   210→  clear(): void {\n   211→    this.entries.clear();\n   212→    this.aliases.clear();\n   213→  }\n   214→\n   215→  private getEntry(eventKey: string): SchemaEntry | undefined {\n   216→    const entry = this.entries.get(eventKey);\n   217→    if (entry) return entry;\n   218→\n   219→    const aliasKey = this.aliases.get(eventKey);\n   220→    if (aliasKey) {\n   221→      return this.entries.get(aliasKey);\n   222→    }\n   223→\n   224→    return undefined;\n   225→  }\n   226→}\n   227→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T17:05:30.365Z"
        },
        {
          "type": "assistant",
          "text": "Let me also check what the root `package.json` looks like for the workspace config:",
          "timestamp": "2025-12-11T17:05:33.718Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/package.json"
          },
          "timestamp": "2025-12-11T17:05:34.059Z"
        },
        {
          "type": "user",
          "text": "     1→{\n     2→  \"name\": \"matador-monorepo\",\n     3→  \"private\": true,\n     4→  \"workspaces\": [\"packages/*\"],\n     5→  \"scripts\": {\n     6→    \"build\": \"bun run --filter '*' build\",\n     7→    \"test\": \"bun run --filter '*' test\",\n     8→    \"lint\": \"bunx biome check .\",\n     9→    \"lint:fix\": \"bunx biome check . --fix\",\n    10→    \"typecheck\": \"bun run --filter '*' typecheck\",\n    11→    \"clean\": \"bun run --filter '*' clean\"\n    12→  },\n    13→  \"devDependencies\": {\n    14→    \"@biomejs/biome\": \"^1.9.0\",\n    15→    \"@types/bun\": \"^1.1.0\",\n    16→    \"tsup\": \"^8.3.5\",\n    17→    \"typescript\": \"^5.6.0\"\n    18→  }\n    19→}\n    20→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T17:05:34.167Z"
        },
        {
          "type": "assistant",
          "text": "Now I have all the context I need. Let me start creating the `matador-nest` package structure:",
          "timestamp": "2025-12-11T17:05:37.476Z"
        },
        {
          "type": "tool_use",
          "name": "Bash",
          "input": {
            "command": "mkdir -p /home/z/Desktop/work/matador/packages/matador-nest/src/{decorators,module,discovery,services,testing}",
            "description": "Create matador-nest package directory structure"
          },
          "timestamp": "2025-12-11T17:05:38.686Z"
        },
        {
          "type": "tool_use",
          "name": "Write",
          "input": {
            "content": "{\n  \"name\": \"@zdavison/matador-nest\",\n  \"version\": \"1.0.0\",\n  \"description\": \"NestJS integration for Matador event processing library\",\n  \"type\": \"module\",\n  \"main\": \"./dist/index.cjs\",\n  \"module\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"import\": {\n        \"types\": \"./dist/index.d.ts\",\n        \"default\": \"./dist/index.js\"\n      },\n      \"require\": {\n        \"types\": \"./dist/index.d.cts\",\n        \"default\": \"./dist/index.cjs\"\n      }\n    },\n    \"./testing\": {\n      \"import\": {\n        \"types\": \"./dist/testing.d.ts\",\n        \"default\": \"./dist/testing.js\"\n      },\n      \"require\": {\n        \"types\": \"./dist/testing.d.cts\",\n        \"default\": \"./dist/testing.cjs\"\n      }\n    }\n  },\n  \"scripts\": {\n    \"build\": \"tsup\",\n    \"test\": \"bun test\",\n    \"test:watch\": \"bun test --watch\",\n    \"lint\": \"bunx biome check .\",\n    \"lint:fix\": \"bunx biome check . --fix\",\n    \"typecheck\": \"tsc --noEmit\",\n    \"clean\": \"rm -rf dist\"\n  },\n  \"peerDependencies\": {\n    \"@nestjs/common\": \"^10.0.0 || ^11.0.0\",\n    \"@nestjs/core\": \"^10.0.0 || ^11.0.0\",\n    \"@zdavison/matador\": \"^2.0.0\",\n    \"reflect-metadata\": \"^0.1.13 || ^0.2.0\"\n  },\n  \"devDependencies\": {\n    \"@nestjs/common\": \"^10.0.0\",\n    \"@nestjs/core\": \"^10.0.0\",\n    \"@nestjs/testing\": \"^10.0.0\",\n    \"@zdavison/matador\": \"workspace:*\",\n    \"reflect-metadata\": \"^0.2.0\",\n    \"rxjs\": \"^7.0.0\",\n    \"tsup\": \"^8.3.5\"\n  },\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  },\n  \"keywords\": [\n    \"nestjs\",\n    \"events\",\n    \"messaging\",\n    \"queue\",\n    \"rabbitmq\",\n    \"matador\"\n  ],\n  \"license\": \"MIT\"\n}\n",
            "file_path": "/home/z/Desktop/work/matador/packages/matador-nest/package.json"
          },
          "timestamp": "2025-12-11T17:05:57.767Z"
        },
        {
          "type": "tool_use",
          "name": "Write",
          "input": {
            "content": "{\n  \"compilerOptions\": {\n    \"composite\": false,\n    \"incremental\": false,\n    \"target\": \"ES2022\",\n    \"module\": \"NodeNext\",\n    \"moduleResolution\": \"NodeNext\",\n    \"lib\": [\"ES2022\"],\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"noEmit\": false,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true,\n    \"noImplicitReturns\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"exactOptionalPropertyTypes\": true,\n    \"noUncheckedIndexedAccess\": true,\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"verbatimModuleSyntax\": true,\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\", \"test\"]\n}\n",
            "file_path": "/home/z/Desktop/work/matador/packages/matador-nest/tsconfig.json"
          },
          "timestamp": "2025-12-11T17:06:01.422Z"
        },
        {
          "type": "tool_use",
          "name": "Write",
          "input": {
            "content": "import { defineConfig } from 'tsup';\n\nexport default defineConfig({\n  entry: ['src/index.ts', 'src/testing.ts'],\n  format: ['cjs', 'esm'],\n  dts: true,\n  splitting: false,\n  sourcemap: true,\n  clean: true,\n  outDir: 'dist',\n  target: 'node18',\n  treeshake: true,\n  external: [\n    '@nestjs/common',\n    '@nestjs/core',\n    '@nestjs/testing',\n    '@zdavison/matador',\n    'reflect-metadata',\n    'rxjs',\n  ],\n});\n",
            "file_path": "/home/z/Desktop/work/matador/packages/matador-nest/tsup.config.ts"
          },
          "timestamp": "2025-12-11T17:06:02.649Z"
        }
      ],
      "total_additions": 1059,
      "total_deletions": 0,
      "accepted_lines": 1017,
      "overriden_lines": 24
    },
    "bee7a58d1941ed07": {
      "agent_id": {
        "tool": "claude",
        "id": "bd5ee055-02ff-46b6-9281-5f46e3192f29",
        "model": "claude-opus-4-5-20251101"
      },
      "human_author": "Zachary Davison <zachary.davison@meetsmore.com>",
      "messages": [
        {
          "type": "user",
          "text": "Add an ascii architecture diagram to the README that describes the flow of the matador internal components (e.g. Transport, Pipeline, Codec, etc)",
          "timestamp": "2025-12-12T07:52:40.410Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/README.md"
          },
          "timestamp": "2025-12-12T07:52:44.099Z"
        },
        {
          "type": "user",
          "text": "     1→# Matador\n     2→\n     3→![image](./assets/logo-small.png)\n     4→\n     5→An opinionated, batteries-included framework for using event transports (e.g. `RabbitMQ`) with a lot of useful conventions built in.\n     6→\n     7→## Table of Contents\n     8→\n     9→- [Vision](#vision)\n    10→- [History](#history)\n    11→- [Features](#features)\n    12→- [Getting Started](#getting-started)\n    13→  - [Define a MatadorEvent](#define-a-matadorevent)\n    14→  - [Define a Subscriber](#define-a-subscriber)\n    15→  - [Define a Schema](#define-a-schema)\n    16→  - [Instantiate Matador and send events](#instantiate-matador-and-send-events)\n    17→- [Concepts](#concepts)\n    18→  - [MatadorEvent](#matadorevent)\n    19→  - [Subscriber](#subscriber)\n    20→  - [Schema](#schema)\n    21→  - [Envelope](#envelope)\n    22→  - [Docket](#docket)\n    23→  - [Fanout](#fanout)\n    24→  - [Transport](#transport)\n    25→  - [Topology](#topology)\n    26→  - [Codec](#codec)\n    27→  - [Config](#config)\n    28→  - [Hooks](#hooks)\n    29→  - [idempotent](#idempotent)\n    30→  - [ResumableSubscriber](#resumablesubscriber)\n    31→- [Why it works this way](#why-it-works-this-way)\n    32→  - [Sending one message will result in a unique message per subscriber](#sending-one-message-will-result-in-a-unique-message-per-subscriber)\n    33→  - [You are working in a monorepo](#you-are-working-in-a-monorepo)\n    34→  - [You want at-least-once delivery](#you-want-at-least-once-delivery)\n    35→- [Logging](#logging)\n    36→- [Errors](#errors)\n    37→- [Other features](#other-features)\n    38→  - [universalMetadata](#universalmetadata)\n    39→  - [Schema plugins](#schema-plugins)\n    40→  - [DoRetry & DontRetry](#doretry--dontretry)\n    41→  - [LocalTransport](#localtransport)\n    42→  - [MultiTransport](#multitransport)\n    43→  - [enabled() hook for Subscriber](#enabled-hook-for-subscriber)\n    44→  - [importance](#importance)\n    45→  - [Delayed messages](#delayed-messages)\n    46→- [CLI](#cli)\n    47→\n    48→# Vision\n    49→\n    50→Matador aims to provide a ready-to-use framework for dispatching messages and moving work off your API servers onto workers.\n    51→It is an _opinionated_ library that may-or-may not suit your expectations about how to work with queues.\n    52→\n    53→You can use it to very quickly set up a framework for your events, with battle-tested conventions, edge-case coverage, and observability baked in.\n    54→\n    55→It works best under the following conditions.\n    56→\n    57→- You want the queue topology to be created and managed for you.\n    58→- You are working in a monorepo, where you can easily share code.\n    59→- You want a 1:N fanout strategy, where each _subscriber_ receives a unique copy of each event.\n    60→- You want `at-least-once` delivery semantics.\n    61→\n    62→These conditions are explained later.\n    63→\n    64→# History\n    65→\n    66→Matador has been used at [MeetsMore Inc](https://meetsmore.com/) for over 2 years to publish, consume, and observe 1,000,000+ successful events per day.\n    67→\n    68→This version of Matador is Matador V2, and was re-written from the ground up using our learnings over that 2 year period.\n    69→\n    70→# Features\n    71→\n    72→- Conventional types for `Event` and `Subscriber`\n    73→- Map an event to a list of subscribers that will consume it.\n    74→- Each subscriber receives a unique copy of each event that can be individually retried and re-queued.\n    75→- Automatically create and manage your queue topology.\n    76→- Automatic reconnection when connection drops.\n    77→- Async hooks for changing behaviour at runtime.\n    78→- Async lifecycle hooks for plugging into your observability platform.\n    79→- Required fields enforcing good, observable documentation practices.\n    80→- `idempotency` declaration for subscribers, allowing you to indicate if events can be retried safely or not.\n    81→- `metadata` separated from event payloads, to clearly separate data used for logic, and data that is just used for debugging.\n    82→- Gracefully wait for pending enqueues and subscribers to complete work before shutting down.\n    83→- Fallback to a different message broker if enqueuing fails.\n    84→- Local broker for executing code locally (useful for fallback).\n    85→- Retry control flow errors (`DoRetry` and `DontRetry`), so subscribers can manually dictate retry logic.\n    86→- Clear, documented, actionable errors for all error cases.\n    87→- Poisoned message detection.\n    88→- Resumable subscribers.\n    89→\n    90→# Getting Started\n    91→\n    92→### Define a MatadorEvent\n    93→\n    94→```ts\n    95→export class UserLoggedInEvent extends MatadorEvent {\n    96→  static readonly key = 'user.logged-in';                   // The unique event name (used to route events).\n    97→  static readonly description = 'Fired when a user logs.';  // A description of when the event is triggered.\n    98→\n    99→  constructor(\n   100→    public data: {                                          // The data payload used by business logic.\n   101→      userId: string;\n   102→      username: string;\n   103→    },\n   104→    public metadata: {                                      // Additional data helpful for logging or debugging.\n   105→      loginMethod: 'email' | 'social'\n   106→    }\n   107→  ) {\n   108→    super();\n   109→  }\n   110→}\n   111→```\n   112→\n   113→### Define a Subscriber\n   114→\n   115→```ts\n   116→const detectLoginFraud: Subscriber<UserLoggedInEvent> = {\n   117→  name: 'detect-login-fraud',                                           // Unique subscriber name.\n   118→  description: 'Send an email if unusual login behaviour is detected.'  // A description of what the subscriber does.\n   119→  idempotent: 'no'                                                      // Dictates if the operation can be safely retried.\n   120→  targetQueue: 'compliance-jobs-worker'                                 // The queue this subscriber consumes from.\n   121→  callback: async (event: EnvelopeOf<UserLoggedIn>) => { /** process event */ }\n   122→}\n   123→```\n   124→\n   125→### Define a Schema\n   126→\n   127→```ts\n   128→const myMatadorSchema = MatadorSchema = {\n   129→  [UserLoggedIn.key]: [UserLoggedIn, bind([ detectLoginFraud, logEventToBigQuery ])]\n   130→}\n   131→```\n   132→\n   133→### Instantiate Matador and send events\n   134→\n   135→```ts\n   136→// Create topology\n   137→const topology = TopologyBuilder.create()\n   138→  .withNamespace('my-app')\n   139→  .addQueue('events')\n   140→  .build();\n   141→\n   142→// Create transport\n   143→const transport = new RabbitMQTransport({ url: 'amqp://localhost' });\n   144→\n   145→// Create Matador instance\n   146→const matador = new Matador({\n   147→  transport,\n   148→  topology,\n   149→  schema: myMatadorSchema,\n   150→  consumeFrom: ['events'],  // Queues to consume from (optional, empty = producer only)\n   151→});\n   152→\n   153→await matador.start();\n   154→```\n   155→\n   156→```ts\n   157→await matador.send(UserLoggedInEvent, { userId: '123', username: 'john' });\n   158→```\n   159→\n   160→# Concepts\n   161→\n   162→### `MatadorEvent`\n   163→\n   164→A definition of an event. You extend `MatadorEvent` in order to create the _template_ for your event.\n   165→\n   166→### `Subscriber`\n   167→\n   168→A subscriber defines the logic that will execute when an event is consumed.\n   169→It also defines details about the event that are used to _fanout_ the event.\n   170→\n   171→```ts\n   172→/**\n   173→ * Standard subscriber definition with standard callback.\n   174→ */\n   175→export interface StandardSubscriber<T extends MatadorEvent> {\n   176→  /** Human-readable name for the subscriber */\n   177→  readonly name: string;\n   178→\n   179→  /** A description of what the event does. */\n   180→  readonly description: string\n   181→\n   182→  /** Idempotency declaration for retry handling (non-resumable) */\n   183→  readonly idempotent?: 'yes' | 'no' | 'unknown' | undefined;\n   184→\n   185→  /** Route this subscriber's events to a specific queue */\n   186→  readonly targetQueue?: string | undefined;\n   187→\n   188→  /** Importance level for monitoring and alerting */\n   189→  readonly importance?: Importance | undefined;\n   190→\n   191→  /** Feature flag function to conditionally enable/disable the subscriber */\n   192→  readonly enabled?: (() => boolean | Promise<boolean>) | undefined;\n   193→\n   194→  /** Callback function to execute when event is received */\n   195→  readonly callback: StandardCallback<T['data']>;\n   196→}\n   197→```\n   198→\n   199→If you want to reference a subscriber which is defined in another codebase, you can use `SubscriberStub`:\n   200→\n   201→```ts\n   202→/**\n   203→ * Subscriber stub for multi-codebase scenarios where subscriber implementation\n   204→ * is in a remote service. Declares the subscriber contract without providing\n   205→ * the callback.\n   206→ */\n   207→export interface SubscriberStub extends StandardSubscriberOptions {\n   208→  /** Human-readable name for the subscriber */\n   209→  readonly name: string;\n   210→\n   211→  /** Indicates this is a stub without implementation */\n   212→  readonly isStub: true;\n   213→}\n   214→```\n   215→\n   216→### `Schema`\n   217→\n   218→Defines the mapping of `Events` to `Subscribers`.\n   219→```ts\n   220→const myMatadorSchema = MatadorSchema = {\n   221→  // user.logged-in -> UserLoggedInEvent (class) -> subscribers\n   222→  [UserLoggedInEvent.key]: [UserLoggedInEvent, bind([ detectLoginFraud, logEventToBigQuery ])]\n   223→}\n   224→```\n   225→\n   226→### `Envelope`\n   227→\n   228→Combines both your event data + metadata with a `Docket`.\n   229→Subscribers receive an `EnvelopeOf<MyEvent>`, which is an envelope with a `data` and `metadata` field typed according to your `MatadorEvent` subclass.\n   230→\n   231→```ts\n   232→/**\n   233→ * Message envelope containing the event data and routing/observability metadata.\n   234→ * This is the transport-agnostic message format used throughout Matador.\n   235→ */\n   236→export interface Envelope<T = unknown> {\n   237→  /** Unique message ID (UUID v4) */\n   238→  readonly id: string;\n   239→\n   240→  /** The event data */\n   241→  readonly data: T;\n   242→\n   243→  /** Routing, processing state, and observability metadata */\n   244→  readonly docket: Docket;\n   245→}\n   246→\n   247→/**\n   248→ * Helper type to get the envelope type for a subscriber callback.\n   249→ * Extracts the data type from a MatadorEvent and wraps it in an Envelope.\n   250→ *\n   251→ * @example\n   252→ * async callback(envelope: EnvelopeOf<MyEvent>) {\n   253→ *   console.log(envelope.data.someField); // Type-safe access\n   254→ * }\n   255→ */\n   256→export type EnvelopeOf<T extends MatadorEvent> = Envelope<T['data']>;\n   257→```\n   258→\n   259→### `Docket`\n   260→\n   261→> A docket is a commercial document accompanying shipped goods, detailing its contents.\n   262→\n   263→Contains all metadata about an `Envelope`.\n   264→\n   265→| Property            | Documentation                                                                                                                                                                                                                                          |\n   266→| ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n   267→| **Routing**         |                                                                                                                                                                                                                                                        |\n   268→| `eventKey`          | Event key for routing                                                                                                                                                                                                                                  |\n   269→| `eventDescription`  | Human-readable description of the event (for observability/logging)                                                                                                                                                                                    |\n   270→| `targetSubscriber`  | Target subscriber name for 1:1 routing                                                                                                                                                                                                                 |\n   271→| `originalQueue`     | Original queue before any dead-letter routing                                                                                                                                                                                                          |\n   272→| `scheduledFor`      | Scheduled processing time for delayed messages (ISO 8601 string)                                                                                                                                                                                       |\n   273→| **Processing State**|                                                                                                                                                                                                                                                        |\n   274→| `attempts`          | Attempt counter managed by Matador (1-based). Incremented on each retry. Used when transport doesn't track attempts.                                                                                                                                   |\n   275→| `createdAt`         | When the envelope was first created (ISO 8601 string)                                                                                                                                                                                                  |\n   276→| `firstError`        | Error message from first failure (for debugging)                                                                                                                                                                                                       |\n   277→| `lastError`         | Error message from most recent failure                                                                                                                                                                                                                 |\n   278→| **Observability**   |                                                                                                                                                                                                                                                        |\n   279→| `importance`        | Importance level for monitoring                                                                                                                                                                                                                        |\n   280→| `correlationId`     | Correlation ID for request tracing                                                                                                                                                                                                                     |\n   281→| `metadata`          | Custom metadata provided by the application, includes `universalMetadata` |\n   282→\n   283→### `Fanout`\n   284→\n   285→The practice of taking a single published event and creating `N` concrete events, where `N` is the number of subscribers mapped to that event in your `MatadorSchema`\n   286→\n   287→### `Transport`\n   288→\n   289→A representation of a message broker or event backend. e.g `RabbitMQ`, `BullMQ`, `Temporal`, etc.\n   290→Currently, only `RabbitMQ` is supported.\n   291→\n   292→### `Topology`\n   293→\n   294→The structure of queues, exchanges, topics, etc that **Matador** will create and manage.\n   295→For RabbitMQ, for example, the topology refers to the exchanges, queues, and bindings of those entities.\n   296→**Matador** creates and manages topology for you.\n   297→\n   298→There is a generic `Topology` definition in Matador, which you can use to describe the queues you want in a limited fashion.\n   299→\n   300→Each `Transport` then translates that generic `Topology` into the concrete queues, exchanges, etc.\n   301→\n   302→The topology that **Matador** creates looks like this by default.\n   303→\n   304→![image](./assets/matador-rabbitmq-configuration-simple.drawio.png)\n   305→\n   306→#### Retry Queue\n   307→\n   308→When events fail, they are pushed into the retry queue. They will then be re-delivered after their TTL expires.\n   309→\n   310→#### Unhandled Queue\n   311→\n   312→In **Matador**, _unhandled_ refers to a message that was consumed by a worker but is not in your `MatadorSchema`.\n   313→This can happen during deployments, where your publisher has already been deployed, but your consumer has not, and therefore your consumer doesn't know about the event yet.\n   314→Since the most common reason for this (99.99% of the time in our experience) is simply deployment timing, _unhandled_ events are automatically retried using the same retry policy as failed messages. After max attempts are exhausted, they are sent to the unhandled dead-letter queue for inspection.\n   315→\n   316→#### Undeliverable Queue\n   317→\n   318→Undeliverable is a conventional term for messages that could not be successfully processed.\n   319→After a configured amount of retries (default: 3 attempts), a message will be sent to the undeliverable queue and left there for inspection.\n   320→By default, this queue is not cleared by **Matador**. You can optionally configure a `maxLength` on the dead-letter queue via the `DeadLetterQueueConfig`.\n   321→\n   322→### `Codec`\n   323→\n   324→Handles the _encoding_ and _decoding_ of events that are published and consumed.\n   325→By default, `JSONCodec` is used, which serializes and de-serializes events using JSON.\n   326→\n   327→You can create other `Codec`s if you wish (for example a `MessagePackCodec`).\n   328→\n   329→When using `RabbitMQ`, `RabbitMQCodec` is used, which still uses `JSONCodec` internally, but uses AMQP headers to store `Docket` information.\n   330→\n   331→### `Config`\n   332→\n   333→**Matador** is configured via the `MatadorConfig` interface:\n   334→\n   335→| Property          | Required | Description                                                                                              |\n   336→| ----------------- | -------- | -------------------------------------------------------------------------------------------------------- |\n   337→| `transport`       | Yes      | Transport for message delivery (e.g., `RabbitMQTransport`, `LocalTransport`, `MultiTransport`)           |\n   338→| `topology`        | Yes      | Topology configuration defining queues, dead-letter, and retry settings                                  |\n   339→| `schema`          | Yes      | Event schema mapping event keys to event classes and subscribers                                         |\n   340→| `consumeFrom`     | No       | Array of queue names to consume from (empty = producer only mode)                                        |\n   341→| `codec`           | No       | Custom codec for serialization (defaults to `JsonCodec`)                                                 |\n   342→| `retryPolicy`     | No       | Custom retry policy (defaults to `StandardRetryPolicy` with 3 max attempts)                              |\n   343→| `shutdownConfig`  | No       | Shutdown configuration (drain timeout, etc.)                                                             |\n   344→| `checkpointStore` | No       | Checkpoint store for resumable subscribers (required for persisting `io()` results across retries)       |\n   345→\n   346→**Topology** is configured via `TopologyBuilder`:\n   347→\n   348→| Property       | Default | Description                                              |\n   349→| -------------- | ------- | -------------------------------------------------------- |\n   350→| `namespace`    | -       | Prefix for all queue names (required)                    |\n   351→| `queues`       | -       | Array of queue definitions (at least one required)       |\n   352→| `deadLetter`   | enabled | Dead-letter queue configuration (unhandled/undeliverable)|\n   353→| `retry`        | enabled | Retry queue configuration (defaultDelayMs: 1000ms, maxDelayMs: 5 minutes) |\n   354→\n   355→**Queue Definition** options:\n   356→\n   357→| Property          | Default | Description                                                |\n   358→| ----------------- | ------- | ---------------------------------------------------------- |\n   359→| `name`            | -       | Queue name (required)                                      |\n   360→| `concurrency`     | -       | Number of concurrent consumers for this queue              |\n   361→| `consumerTimeout` | -       | Consumer timeout in milliseconds                           |\n   362→| `priorities`      | false   | Enable priority support if transport allows                |\n   363→| `exact`           | false   | Use queue name exactly without namespace prefix            |\n   364→\n   365→**Retry Policy** defaults (`StandardRetryPolicy`):\n   366→\n   367→| Property           | Default  | Description                                              |\n   368→| ------------------ | -------- | -------------------------------------------------------- |\n   369→| `maxAttempts`      | 3        | Maximum retry attempts before dead-lettering             |\n   370→| `baseDelay`        | 1000ms   | Base delay between retries                               |\n   371→| `maxDelay`         | 300000ms | Maximum delay (5 minutes)                                |\n   372→| `backoffMultiplier`| 2        | Multiplier for exponential backoff                       |\n   373→| `maxDeliveries`    | 5        | Max native delivery count before poison detection        |\n   374→\n   375→**Checkpoint Store** options (for resumable subscribers):\n   376→\n   377→| Store                  | Description                                                                            |\n   378→| ---------------------- | -------------------------------------------------------------------------------------- |\n   379→| `MemoryCheckpointStore`| In-memory store for testing/development. Checkpoints are lost on process restart.      |\n   380→| `NoOpCheckpointStore`  | No-op store (default). `io()` works but doesn't persist across retries.                |\n   381→\n   382→For production, implement `CheckpointStore` interface with Redis or another persistent store.\n   383→\n   384→### `Hooks`\n   385→\n   386→Hooks are passed as the second argument to the `Matador` constructor and provide lifecycle callbacks for observability and dynamic configuration.\n   387→\n   388→**Lifecycle Hooks:**\n   389→\n   390→| Hook                     | Description                                                                           |\n   391→| ------------------------ | ------------------------------------------------------------------------------------- |\n   392→| `logger`                 | Logger instance for internal Matador logging (defaults to console)                    |\n   393→| `onEnqueueSuccess`       | Called when an event is successfully enqueued                                         |\n   394→| `onEnqueueWarning`       | Called when enqueue falls back to a secondary queue                                   |\n   395→| `onTransportFallback`    | Called when transport fallback occurs (MultiTransport with fallbackEnabled)           |\n   396→| `onEnqueueError`         | Called when enqueue fails completely                                                  |\n   397→| `onWorkerWrap`           | Wraps entire worker processing (for APM context like DataDog, NewRelic)               |\n   398→| `onWorkerBeforeProcess`  | Called before processing begins                                                       |\n   399→| `onWorkerSuccess`        | Called after successful processing                                                    |\n   400→| `onWorkerError`          | Called after processing error                                                         |\n   401→| `onDecodeError`          | Called when message decoding fails                                                    |\n   402→| `onConnectionStateChange`| Called when transport connection state changes                                        |\n   403→\n   404→**Dynamic Configuration Hooks:**\n   405→\n   406→| Hook                     | Description                                                                           |\n   407→| ------------------------ | ------------------------------------------------------------------------------------- |\n   408→| `loadUniversalMetadata`  | Loads metadata to add to all envelopes (e.g., correlationId from AsyncLocalStorage)   |\n   409→| `getQueueConcurrency`    | Dynamic queue concurrency lookup                                                      |\n   410→| `getRetryDelay`          | Dynamic retry delay lookup                                                            |\n   411→| `getAttempts`            | Dynamic max attempts lookup                                                           |\n   412→| `getMaxDeliveries`       | Dynamic max deliveries (poison threshold) lookup                                      |\n   413→\n   414→**Checkpoint Hooks (Resumable Subscribers):**\n   415→\n   416→| Hook                     | Description                                                                           |\n   417→| ------------------------ | ------------------------------------------------------------------------------------- |\n   418→| `onCheckpointLoaded`     | Called when a checkpoint is loaded for a retry                                        |\n   419→| `onCheckpointHit`        | Called when an `io()` operation uses a cached value                                   |\n   420→| `onCheckpointMiss`       | Called when an `io()` operation executes (cache miss)                                 |\n   421→| `onCheckpointCleared`    | Called when a checkpoint is cleared (success or dead-letter)                          |\n   422→\n   423→### `idempotent`\n   424→\n   425→> In programming, an idempotent operation is one that can be performed multiple times with the same result as if it were done only once.\n   426→\n   427→In **Matador**, `idempotent` has a very close meaning, but ultimately just means that an event is _allowed_ to be retried automatically by **Matador**.\n   428→\n   429→| Value       | Meaning                                                            | Retry Behavior                     |\n   430→| ----------- | ------------------------------------------------------------------ | ---------------------------------- |\n   431→| `'yes'`     | Subscriber is manually idempotent (safe to retry)                  | Retries allowed                    |\n   432→| `'no'`      | Subscriber is NOT idempotent (unsafe to retry)                     | Dead-letter on redelivery          |\n   433→| `'unknown'` | Idempotency not determined (default)                               | Dead-letter on redelivery          |\n   434→| `'resumable'` | Subscriber uses `io()` for checkpoint-based idempotency          | Retries allowed, checkpoint loaded |\n   435→\n   436→### `ResumableSubscriber`\n   437→\n   438→> ⚠️ This feature is experimental and not tested in production. \n   439→\n   440→Matador supports durable / resumable subscribers.\n   441→\n   442→This allows subscribers that fail to resume where they left off, allowing you to retry subscribers that otherwise would not be idempotent.\n   443→\n   444→This requires a persistent `CheckpointStore` to be configured (e.g., Redis, database, etc.).\n   445→\n   446→When using `idempotent: 'resumable'`, you can use the `io` function argument to wrap side-effects, which will be cached when successful.\n   447→\n   448→On subsequent retries, those successful `io` calls will return the cached value, instead of executing again.\n   449→\n   450→```ts\n   451→import { MemoryCheckpointStore } from '@zdavison/matador';\n   452→\n   453→// Configure Matador with a checkpoint store\n   454→const matador = new Matador({\n   455→  transport,\n   456→  topology,\n   457→  schema,\n   458→  consumeFrom: ['events'],\n   459→  checkpointStore: new MemoryCheckpointStore(), // Use RedisCheckpointStore in production\n   460→});\n   461→\n   462→// Define a resumable subscriber\n   463→const processOrder: Subscriber<OrderPlacedEvent> = {\n   464→  name: 'process-order',\n   465→  idempotent: 'resumable',  // Enables the io() function\n   466→  callback: async (envelope, { io }) => {\n   467→    const { orderId, userId, amount } = envelope.data;\n   468→\n   469→    // Step 1: Reserve inventory (cached on retry)\n   470→    const reservation = await io('reserve-inventory', async () => {\n   471→      return await inventoryService.reserve(orderId);\n   472→    });\n   473→\n   474→    // Step 2: Charge payment (cached on retry)\n   475→    const payment = await io('charge-payment', async () => {\n   476→      return await paymentService.charge(userId, amount);\n   477→    });\n   478→\n   479→    // Step 3: Send confirmation email (cached on retry)\n   480→    await io('send-confirmation', async () => {\n   481→      await emailService.send(userId, {\n   482→        subject: 'Order Confirmed',\n   483→        reservationId: reservation.id,\n   484→        transactionId: payment.transactionId,\n   485→      });\n   486→    });\n   487→  },\n   488→};\n   489→```\n   490→\n   491→If the subscriber crashes after charging the payment but before sending the email:\n   492→- On retry, `reserve-inventory` returns the cached reservation (no duplicate reservation)\n   493→- On retry, `charge-payment` returns the cached payment (no double charge)\n   494→- `send-confirmation` executes fresh (no cache entry exists)\n   495→\n   496→You can also use `all()` to execute multiple `io()` operations in parallel:\n   497→\n   498→```ts\n   499→const enrichUserData: Subscriber<UserCreatedEvent> = {\n   500→  name: 'enrich-user-data',\n   501→  idempotent: 'resumable',\n   502→  callback: async (envelope, { io, all }) => {\n   503→    const { userId } = envelope.data;\n   504→\n   505→    // Fetch multiple data sources in parallel (each with a unique key)\n   506→    const [profile, preferences, history] = await all([\n   507→      ['fetch-profile', async () => await profileService.get(userId)],\n   508→      ['fetch-preferences', async () => await prefsService.get(userId)],\n   509→      ['fetch-history', async () => await historyService.get(userId)],\n   510→    ]);\n   511→\n   512→    // Use the enriched data\n   513→    await io('save-enrichment', async () => {\n   514→      await enrichmentService.save({ userId, profile, preferences, history });\n   515→    });\n   516→  },\n   517→};\n   518→```\n   519→\n   520→Each `io()` key must be unique within the subscriber and stable across retries. Use descriptive names like `'fetch-user'`, `'send-email'`, or `'charge-payment'`.\n   521→\n   522→# Why it works this way\n   523→\n   524→Since **Matador** is opinionated, we should explain the rationale behind our choices.\n   525→\n   526→### Sending one message will result in a unique message _per subscriber_.\n   527→\n   528→When you send an event in **Matador**, there is a unique copy of that event sent with different `Docket` details.\n   529→\n   530→This is automatic, and referred to as _fanout_ within **Matador**.\n   531→\n   532→We chose this model because while it results in `N` real events per published event, it allows each real event to be retried and managed individually. A single failed subscriber does not affect any others or result in any additional cognitive complexity about the system.\n   533→\n   534→This however does have the impact of requiring the publisher to know about the subscriber. \n   535→This is easy in a monorepo environment, but for remote subscribers, you can use `SubscriberStub`.\n   536→\n   537→### You are working in a monorepo\n   538→\n   539→While it is possible to use **Matador** outside of a monorepo environment, it is designed to work in a situation where you can easily share code between your applications.\n   540→This is because both the _publisher_ and the _consumer_ need to know about the event _schema_ (e.g. which events map to which subscribers).\n   541→\n   542→You can either share the code for your `MatadorSchema`, or you can make your workers simply be different instances of the same codebase (with different configuration).\n   543→\n   544→```ts\n   545→// Example: Dynamic configuration based on environment\n   546→const matador = new Matador(\n   547→  {\n   548→    transport,\n   549→    topology,\n   550→    schema: myMatadorSchema,\n   551→    // Only consume in worker mode\n   552→    consumeFrom: process.env.WORKER_MODE === 'true' ? ['events'] : [],\n   553→  },\n   554→  {\n   555→    // Dynamic hooks can use runtime config\n   556→    getAttempts: async (envelope) => {\n   557→      // High-importance events get more retries\n   558→      if (envelope.docket.importance === 'must-investigate') {\n   559→        return 5;\n   560→      }\n   561→      return 3;\n   562→    },\n   563→  }\n   564→);\n   565→```\n   566→\n   567→### You want a conventional queue topology to be managed for you\n   568→\n   569→Because making queue topology choices can be difficult, we decided to create a reasonable, good-for-most-use-cases design that covers the basic needs.\n   570→\n   571→In our org, we have been using this topology for 2+ years, and it's suited most of our needs. We create new queues, but the 'infrastructure queues' (e.g. dead-letter, retry, etc), we don't need to touch.\n   572→\n   573→So that you can get up and running quickly, **Matador** makes a lot of assumptions about how events should be routed and retried, and you're buying into those conventions by using **Matador**.\n   574→\n   575→If you want precise control over your queue topology, **Matador** may not be suitable for you.\n   576→\n   577→### You want `at-least-once` delivery.\n   578→\n   579→There are two options for delivery in an event system.\n   580→\n   581→- `at-least-once`: Every message is guaranteed to be delivered once, but may deliver more times in some edge-cases.\n   582→- `at-most-once`: Every message is guaranteed to be delivered at most once, but may not be delivered at all in some edge cases.\n   583→\n   584→Any system that promises `exactly-once` is lying to you, because there are always timeout scenarios in a distributed system that mean that there may still be a very small possibility of a message being either delivered multiple times (`at-least-once`) or not at all (`at-most-once`).\n   585→\n   586→The choice essentially comes down to when you `ack` (acknowledge) a message.\n   587→\n   588→- **Before processing**: `at-most-once`. If the worker crashes after ack but before completing, the message is lost.\n   589→- **After processing**: `at-least-once`. If the worker crashes after completing but before ack, the message may be redelivered.\n   590→\n   591→**Matador** uses `at-least-once` delivery by acknowledging messages only after successful processing.\n   592→\n   593→# Logging\n   594→\n   595→**Matador** uses a pluggable logger interface. You can provide your own logger via the `logger` hook:\n   596→\n   597→```ts\n   598→const matador = new Matador(config, {\n   599→  logger: {\n   600→    debug: (msg, ...args) => myLogger.debug(msg, ...args),\n   601→    info: (msg, ...args) => myLogger.info(msg, ...args),\n   602→    warn: (msg, ...args) => myLogger.warn(msg, ...args),\n   603→    error: (msg, ...args) => myLogger.error(msg, ...args),\n   604→  },\n   605→});\n   606→```\n   607→\n   608→### Log Messages by Level\n   609→\n   610→**Debug:**\n   611→\n   612→| Message                                               | Context                                            |\n   613→| ----------------------------------------------------- | -------------------------------------------------- |\n   614→| `[Matador] 🔌 Delayed message exchange plugin detected` | RabbitMQ delayed message plugin is available       |\n   615→\n   616→**Warn:**\n   617→\n   618→| Message                                                                   | Context                                                    |\n   619→| ------------------------------------------------------------------------- | ---------------------------------------------------------- |\n   620→| `[Matador] 🟡 RabbitMQ delayed message exchange plugin not available...`  | RabbitMQ plugin not installed, delayed messages disabled   |\n   621→| `[Matador] ⚠️ Shutdown timeout reached with N events still processing`    | Graceful shutdown timed out with pending events            |\n   622→| `[Matador] 🟡 Hook onWorkerWrap threw an error`                           | The `onWorkerWrap` hook threw an exception                 |\n   623→| `[Matador] 🟡 Hook loadUniversalMetadata threw an error`                  | The `loadUniversalMetadata` hook threw an exception        |\n   624→| `[Matador] 🟡 Hook getQueueConcurrency threw an error`                    | The `getQueueConcurrency` hook threw an exception          |\n   625→| `[Matador] 🟡 Hook getRetryDelay threw an error`                          | The `getRetryDelay` hook threw an exception                |\n   626→| `[Matador] 🟡 Hook getAttempts threw an error`                            | The `getAttempts` hook threw an exception                  |\n   627→| `[Matador] 🟡 Hook getMaxDeliveries threw an error`                       | The `getMaxDeliveries` hook threw an exception             |\n   628→| `[Matador] 🟡 Hook {hookName} threw an error`                             | Any other lifecycle hook threw an exception                |\n   629→\n   630→**Error:**\n   631→\n   632→| Message                                               | Context                                                     |\n   633→| ----------------------------------------------------- | ----------------------------------------------------------- |\n   634→| `[Matador] 🔴 RabbitMQ connection error`              | RabbitMQ connection encountered an error                    |\n   635→| `[Matador] 🔴 RabbitMQ publish channel error`         | RabbitMQ publish channel encountered an error               |\n   636→| `[Matador] 🔴 Handler error in message processing`    | Subscriber callback threw an unhandled exception            |\n   637→| `[Matador] 🔴 Failed to enqueue delayed message`      | LocalTransport failed to enqueue a delayed message          |\n   638→\n   639→For application-level logging (event processing, success/failure tracking), use the lifecycle hooks (`onWorkerSuccess`, `onWorkerError`, `onEnqueueSuccess`, etc.).\n   640→\n   641→# Errors\n   642→\n   643→All errors in **Matador** extend `MatadorError` and include a `description` field explaining the cause and recommended action.\n   644→\n   645→| Error                             | Description                                                                                |\n   646→| --------------------------------- | ------------------------------------------------------------------------------------------ |\n   647→| `NotStartedError`                 | Matador has not been started. Call `matador.start()` first.                                |\n   648→| `ShutdownInProgressError`         | Matador is shutting down and will not accept new events.                                   |\n   649→| `TransportNotConnectedError`      | Transport is not connected to the message broker.                                          |\n   650→| `TransportClosedError`            | Transport has been closed (during shutdown).                                               |\n   651→| `AllTransportsFailedError`        | All transports in a fallback chain failed.                                                 |\n   652→| `TransportSendError`              | Failed to send a message through the transport.                                            |\n   653→| `DelayedMessagesNotSupportedError`| Delayed messages requested but transport doesn't support them.                             |\n   654→| `EventNotRegisteredError`         | Event type is not registered in the schema.                                                |\n   655→| `SubscriberNotRegisteredError`    | Subscriber is not registered for this event.                                               |\n   656→| `NoSubscribersExistError`         | Event has no subscribers registered.                                                       |\n   657→| `InvalidSchemaError`              | Schema configuration is invalid.                                                           |\n   658→| `SubscriberIsStubError`           | A SubscriberStub was registered in a consuming schema.                                     |\n   659→| `LocalTransportCannotProcessStubError` | LocalTransport cannot process events for SubscriberStubs.                             |\n   660→| `QueueNotFoundError`              | Queue does not exist or has not been created.                                              |\n   661→| `InvalidEventError`               | Event is invalid or missing required fields.                                               |\n   662→| `MessageMaybePoisonedError`       | Message redelivered too many times (possible poison message).                              |\n   663→| `IdempotentMessageCannotRetryError` | Non-idempotent subscriber received a redelivered message.                                |\n   664→| `TimeoutError`                    | Operation timed out before completing.                                                     |\n   665→\n   666→**Checkpoint Errors** (resumable subscribers):\n   667→\n   668→| Error                   | Description                                                                                      |\n   669→| ----------------------- | ------------------------------------------------------------------------------------------------ |\n   670→| `DuplicateIoKeyError`   | Same `io()` key used multiple times in a single subscriber execution. Keys must be unique.       |\n   671→| `CheckpointStoreError`  | Checkpoint store operation failed (get/set/delete). Check underlying storage connectivity.       |\n   672→\n   673→**Retry Control Errors** (thrown by subscribers to control retry behavior):\n   674→\n   675→| Error                | Description                                                                                    |\n   676→| -------------------- | ---------------------------------------------------------------------------------------------- |\n   677→| `DoRetry`            | Forces retry regardless of subscriber idempotency setting.                                     |\n   678→| `DontRetry`          | Prevents retry regardless of subscriber idempotency setting. Message goes to dead-letter.      |\n   679→| `EventAssertionError`| Assertion error that should never be retried. Goes directly to dead-letter queue.              |\n   680→\n   681→# Other features\n   682→\n   683→### `universalMetadata`\n   684→\n   685→It is often the case that you want every event to have a consistent set of metadata.\n   686→**Matador** provides a hook `loadUniversalMetadata` which you can use to do this.\n   687→\n   688→You can combine this with `asyncLocalStorage` to set session based metadata on your events.\n   689→\n   690→Here is a real world example:\n   691→\n   692→```ts\n   693→loadUniversalMetadata: () => {\n   694→  const store = asyncLocalStorage?.getStore()\n   695→  return {\n   696→    timestamp: new Date(),\n   697→    correlationId: store?.correlationId || null,\n   698→    userId: store?.userId || null,\n   699→  }\n   700→},\n   701→```\n   702→\n   703→### Schema plugins\n   704→\n   705→Sometimes, you want to run a subscriber on every event in your _schema_.\n   706→Instead of defining the subscriber mapping for every event, you can use `installPlugins` to add global subscribers:\n   707→\n   708→```ts\n   709→import { installPlugins } from '@zdavison/matador';\n   710→\n   711→const baseSchema: MatadorSchema = {\n   712→  [UserCreatedEvent.key]: [UserCreatedEvent, [sendWelcomeEmail]],\n   713→  [OrderPlacedEvent.key]: [OrderPlacedEvent, [processOrder]],\n   714→  [ChatMessageSentEvent.key]: [ChatMessageSentEvent, [notifyRecipient]],\n   715→};\n   716→\n   717→const myMatadorSchema = installPlugins(baseSchema, [\n   718→  {\n   719→    subscriber: logToBigQuery,\n   720→    exclusions: [ChatMessageSentEvent.key], // Don't log chat messages\n   721→  }\n   722→]);\n   723→```\n   724→\n   725→Each plugin defines a `subscriber` and optional `exclusions` array of event keys to skip.\n   726→\n   727→### `DoRetry` & `DontRetry`\n   728→\n   729→Sometimes, your subscribers may want to explicitly control if they should be retried or not.\n   730→This is useful in cases where a message is _sometimes_ idempotent, but in certain cases (e.g. error scenarios) it is not.\n   731→\n   732→```ts\n   733→import { DoRetry, DontRetry } from '@zdavison/matador';\n   734→\n   735→const processPayment: Subscriber<PaymentRequestedEvent> = {\n   736→  name: 'process-payment',\n   737→  idempotent: 'no', // Default: don't retry\n   738→  callback: async (envelope) => {\n   739→    try {\n   740→      await paymentGateway.charge(envelope.data.amount);\n   741→    } catch (error) {\n   742→      if (error.code === 'TEMPORARY_FAILURE') {\n   743→        // Gateway is temporarily unavailable, safe to retry\n   744→        throw new DoRetry('Payment gateway temporarily unavailable');\n   745→      }\n   746→      if (error.code === 'CARD_DECLINED') {\n   747→        // Permanent failure, don't retry\n   748→        throw new DontRetry('Card was declined');\n   749→      }\n   750→      throw error; // Default behavior based on idempotent setting\n   751→    }\n   752→  },\n   753→};\n   754→```\n   755→\n   756→### `LocalTransport`\n   757→\n   758→Matador includes a `LocalTransport`, which is an in-memory transport that will simply process events on the same machine.\n   759→This allows you to develop locally without having a message broker, then simply switch to using an actual message broker when you deploy.\n   760→\n   761→### `MultiTransport`\n   762→\n   763→`MultiTransport` allows you to declare a group of transports, and then switch between them at runtime.\n   764→\n   765→You can also use configure it with `fallbackEnabled` (default: `true`), and if enqueuing a message fails, it can fallback to another queue system (in declared order).\n   766→\n   767→You can combine this with `LocalTransport` to make messages that fail to enqueue execute locally, providing resilience against your message broker being unavailable or timing out.\n   768→\n   769→```ts\n   770→import { MultiTransport, RabbitMQTransport, LocalTransport } from '@zdavison/matador';\n   771→\n   772→const rabbitTransport = new RabbitMQTransport({ url: 'amqp://localhost' });\n   773→const localTransport = new LocalTransport();\n   774→\n   775→const transport = new MultiTransport(\n   776→  {\n   777→    transports: [rabbitTransport, localTransport],\n   778→    fallbackEnabled: true, // Default: true\n   779→  },\n   780→  {\n   781→    // Optional: dynamically select backend based on feature flags\n   782→    getDesiredBackend: async () => {\n   783→      if (process.env.SANDBOX === 'true') return 'local';\n   784→      const useLocal = await featureFlags.isEnabled('use-local-transport');\n   785→      return useLocal ? 'local' : 'rabbitmq';\n   786→    },\n   787→    // Optional: log when fallback occurs\n   788→    onEnqueueFallback: (ctx) => {\n   789→      console.warn(`Fallback from ${ctx.failedTransport} to ${ctx.nextTransport}: ${ctx.error.message}`);\n   790→    },\n   791→  }\n   792→);\n   793→\n   794→const matador = new Matador({\n   795→  transport,\n   796→  topology,\n   797→  schema,\n   798→  consumeFrom: ['events'],\n   799→});\n   800→```\n   801→\n   802→### `enabled()` hook for `Subscriber`\n   803→\n   804→Sometimes, you want to enable / disable subscribers at runtime using feature flags.\n   805→\n   806→Each subscriber accepts an `enabled()` callback, which is invoked before **publishing** an event for that subscriber. If `enabled()` returns `false`, the message is not sent for that subscriber (it's skipped during fanout). If the check fails with an error, the subscriber is treated as enabled.\n   807→\n   808→```ts\n   809→const sendWelcomeEmail: Subscriber<UserCreatedEvent> = {\n   810→  name: 'send-welcome-email',\n   811→  idempotent: 'yes',\n   812→  enabled: async () => {\n   813→    // Check feature flag\n   814→    return await featureFlags.isEnabled('welcome-email-v2');\n   815→  },\n   816→  callback: async (envelope) => {\n   817→    await emailService.sendWelcome(envelope.data.email);\n   818→  },\n   819→};\n   820→\n   821→// Sync enabled check is also supported\n   822→const legacySubscriber: Subscriber<UserCreatedEvent> = {\n   823→  name: 'legacy-handler',\n   824→  enabled: () => process.env.ENABLE_LEGACY === 'true',\n   825→  callback: async (envelope) => { /* ... */ },\n   826→};\n   827→```\n   828→\n   829→### `importance`\n   830→\n   831→`importance` is an optional field that allows you to note how critical a subscriber failure is.\n   832→This is useful for setting up alerts in your observability platform.\n   833→\n   834→For example, if an analytics event fails, it is likely unimportant, but if a payment related subscriber fails, it warrants investigation and should trigger an alert.\n   835→\n   836→Available importance levels:\n   837→- `'can-ignore'` - Failures are not critical (e.g., analytics, logging)\n   838→- `'should-investigate'` - Failures should be reviewed (default)\n   839→- `'must-investigate'` - Failures are critical and require immediate attention (e.g., payments)\n   840→\n   841→```ts\n   842→const trackAnalytics: Subscriber<UserCreatedEvent> = {\n   843→  name: 'track-analytics',\n   844→  importance: 'can-ignore', // Don't alert on failures\n   845→  callback: async (envelope) => {\n   846→    await analytics.track('user_created', envelope.data);\n   847→  },\n   848→};\n   849→\n   850→const processPayment: Subscriber<PaymentRequestedEvent> = {\n   851→  name: 'process-payment',\n   852→  importance: 'must-investigate', // Critical - alert immediately on failures\n   853→  callback: async (envelope) => {\n   854→    await paymentGateway.charge(envelope.data);\n   855→  },\n   856→};\n   857→\n   858→// Use in hooks for alerting\n   859→const matador = new Matador(config, {\n   860→  onWorkerError: (ctx) => {\n   861→    if (ctx.subscriber.importance === 'must-investigate') {\n   862→      alerting.critical(`Subscriber ${ctx.subscriber.name} failed: ${ctx.error.message}`);\n   863→    }\n   864→  },\n   865→});\n   866→```\n   867→\n   868→### Delayed messages\n   869→\n   870→> Delayed messages implementation is dependent on the `Transport` used.\n   871→\n   872→You can optionally delay messages in Matador. This will cause their delivery to be delayed.\n   873→\n   874→When using `RabbitMQTransport`, this is implemented using the [delayed-message-exchange plugin](https://github.com/rabbitmq/rabbitmq-delayed-message-exchange), and you should ensure it is installed in your RabbitMQ instance first.\n   875→\n   876→> Note: Distributed event systems do not have precise delivery timings. The consumption of your event will be dependent on your throughput, and you should not depend on delayed messages for accurate timings.\n   877→\n   878→```ts\n   879→// Delay message by 5 minutes\n   880→await matador.send(ReminderEvent, { userId: '123', message: 'Hello!' }, {\n   881→  delayMs: 5 * 60 * 1000, // 5 minutes\n   882→});\n   883→\n   884→// Delay can also be used with correlationId and metadata\n   885→await matador.send(ScheduledNotificationEvent, notificationData, {\n   886→  delayMs: 60000, // 1 minute\n   887→  correlationId: 'notification-123',\n   888→  metadata: { scheduledBy: 'cron-job' },\n   889→});\n   890→```\n   891→\n   892→# CLI\n   893→\n   894→Matador provides a CLI utility for quick local testing of your Matador configuration.\n   895→\n   896→```bash\n   897→# Send an event using config and event files\n   898→bunx matador send <config-file> <event-file> [options]\n   899→\n   900→# Send a test event defined in the config file\n   901→bunx matador send-test-event <config-file> [options]\n   902→```\n   903→\n   904→**Options:**\n   905→- `--help, -h` - Show help message\n   906→- `--dry-run` - Validate config and event without dispatching\n   907→- `--timeout` - Timeout in milliseconds for processing (default: 5000)\n   908→- `--verbose` - Show verbose output including all hook logs\n   909→\n   910→**Config file** should export:\n   911→- `schema: MatadorSchema` - Map of event keys to [EventClass, Subscribers[]]\n   912→- `topology?: Topology` - Optional topology (defaults to simple 'events' queue)\n   913→- `hooks?: MatadorHooks` - Optional hooks\n   914→- `testEvent?: { eventKey, data, before?, options? }` - Test event for `send-test-event` command\n   915→\n   916→**Event file** should export:\n   917→- `eventKey: string` - The key of the event to dispatch\n   918→- `data: unknown` - The event data payload\n   919→- `before?: unknown` - Optional 'before' data for change events\n   920→- `options?: EventOptions` - Optional dispatch options (correlationId, metadata, delayMs)\n   921→\n   922→**Examples:**\n   923→```bash\n   924→bunx matador send ./my-config.ts ./test-event.ts --verbose\n   925→bunx matador send-test-event ./my-config.ts\n   926→```\n   927→\n   928→# Thanks\n   929→\n   930→Thank you to the following MeetsMore engineers who worked on our internal V1 version of Matador.\n   931→\n   932→Matador V2 would not exist without your contributions.\n   933→\n   934→- https://github.com/GuillaumeDeconinck\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-12T07:52:44.443Z"
        },
        {
          "type": "assistant",
          "text": "I'll create an ASCII architecture diagram showing the internal flow of Matador components. Let me add it to the README in a new Architecture section after Features.",
          "timestamp": "2025-12-12T07:53:04.175Z"
        },
        {
          "type": "tool_use",
          "name": "Edit",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/README.md",
            "new_string": "# Architecture\n\n```\n┌─────────────────────────────────────────────────────────────────────────────────┐\n│                                   MATADOR                                       │\n│                              (Orchestrator)                                     │\n├─────────────────────────────────────────────────────────────────────────────────┤\n│                                                                                 │\n│  ┌─────────────────────────────────────────────────────────────────────────┐   │\n│  │                         DISPATCH PATH (Producer)                        │   │\n│  │                                                                         │   │\n│  │   matador.send(Event, data)                                             │   │\n│  │           │                                                             │   │\n│  │           ▼                                                             │   │\n│  │   ┌──────────────┐      ┌──────────────┐      ┌──────────────┐         │   │\n│  │   │    SCHEMA    │─────▶│    FANOUT    │─────▶│    CODEC     │         │   │\n│  │   │              │      │              │      │              │         │   │\n│  │   │ Event → Subs │      │ 1 Event →    │      │  Envelope →  │         │   │\n│  │   │   mapping    │      │ N Envelopes  │      │    bytes     │         │   │\n│  │   └──────────────┘      └──────────────┘      └──────┬───────┘         │   │\n│  │                                                      │                  │   │\n│  │                                                      ▼                  │   │\n│  │                                              ┌──────────────┐           │   │\n│  │                                              │  TRANSPORT   │           │   │\n│  │                                              │              │           │   │\n│  │                                              │ Send to      │           │   │\n│  │                                              │ broker       │──────────────▶ Broker\n│  │                                              └──────────────┘           │   │\n│  └─────────────────────────────────────────────────────────────────────────┘   │\n│                                                                                 │\n│  ┌─────────────────────────────────────────────────────────────────────────┐   │\n│  │                         CONSUME PATH (Consumer)                         │   │\n│  │                                                                         │   │\n│  │   Broker ──────────────────────────────────────────────────────────────────▶│\n│  │           │                                                             │   │\n│  │           ▼                                                             │   │\n│  │   ┌──────────────┐                                                      │   │\n│  │   │  TRANSPORT   │                                                      │   │\n│  │   │              │                                                      │   │\n│  │   │ Receive from │                                                      │   │\n│  │   │ broker       │                                                      │   │\n│  │   └──────┬───────┘                                                      │   │\n│  │          │                                                              │   │\n│  │          ▼                                                              │   │\n│  │   ┌─────────────────────────────────────────────────────────────────┐   │   │\n│  │   │                         PIPELINE                                │   │   │\n│  │   │                                                                 │   │   │\n│  │   │  ┌────────┐   ┌────────┐   ┌────────┐   ┌────────┐   ┌───────┐ │   │   │\n│  │   │  │ CODEC  │──▶│ SCHEMA │──▶│ RETRY  │──▶│CALLBACK│──▶│ACK/   │ │   │   │\n│  │   │  │        │   │        │   │ POLICY │   │        │   │NACK   │ │   │   │\n│  │   │  │ bytes→ │   │ lookup │   │        │   │execute │   │       │ │   │   │\n│  │   │  │Envelope│   │  sub   │   │ check  │   │  sub   │   │result │ │   │   │\n│  │   │  └────────┘   └────────┘   └────────┘   └────────┘   └───────┘ │   │   │\n│  │   │                                                                 │   │   │\n│  │   └─────────────────────────────────────────────────────────────────┘   │   │\n│  │                                                                         │   │\n│  └─────────────────────────────────────────────────────────────────────────┘   │\n│                                                                                 │\n│  ┌─────────────────────────────────────────────────────────────────────────┐   │\n│  │                           SUPPORTING COMPONENTS                         │   │\n│  │                                                                         │   │\n│  │  ┌──────────────┐   ┌──────────────┐   ┌──────────────┐                 │   │\n│  │  │   TOPOLOGY   │   │    HOOKS     │   │  SHUTDOWN    │                 │   │\n│  │  │              │   │              │   │   MANAGER    │                 │   │\n│  │  │ Queue config │   │ Lifecycle    │   │              │                 │   │\n│  │  │ & structure  │   │ callbacks    │   │ Graceful     │                 │   │\n│  │  │              │   │              │   │ drain        │                 │   │\n│  │  └──────────────┘   └──────────────┘   └──────────────┘                 │   │\n│  │                                                                         │   │\n│  │  ┌──────────────┐                                                       │   │\n│  │  │  CHECKPOINT  │  (Optional - for resumable subscribers)               │   │\n│  │  │    STORE     │                                                       │   │\n│  │  │              │                                                       │   │\n│  │  │ io() results │                                                       │   │\n│  │  │   cache      │                                                       │   │\n│  │  └──────────────┘                                                       │   │\n│  └─────────────────────────────────────────────────────────────────────────┘   │\n│                                                                                 │\n└─────────────────────────────────────────────────────────────────────────────────┘\n\nComponent Responsibilities:\n───────────────────────────\n  SCHEMA        Maps EventKey → [EventClass, Subscriber[]]\n  FANOUT        Creates unique envelope per subscriber (1:N distribution)\n  CODEC         Serializes/deserializes envelopes (JSON by default)\n  TRANSPORT     Broker abstraction (RabbitMQ, Local, Multi)\n  PIPELINE      Message processing: decode → validate → execute → ack/nack\n  RETRY POLICY  Determines retry behavior based on attempts & idempotency\n  TOPOLOGY      Defines queue structure (main, retry, dead-letter queues)\n  HOOKS         Lifecycle callbacks for observability & dynamic config\n  SHUTDOWN      Manages graceful shutdown with in-flight message draining\n  CHECKPOINT    Persists io() results for resumable subscribers\n```\n\n# Getting Started\n\n### Define a MatadorEvent",
            "old_string": "# Getting Started\n\n### Define a MatadorEvent"
          },
          "timestamp": "2025-12-12T07:53:26.283Z"
        }
      ],
      "total_additions": 158,
      "total_deletions": 88,
      "accepted_lines": 70,
      "overriden_lines": 0
    }
  }
}
