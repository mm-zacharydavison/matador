---
{
  "schema_version": "authorship/3.0.0",
  "git_ai_version": "1.0.22",
  "base_commit_sha": "40787211240b186ed76ad06d160210171d367362",
  "prompts": {
    "073f38be972407b0": {
      "agent_id": {
        "tool": "claude",
        "id": "ad11fd6a-0c9d-4c1c-8873-667629c536dc",
        "model": "claude-opus-4-5-20251101"
      },
      "human_author": "Zachary Davison <zachary.davison@meetsmore.com>",
      "messages": [
        {
          "type": "user",
          "text": "We want to allow subscribers to resume, if they fail part way through.\n\nTo do so, we want to pass an 'io' function to subscribers that takes a lambda, that lambda will perform some side-effect or mutation, and return a value\n\nThose returned values should be cached.\n\nIf a subscriber crashes midway through and is retried, if there is a cache for an `io` call available, that cache will be used and the `io` will not be executed.\n\nThis allows subscribers to retry and run from where they left off.\n\nultrathink and write a plan in docs/plans on how to implement such a feature",
          "timestamp": "2025-12-11T13:15:13.241Z"
        },
        {
          "type": "assistant",
          "text": "I'll explore the codebase to understand the current architecture before designing this feature.",
          "timestamp": "2025-12-11T13:15:23.603Z"
        },
        {
          "type": "tool_use",
          "name": "Task",
          "input": {
            "description": "Explore Matador codebase architecture",
            "prompt": "I need to understand the Matador event processing library architecture in depth to design a resumable subscriber feature. Please explore:\n\n1. How subscribers are defined and what interface they implement (look in types/ and schema/)\n2. How the pipeline processes messages and executes subscriber callbacks (pipeline/)\n3. How retry logic works currently (retry/)\n4. How envelopes track attempt information (types/)\n5. How the Matador orchestrator wires everything together (core/)\n6. Any existing hooks that might be relevant (hooks/)\n\nBe very thorough - I need to understand the full message lifecycle from dispatch to subscriber execution to design a checkpointing/caching system for resumable subscribers.",
            "subagent_type": "Explore"
          },
          "timestamp": "2025-12-11T13:15:27.922Z"
        },
        {
          "type": "assistant",
          "text": "Now I have a thorough understanding of the architecture. Let me create the plan document.",
          "timestamp": "2025-12-11T13:16:57.368Z"
        },
        {
          "type": "tool_use",
          "name": "Bash",
          "input": {
            "command": "mkdir -p /home/z/Desktop/work/matador/docs/plans",
            "description": "Create plans directory"
          },
          "timestamp": "2025-12-11T13:16:58.512Z"
        },
        {
          "type": "tool_use",
          "name": "Write",
          "input": {
            "content": "# Resumable Subscribers Implementation Plan\n\n## Problem Statement\n\nWhen a subscriber fails partway through execution (e.g., after calling an external API but before completing), retrying the message re-executes all operations from the beginning. This can cause:\n\n- Duplicate side effects (double charges, duplicate emails, etc.)\n- Wasted compute on operations that already succeeded\n- Complex manual idempotency handling in every subscriber\n\n## Proposed Solution\n\nProvide subscribers with an `io` function that:\n1. Wraps side-effectful operations in a cacheable lambda\n2. Caches successful results keyed by a deterministic identifier\n3. On retry, returns cached values instead of re-executing\n\nThis pattern is inspired by workflow engines like Temporal/Cadence, adapted for Matador's event-driven model.\n\n## API Design\n\n### Subscriber Callback Signature Change\n\n```typescript\n// Current\ntype SubscriberCallback<T> = (envelope: Envelope<T>) => Promise<void> | void;\n\n// Proposed - add context parameter with io function\ntype SubscriberCallback<T> = (\n  envelope: Envelope<T>,\n  context: SubscriberContext\n) => Promise<void> | void;\n\ninterface SubscriberContext {\n  /**\n   * Wraps a side-effectful operation for caching/replay.\n   * On first execution: runs the lambda and caches the result.\n   * On retry: returns cached result without re-executing.\n   *\n   * @param key - Unique identifier for this operation within this subscriber\n   * @param fn - The side-effectful operation to execute\n   * @returns The result of fn (or cached result on retry)\n   */\n  io<T>(key: string, fn: () => Promise<T> | T): Promise<T>;\n\n  /**\n   * Current attempt number (1-based)\n   */\n  attempt: number;\n\n  /**\n   * Whether this is a retry (attempt > 1)\n   */\n  isRetry: boolean;\n}\n```\n\n### Usage Example\n\n```typescript\nconst sendWelcomeEmail = createSubscriber<UserCreatedEvent>({\n  name: 'send-welcome-email',\n  idempotent: 'yes',\n\n  async callback(envelope, { io }) {\n    const { userId, email } = envelope.data;\n\n    // Step 1: Fetch user preferences (cached on retry)\n    const prefs = await io('fetch-prefs', async () => {\n      return await userService.getPreferences(userId);\n    });\n\n    // Step 2: Generate email content (cached on retry)\n    const emailContent = await io('generate-email', async () => {\n      return await templateService.render('welcome', { prefs });\n    });\n\n    // Step 3: Send email (cached on retry)\n    const sendResult = await io('send-email', async () => {\n      return await emailService.send(email, emailContent);\n    });\n\n    // Step 4: Record analytics (cached on retry)\n    await io('record-analytics', async () => {\n      await analytics.track('welcome_email_sent', { userId, messageId: sendResult.id });\n    });\n  }\n});\n```\n\nIf the subscriber crashes after Step 2 but before Step 3:\n- On retry, Steps 1-2 return cached values instantly\n- Step 3 executes fresh (no cache entry exists)\n\n## Architecture\n\n### Components\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                         Matador Core                            │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│  ┌─────────────────┐      ┌──────────────────────────────────┐  │\n│  │ ProcessingPipeline│ ──→ │ ResumableContext                 │  │\n│  │                 │      │                                  │  │\n│  │ - process()     │      │ - io(key, fn): Promise<T>        │  │\n│  │ - executeCallback│      │ - loadCheckpoint()               │  │\n│  │                 │      │ - saveCheckpoint()               │  │\n│  └─────────────────┘      │ - clearCheckpoint()              │  │\n│           │               └──────────────┬───────────────────┘  │\n│           │                              │                      │\n│           │                              ▼                      │\n│           │               ┌──────────────────────────────────┐  │\n│           │               │ CheckpointStore (Interface)      │  │\n│           │               │                                  │  │\n│           │               │ - get(envelopeId): Checkpoint    │  │\n│           │               │ - set(envelopeId, checkpoint)    │  │\n│           │               │ - delete(envelopeId)             │  │\n│           │               └──────────────────────────────────┘  │\n│           │                              │                      │\n│           │               ┌──────────────┼──────────────┐       │\n│           │               ▼              ▼              ▼       │\n│           │         ┌──────────┐  ┌───────────┐  ┌───────────┐  │\n│           │         │ Memory   │  │ Redis     │  │ Envelope  │  │\n│           │         │ Store    │  │ Store     │  │ Metadata  │  │\n│           │         └──────────┘  └───────────┘  └───────────┘  │\n│           │                                                     │\n│           ▼                                                     │\n│  ┌─────────────────────────────────────────────────────────────┐│\n│  │ Subscriber Callback                                         ││\n│  │                                                             ││\n│  │  callback(envelope, { io, attempt, isRetry })               ││\n│  │                                                             ││\n│  └─────────────────────────────────────────────────────────────┘│\n└─────────────────────────────────────────────────────────────────┘\n```\n\n### Checkpoint Data Structure\n\n```typescript\ninterface Checkpoint {\n  envelopeId: string;\n  subscriberName: string;\n  createdAt: string;           // ISO 8601\n  updatedAt: string;           // ISO 8601\n  completedSteps: Map<string, CheckpointEntry>;\n}\n\ninterface CheckpointEntry {\n  key: string;\n  value: unknown;              // Serialized result\n  completedAt: string;         // ISO 8601\n  durationMs: number;          // Original execution time\n}\n```\n\n### CheckpointStore Interface\n\n```typescript\ninterface CheckpointStore {\n  /**\n   * Retrieve checkpoint for an envelope\n   */\n  get(envelopeId: string): Promise<Checkpoint | undefined>;\n\n  /**\n   * Save/update checkpoint\n   */\n  set(envelopeId: string, checkpoint: Checkpoint): Promise<void>;\n\n  /**\n   * Delete checkpoint (on success or dead-letter)\n   */\n  delete(envelopeId: string): Promise<void>;\n\n  /**\n   * Optional: TTL-based cleanup for orphaned checkpoints\n   */\n  cleanup?(olderThan: Date): Promise<number>;\n}\n```\n\n### Implementations\n\n#### 1. MemoryCheckpointStore (Default, for testing)\n\n```typescript\nclass MemoryCheckpointStore implements CheckpointStore {\n  private checkpoints = new Map<string, Checkpoint>();\n\n  async get(envelopeId: string): Promise<Checkpoint | undefined> {\n    return this.checkpoints.get(envelopeId);\n  }\n\n  async set(envelopeId: string, checkpoint: Checkpoint): Promise<void> {\n    this.checkpoints.set(envelopeId, checkpoint);\n  }\n\n  async delete(envelopeId: string): Promise<void> {\n    this.checkpoints.delete(envelopeId);\n  }\n}\n```\n\n#### 2. EnvelopeMetadataCheckpointStore (Portable, limited size)\n\nStores checkpoint in `envelope.docket.metadata._checkpoint`. Travels with the message but limited to ~64KB.\n\n```typescript\nclass EnvelopeMetadataCheckpointStore implements CheckpointStore {\n  // Checkpoint is stored/retrieved from envelope metadata\n  // Useful when no external store is available\n  // Limited by message size constraints\n}\n```\n\n#### 3. RedisCheckpointStore (Production)\n\n```typescript\nclass RedisCheckpointStore implements CheckpointStore {\n  constructor(private redis: Redis, private options: {\n    prefix?: string;        // Key prefix, default: 'matador:checkpoint:'\n    ttlSeconds?: number;    // TTL for cleanup, default: 86400 (24h)\n  }) {}\n\n  async get(envelopeId: string): Promise<Checkpoint | undefined> {\n    const data = await this.redis.get(this.key(envelopeId));\n    return data ? JSON.parse(data) : undefined;\n  }\n\n  async set(envelopeId: string, checkpoint: Checkpoint): Promise<void> {\n    await this.redis.set(\n      this.key(envelopeId),\n      JSON.stringify(checkpoint),\n      'EX', this.options.ttlSeconds\n    );\n  }\n\n  async delete(envelopeId: string): Promise<void> {\n    await this.redis.del(this.key(envelopeId));\n  }\n\n  private key(envelopeId: string): string {\n    return `${this.options.prefix}${envelopeId}`;\n  }\n}\n```\n\n## Implementation Details\n\n### ResumableContext Class\n\n```typescript\nclass ResumableContext implements SubscriberContext {\n  private checkpoint: Checkpoint;\n  private dirty = false;\n\n  constructor(\n    private store: CheckpointStore,\n    private envelope: Envelope,\n    private subscriberName: string,\n    existingCheckpoint?: Checkpoint\n  ) {\n    this.checkpoint = existingCheckpoint ?? {\n      envelopeId: envelope.id,\n      subscriberName,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      completedSteps: new Map(),\n    };\n  }\n\n  get attempt(): number {\n    return this.envelope.docket.attempts;\n  }\n\n  get isRetry(): boolean {\n    return this.attempt > 1;\n  }\n\n  async io<T>(key: string, fn: () => Promise<T> | T): Promise<T> {\n    // Check cache first\n    const cached = this.checkpoint.completedSteps.get(key);\n    if (cached !== undefined) {\n      return cached.value as T;\n    }\n\n    // Execute the function\n    const startTime = Date.now();\n    const result = await fn();\n    const durationMs = Date.now() - startTime;\n\n    // Cache the result\n    this.checkpoint.completedSteps.set(key, {\n      key,\n      value: result,\n      completedAt: new Date().toISOString(),\n      durationMs,\n    });\n    this.checkpoint.updatedAt = new Date().toISOString();\n    this.dirty = true;\n\n    // Persist checkpoint immediately (fail-safe)\n    await this.store.set(this.envelope.id, this.checkpoint);\n\n    return result;\n  }\n\n  async clear(): Promise<void> {\n    await this.store.delete(this.envelope.id);\n  }\n}\n```\n\n### Pipeline Integration\n\nModify `ProcessingPipeline.executeCallback()` to create and manage the context:\n\n```typescript\n// In pipeline.ts - executeCallback method\n\nprivate async executeCallback(\n  envelope: Envelope,\n  subscriber: Subscriber,\n  receipt: MessageReceipt\n): Promise<ProcessResult> {\n  const startTime = Date.now();\n\n  try {\n    // Load existing checkpoint if this is a retry\n    const existingCheckpoint = this.checkpointStore\n      ? await this.checkpointStore.get(envelope.id)\n      : undefined;\n\n    // Create resumable context\n    const context = new ResumableContext(\n      this.checkpointStore ?? new NoOpCheckpointStore(),\n      envelope,\n      subscriber.name,\n      existingCheckpoint\n    );\n\n    // Execute with context\n    await subscriber.callback(envelope, context);\n\n    // Success - clean up checkpoint\n    await context.clear();\n\n    return {\n      success: true,\n      envelope,\n      subscriber: toSubscriberDefinition(subscriber),\n      durationMs: Date.now() - startTime,\n    };\n  } catch (error) {\n    // Checkpoint persists for retry\n    // (already saved incrementally in io() calls)\n    return {\n      success: false,\n      envelope,\n      subscriber: toSubscriberDefinition(subscriber),\n      error: error as Error,\n      durationMs: Date.now() - startTime,\n    };\n  }\n}\n```\n\n### Configuration\n\n```typescript\ninterface MatadorConfig {\n  // ... existing config ...\n\n  /**\n   * Checkpoint store for resumable subscribers.\n   * If not provided, resumable context will be available but\n   * checkpoints won't persist across retries.\n   */\n  checkpointStore?: CheckpointStore;\n}\n```\n\n## Key Design Decisions\n\n### 1. Explicit Keys vs Implicit Ordering\n\n**Decision: Explicit keys required**\n\nRationale:\n- Implicit ordering (like Temporal) requires deterministic execution paths\n- Explicit keys are clearer, safer, and work with conditional logic\n- Keys can be meaningful (debugging, observability)\n- No risk of cache misalignment if code paths change\n\n```typescript\n// Explicit key - safe with any control flow\nconst result = await io('payment', () => chargeCard(amount));\n\n// vs implicit ordering - fragile with conditionals\n// Step 0, Step 1, Step 2... what if code changes?\n```\n\n### 2. Incremental vs Batch Checkpoint Persistence\n\n**Decision: Incremental persistence (save after each io() call)**\n\nRationale:\n- Ensures no work is lost if crash happens between io() calls\n- Slightly more I/O but much safer\n- Can batch with debouncing if performance is critical\n\n### 3. Checkpoint Cleanup Strategy\n\n**Decision: Clean on success, retain on failure with TTL**\n\n- On subscriber success: Delete checkpoint immediately\n- On failure/retry: Checkpoint persists for next attempt\n- On dead-letter: Delete checkpoint (terminal state)\n- TTL on store: Cleanup orphaned checkpoints (24h default)\n\n### 4. Error Handling in io()\n\n**Decision: Errors propagate, no caching of failures**\n\n```typescript\nasync io<T>(key: string, fn: () => Promise<T> | T): Promise<T> {\n  // Check cache\n  const cached = this.checkpoint.completedSteps.get(key);\n  if (cached !== undefined) {\n    return cached.value as T;\n  }\n\n  // Execute - if this throws, it propagates up\n  // The checkpoint is NOT updated on failure\n  const result = await fn();\n\n  // Only cache on success\n  this.checkpoint.completedSteps.set(key, { ... });\n  await this.store.set(...);\n\n  return result;\n}\n```\n\n### 5. Serialization\n\n**Decision: JSON serialization with optional custom serializer**\n\n- Default: `JSON.stringify/parse` (covers most cases)\n- Custom: Allow `CheckpointStore` to accept custom serializer for complex types\n- Limitation: Functions, symbols, circular refs not supported (document this)\n\n### 6. Backward Compatibility\n\n**Decision: Context parameter is optional, existing subscribers work unchanged**\n\n```typescript\n// New signature supports both:\ntype SubscriberCallback<T> = (\n  envelope: Envelope<T>,\n  context?: SubscriberContext  // Optional for backward compat\n) => Promise<void> | void;\n\n// Old subscribers continue to work\ncallback: async (envelope) => { ... }\n\n// New subscribers can use context\ncallback: async (envelope, { io }) => { ... }\n```\n\n## Hooks Integration\n\nNew hooks for observability:\n\n```typescript\ninterface MatadorHooks {\n  // ... existing hooks ...\n\n  /**\n   * Called when a checkpoint is loaded for a retry\n   */\n  onCheckpointLoaded?(context: {\n    envelope: Envelope;\n    subscriber: SubscriberDefinition;\n    checkpoint: Checkpoint;\n    cachedSteps: number;\n  }): void | Promise<void>;\n\n  /**\n   * Called when an io() operation uses cached value\n   */\n  onCheckpointHit?(context: {\n    envelope: Envelope;\n    subscriber: SubscriberDefinition;\n    key: string;\n    cachedValue: unknown;\n  }): void | Promise<void>;\n\n  /**\n   * Called when an io() operation executes (cache miss)\n   */\n  onCheckpointMiss?(context: {\n    envelope: Envelope;\n    subscriber: SubscriberDefinition;\n    key: string;\n    durationMs: number;\n  }): void | Promise<void>;\n\n  /**\n   * Called when checkpoint is cleared (success or dead-letter)\n   */\n  onCheckpointCleared?(context: {\n    envelope: Envelope;\n    subscriber: SubscriberDefinition;\n    reason: 'success' | 'dead-letter';\n  }): void | Promise<void>;\n}\n```\n\n## File Structure\n\n```\npackages/matador/src/\n├── checkpoint/\n│   ├── index.ts                    # Public exports\n│   ├── types.ts                    # Checkpoint, CheckpointStore interfaces\n│   ├── context.ts                  # ResumableContext implementation\n│   ├── stores/\n│   │   ├── memory.ts               # MemoryCheckpointStore\n│   │   ├── envelope-metadata.ts    # EnvelopeMetadataCheckpointStore\n│   │   └── noop.ts                 # NoOpCheckpointStore (default)\n│   └── errors.ts                   # CheckpointError, etc.\n├── types/\n│   └── subscriber.ts               # Update SubscriberCallback signature\n├── pipeline/\n│   └── pipeline.ts                 # Integrate ResumableContext\n└── hooks/\n    └── types.ts                    # Add checkpoint hooks\n```\n\n## Migration Guide\n\n### For Existing Subscribers (No Changes Required)\n\nExisting subscribers continue to work. The context parameter is optional:\n\n```typescript\n// This still works\nconst mySubscriber = createSubscriber<MyEvent>({\n  name: 'my-subscriber',\n  callback: async (envelope) => {\n    // existing code unchanged\n  }\n});\n```\n\n### For New Resumable Subscribers\n\n1. Add context parameter to callback\n2. Wrap side-effectful operations in `io()`\n3. Choose meaningful, unique keys\n\n```typescript\nconst myResumableSubscriber = createSubscriber<MyEvent>({\n  name: 'my-resumable-subscriber',\n  callback: async (envelope, { io }) => {\n    const step1 = await io('step-1', () => doSomething());\n    const step2 = await io('step-2', () => doSomethingElse(step1));\n    await io('step-3', () => finalize(step2));\n  }\n});\n```\n\n### For Production Deployments\n\nConfigure a persistent checkpoint store:\n\n```typescript\nimport { RedisCheckpointStore } from 'matador/checkpoint';\nimport Redis from 'ioredis';\n\nconst matador = new Matador({\n  // ... other config ...\n  checkpointStore: new RedisCheckpointStore(new Redis(), {\n    prefix: 'myapp:checkpoint:',\n    ttlSeconds: 86400, // 24 hours\n  }),\n});\n```\n\n## Testing Strategy\n\n### Unit Tests\n\n1. **ResumableContext**\n   - `io()` caches results\n   - `io()` returns cached value on second call with same key\n   - Different keys store different values\n   - Error in `io()` propagates without caching\n   - `clear()` removes checkpoint\n\n2. **CheckpointStores**\n   - CRUD operations for each implementation\n   - TTL/cleanup behavior\n   - Concurrent access handling\n\n3. **Pipeline Integration**\n   - Context is passed to subscriber\n   - Checkpoint loaded on retry\n   - Checkpoint cleared on success\n   - Checkpoint retained on failure\n\n### Integration Tests\n\n1. **End-to-end retry with checkpoints**\n   - Subscriber fails after 2 io() calls\n   - Retry executes, first 2 io() calls return cached\n   - Third io() call executes fresh\n   - Success clears checkpoint\n\n2. **Checkpoint store reliability**\n   - Redis connection loss handling\n   - Checkpoint corruption recovery\n\n### Example Test Case\n\n```typescript\ndescribe('Resumable Subscribers', () => {\n  it('should replay cached io() results on retry', async () => {\n    const executionLog: string[] = [];\n    let shouldFail = true;\n\n    const subscriber = createSubscriber<TestEvent>({\n      name: 'test-resumable',\n      callback: async (envelope, { io }) => {\n        await io('step-1', () => {\n          executionLog.push('step-1');\n          return 'result-1';\n        });\n\n        await io('step-2', () => {\n          executionLog.push('step-2');\n          return 'result-2';\n        });\n\n        if (shouldFail) {\n          shouldFail = false;\n          throw new Error('Simulated failure');\n        }\n\n        await io('step-3', () => {\n          executionLog.push('step-3');\n          return 'result-3';\n        });\n      }\n    });\n\n    // First attempt - fails after step-2\n    await processMessage(envelope, subscriber);\n    expect(executionLog).toEqual(['step-1', 'step-2']);\n\n    // Retry - step-1 and step-2 use cache, step-3 executes\n    executionLog.length = 0;\n    await processMessage(envelope, subscriber);\n    expect(executionLog).toEqual(['step-3']); // Only step-3 executed!\n  });\n});\n```\n\n## Future Enhancements\n\n### 1. Conditional io() with dependencies\n\n```typescript\n// Only execute if condition met, still cache result\nawait io.if('send-sms', userPrefersSms, () => sendSms(phone));\n```\n\n### 2. Parallel io() execution\n\n```typescript\n// Execute multiple io() calls in parallel\nconst [a, b, c] = await io.all([\n  ['fetch-user', () => fetchUser(id)],\n  ['fetch-prefs', () => fetchPrefs(id)],\n  ['fetch-history', () => fetchHistory(id)],\n]);\n```\n\n### 3. io() timeouts\n\n```typescript\n// Timeout individual operations\nawait io('slow-api', () => callSlowApi(), { timeout: 5000 });\n```\n\n### 4. Checkpoint inspection API\n\n```typescript\n// For debugging/admin tools\nconst checkpoint = await matador.getCheckpoint(envelopeId);\nconsole.log(checkpoint.completedSteps);\n```\n\n## Implementation Order\n\n1. **Phase 1: Core Types and Interfaces**\n   - [ ] Define `Checkpoint`, `CheckpointEntry`, `CheckpointStore` types\n   - [ ] Define `SubscriberContext` interface\n   - [ ] Update `SubscriberCallback` type signature\n\n2. **Phase 2: Checkpoint Stores**\n   - [ ] Implement `NoOpCheckpointStore` (default)\n   - [ ] Implement `MemoryCheckpointStore`\n   - [ ] Write unit tests for stores\n\n3. **Phase 3: ResumableContext**\n   - [ ] Implement `ResumableContext` class\n   - [ ] Implement `io()` method with caching logic\n   - [ ] Write unit tests for context\n\n4. **Phase 4: Pipeline Integration**\n   - [ ] Add `checkpointStore` to `MatadorConfig`\n   - [ ] Modify `ProcessingPipeline` to create/manage context\n   - [ ] Pass context to subscriber callbacks\n   - [ ] Clear checkpoint on success/dead-letter\n\n5. **Phase 5: Hooks**\n   - [ ] Add checkpoint-related hooks to `MatadorHooks`\n   - [ ] Integrate hooks into context operations\n\n6. **Phase 6: Integration Tests**\n   - [ ] End-to-end retry with checkpoints\n   - [ ] Multiple subscribers with checkpoints\n   - [ ] Dead-letter checkpoint cleanup\n\n7. **Phase 7: Redis Store (Optional)**\n   - [ ] Implement `RedisCheckpointStore`\n   - [ ] Write integration tests with Redis\n\n8. **Phase 8: Documentation**\n   - [ ] API documentation\n   - [ ] Migration guide\n   - [ ] Examples\n",
            "file_path": "/home/z/Desktop/work/matador/docs/plans/resumable-subscribers.md"
          },
          "timestamp": "2025-12-11T13:18:31.222Z"
        }
      ],
      "total_additions": 1413,
      "total_deletions": 299,
      "accepted_lines": 1114,
      "overriden_lines": 0
    },
    "63f631659cb42c1c": {
      "agent_id": {
        "tool": "claude",
        "id": "edf8c878-3891-411b-b34a-d23700c6e9c9",
        "model": "claude-opus-4-5-20251101"
      },
      "human_author": "Zachary Davison <zachary.davison@meetsmore.com>",
      "messages": [
        {
          "type": "user",
          "text": "start  implementing docs/plans/resumable-subscribers.md",
          "timestamp": "2025-12-11T14:25:51.651Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/docs/plans/resumable-subscribers.md"
          },
          "timestamp": "2025-12-11T14:25:54.875Z"
        },
        {
          "type": "user",
          "text": "     1→# Resumable Subscribers Implementation Plan\n     2→\n     3→## Problem Statement\n     4→\n     5→When a subscriber fails partway through execution (e.g., after calling an external API but before completing), retrying the message re-executes all operations from the beginning. This can cause:\n     6→\n     7→- Duplicate side effects (double charges, duplicate emails, etc.)\n     8→- Wasted compute on operations that already succeeded\n     9→- Complex manual idempotency handling in every subscriber\n    10→\n    11→## Proposed Solution\n    12→\n    13→Provide subscribers with an `io` function that:\n    14→1. Wraps side-effectful operations in a cacheable lambda\n    15→2. Caches successful results keyed by an explicit developer-provided key\n    16→3. On retry, returns cached values instead of re-executing\n    17→\n    18→This pattern is inspired by workflow engines like Temporal/Cadence, adapted for Matador's event-driven model.\n    19→\n    20→## API Design\n    21→\n    22→### Idempotency Integration\n    23→\n    24→A resumable subscriber is inherently idempotent because the `io()` caching mechanism prevents duplicate side effects on retry. We extend the existing `Idempotency` type:\n    25→\n    26→```typescript\n    27→// Current\n    28→type Idempotency = 'yes' | 'no' | 'unknown';\n    29→\n    30→// Proposed\n    31→type Idempotency = 'yes' | 'no' | 'unknown' | 'resumable';\n    32→```\n    33→\n    34→**Semantics:**\n    35→\n    36→| Value       | Meaning                                                                 | Retry Behavior                          |\n    37→|-------------|-------------------------------------------------------------------------|----------------------------------------|\n    38→| `'yes'`     | Subscriber is manually idempotent (safe to retry)                       | Retries allowed                        |\n    39→| `'no'`      | Subscriber is NOT idempotent (unsafe to retry)                          | Dead-letter on redelivery              |\n    40→| `'unknown'` | Idempotency not determined                                              | Retries allowed (default)              |\n    41→| `'resumable'` | Subscriber uses `io()` for checkpointed idempotency                   | Retries allowed, checkpoint loaded     |\n    42→\n    43→**Why `'resumable'` is distinct from `'yes'`:**\n    44→\n    45→- `'yes'` means the subscriber code is inherently idempotent (e.g., upserts, idempotency keys)\n    46→- `'resumable'` means idempotency is achieved through the checkpoint system\n    47→- This distinction enables:\n    48→  - Validation: Matador can warn if `idempotent: 'resumable'` but no `checkpointStore` configured\n    49→  - Observability: Differentiate between native idempotency and checkpoint-based idempotency in metrics\n    50→  - Future optimization: Skip checkpoint loading for `'yes'` subscribers\n    51→\n    52→### Compile-Time Enforcement via Discriminated Union\n    53→\n    54→We use a discriminated union on the subscriber options to enforce at compile time that:\n    55→- `idempotent: 'resumable'` **requires** a callback with `SubscriberContext`\n    56→- Other idempotency values **cannot** have a callback with `SubscriberContext`\n    57→\n    58→```typescript\n    59→/**\n    60→ * Context provided to resumable subscriber callbacks.\n    61→ */\n    62→interface SubscriberContext {\n    63→  /**\n    64→   * Wraps a side-effectful operation for caching/replay.\n    65→   * On first execution: runs the lambda and caches the result.\n    66→   * On retry: returns cached result without re-executing.\n    67→   *\n    68→   * @param key - Unique identifier for this operation within this subscriber.\n    69→   *              Must be stable across retries. Use descriptive names like\n    70→   *              'fetch-user', 'send-email', 'charge-payment'.\n    71→   * @param fn - The side-effectful operation to execute\n    72→   * @returns The result of fn (or cached result on retry)\n    73→   */\n    74→  io<T extends JsonSerializable>(key: string, fn: () => Promise<T> | T): Promise<T>;\n    75→\n    76→  /**\n    77→   * Execute multiple io() operations in parallel.\n    78→   * Each operation requires its own unique key.\n    79→   *\n    80→   * @param ops - Array of [key, fn] tuples to execute in parallel\n    81→   * @returns Array of results in the same order as input\n    82→   */\n    83→  all<T extends readonly [string, () => Promise<JsonSerializable> | JsonSerializable][]>(\n    84→    ops: T\n    85→  ): Promise<{ [K in keyof T]: T[K] extends [string, () => Promise<infer R> | infer R] ? R : never }>;\n    86→\n    87→  /** Current attempt number (1-based) */\n    88→  attempt: number;\n    89→\n    90→  /** Whether this is a retry (attempt > 1) */\n    91→  isRetry: boolean;\n    92→}\n    93→\n    94→/**\n    95→ * Type constraint ensuring values can be JSON serialized.\n    96→ */\n    97→type JsonSerializable =\n    98→  | string\n    99→  | number\n   100→  | boolean\n   101→  | null\n   102→  | JsonSerializable[]\n   103→  | { [key: string]: JsonSerializable };\n   104→\n   105→/**\n   106→ * Callback for standard (non-resumable) subscribers.\n   107→ */\n   108→type StandardCallback<T> = (envelope: Envelope<T>) => Promise<void> | void;\n   109→\n   110→/**\n   111→ * Callback for resumable subscribers - receives SubscriberContext with io().\n   112→ */\n   113→type ResumableCallback<T> = (\n   114→  envelope: Envelope<T>,\n   115→  context: SubscriberContext\n   116→) => Promise<void> | void;\n   117→\n   118→/**\n   119→ * Discriminated union ensuring idempotent: 'resumable' pairs with ResumableCallback.\n   120→ */\n   121→type SubscriberOptions<T extends MatadorEvent> =\n   122→  | {\n   123→      readonly name: string;\n   124→      readonly idempotent?: 'yes' | 'no' | 'unknown';  // Optional, defaults to 'unknown'\n   125→      readonly callback: StandardCallback<T['data']>;\n   126→      readonly importance?: Importance;\n   127→      readonly targetQueue?: string;\n   128→      readonly enabled?: () => boolean | Promise<boolean>;\n   129→    }\n   130→  | {\n   131→      readonly name: string;\n   132→      readonly idempotent: 'resumable';  // Required, must be 'resumable'\n   133→      readonly callback: ResumableCallback<T['data']>;\n   134→      readonly importance?: Importance;\n   135→      readonly targetQueue?: string;\n   136→      readonly enabled?: () => boolean | Promise<boolean>;\n   137→    };\n   138→\n   139→/**\n   140→ * Single createSubscriber function handles both cases.\n   141→ */\n   142→function createSubscriber<T extends MatadorEvent>(\n   143→  options: SubscriberOptions<T>\n   144→): Subscriber<T>;\n   145→```\n   146→\n   147→### Compile-Time Examples\n   148→\n   149→```typescript\n   150→// ✅ GOOD: Standard subscriber without context\n   151→createSubscriber<MyEvent>({\n   152→  name: 'standard',\n   153→  idempotent: 'yes',\n   154→  callback: async (envelope) => {\n   155→    // No io() available - correct!\n   156→  }\n   157→});\n   158→\n   159→// ✅ GOOD: Resumable subscriber with context\n   160→createSubscriber<MyEvent>({\n   161→  name: 'resumable',\n   162→  idempotent: 'resumable',\n   163→  callback: async (envelope, { io }) => {\n   164→    await io('do-something', () => doSomething());\n   165→  }\n   166→});\n   167→\n   168→// ❌ COMPILE ERROR: 'resumable' requires context parameter\n   169→createSubscriber<MyEvent>({\n   170→  name: 'broken',\n   171→  idempotent: 'resumable',\n   172→  callback: async (envelope) => {  // Error: missing context parameter\n   173→    // ...\n   174→  }\n   175→});\n   176→\n   177→// ❌ COMPILE ERROR: Non-resumable cannot have context parameter\n   178→createSubscriber<MyEvent>({\n   179→  name: 'broken',\n   180→  idempotent: 'yes',\n   181→  callback: async (envelope, { io }) => {  // Error: unexpected context parameter\n   182→    // ...\n   183→  }\n   184→});\n   185→\n   186→// ❌ COMPILE ERROR: Cannot use io() without 'resumable'\n   187→createSubscriber<MyEvent>({\n   188→  name: 'broken',\n   189→  // idempotent defaults to 'unknown'\n   190→  callback: async (envelope, context) => {  // Error: context not available\n   191→    await context.io('key', () => doSomething());\n   192→  }\n   193→});\n   194→```\n   195→\n   196→This ensures that **you cannot use `io()` without `idempotent: 'resumable'`** - the type system enforces it.\n   197→\n   198→### Usage Example\n   199→\n   200→```typescript\n   201→const sendWelcomeEmail = createSubscriber<UserCreatedEvent>({\n   202→  name: 'send-welcome-email',\n   203→  idempotent: 'resumable',  // Idempotency via checkpoint system\n   204→\n   205→  async callback(envelope, { io, all }) {\n   206→    const { userId, email } = envelope.data;\n   207→\n   208→    // Fetch user preferences (cached on retry)\n   209→    const prefs = await io('fetch-prefs', async () => {\n   210→      return await userService.getPreferences(userId);\n   211→    });\n   212→\n   213→    // Generate email content (cached on retry)\n   214→    const emailContent = await io('generate-email', async () => {\n   215→      return await templateService.render('welcome', { prefs });\n   216→    });\n   217→\n   218→    // Send email (cached on retry)\n   219→    const sendResult = await io('send-email', async () => {\n   220→      return await emailService.send(email, emailContent);\n   221→    });\n   222→\n   223→    // Record analytics (cached on retry)\n   224→    await io('record-analytics', async () => {\n   225→      await analytics.track('welcome_email_sent', { userId, messageId: sendResult.id });\n   226→    });\n   227→  }\n   228→});\n   229→```\n   230→\n   231→### Parallel Execution Example\n   232→\n   233→```typescript\n   234→const enrichUserData = createSubscriber<UserCreatedEvent>({\n   235→  name: 'enrich-user-data',\n   236→  idempotent: 'resumable',\n   237→\n   238→  async callback(envelope, { io, all }) {\n   239→    const { userId } = envelope.data;\n   240→\n   241→    // Fetch multiple data sources in parallel (each with unique key)\n   242→    const [profile, preferences, history] = await all([\n   243→      ['fetch-profile', async () => await profileService.get(userId)],\n   244→      ['fetch-prefs', async () => await prefsService.get(userId)],\n   245→      ['fetch-history', async () => await historyService.get(userId)],\n   246→    ]);\n   247→\n   248→    // Use enriched data\n   249→    await io('process-enrichment', async () => {\n   250→      await enrichmentService.process({ profile, preferences, history });\n   251→    });\n   252→  }\n   253→});\n   254→```\n   255→\n   256→If the subscriber crashes after 'generate-email' but before 'send-email':\n   257→- On retry, 'fetch-prefs' and 'generate-email' return cached values instantly\n   258→- 'send-email' executes fresh (no cache entry exists)\n   259→\n   260→## Explicit Keys\n   261→\n   262→Each `io()` call requires an explicit key that uniquely identifies the operation within the subscriber. This design choice provides important safety guarantees.\n   263→\n   264→### Why Explicit Keys?\n   265→\n   266→Explicit keys make resumable subscribers **resilient to code changes**:\n   267→\n   268→```typescript\n   269→// Version 1 (first attempt):\n   270→await io('fetch-user', () => fetchUser());\n   271→await io('send-email', () => sendEmail());\n   272→// crash here\n   273→\n   274→// Version 2 deployed (new io inserted), retry:\n   275→await io('fetch-user', () => fetchUser());     // cache HIT ✓\n   276→await io('log-audit', () => logAudit());       // cache MISS, executes (new key)\n   277→await io('send-email', () => sendEmail());     // cache HIT ✓ (same key!)\n   278→```\n   279→\n   280→With auto-generated keys (call order), inserting a new `io()` would shift all subsequent keys and cause cache misalignment. Explicit keys avoid this entirely.\n   281→\n   282→### Key Requirements\n   283→\n   284→1. **Unique within subscriber** - No two `io()` calls can have the same key\n   285→2. **Stable across retries** - The key for an operation must not change\n   286→3. **Descriptive** - Use meaningful names for debugging: `'fetch-user'`, `'send-email'`, `'charge-payment'`\n   287→\n   288→### Runtime Validation\n   289→\n   290→Duplicate keys are detected at runtime and throw an error:\n   291→\n   292→```typescript\n   293→await io('fetch-user', () => fetchUser());\n   294→await io('fetch-user', () => fetchPrefs());  // Error: Duplicate io key 'fetch-user'\n   295→```\n   296→\n   297→### Flexibility with Explicit Keys\n   298→\n   299→Explicit keys allow patterns that auto-generated keys cannot support:\n   300→\n   301→```typescript\n   302→// ✅ Conditional io() calls - safe!\n   303→if (envelope.data.sendEmail) {\n   304→  await io('send-email', () => sendEmail());\n   305→}\n   306→\n   307→// ✅ Dynamic loops - safe with unique keys!\n   308→for (const item of envelope.data.items) {\n   309→  await io(`process-item-${item.id}`, () => processItem(item));\n   310→}\n   311→\n   312→// ✅ Reordering code - safe!\n   313→// Moving io() calls around doesn't break existing checkpoints\n   314→```\n   315→\n   316→## Architecture\n   317→\n   318→### Components\n   319→\n   320→```\n   321→┌─────────────────────────────────────────────────────────────────┐\n   322→│                         Matador Core                            │\n   323→├─────────────────────────────────────────────────────────────────┤\n   324→│                                                                 │\n   325→│  ┌─────────────────┐      ┌──────────────────────────────────┐  │\n   326→│  │ ProcessingPipeline│ ──→ │ ResumableContext                 │  │\n   327→│  │                 │      │                                  │  │\n   328→│  │ - process()     │      │ - io(key, fn): Promise<T>        │  │\n   329→│  │ - executeCallback│      │ - all(ops): Promise<T[]>         │  │\n   330→│  │                 │      │ - loadCheckpoint()               │  │\n   331→│  └─────────────────┘      │ - saveCheckpoint()               │  │\n   332→│           │               │ - clearCheckpoint()              │  │\n   333→│           │               └──────────────┬───────────────────┘  │\n   334→│           │                              │                      │\n   335→│           │                              ▼                      │\n   336→│           │               ┌──────────────────────────────────┐  │\n   337→│           │               │ CheckpointStore (Interface)      │  │\n   338→│           │               │                                  │  │\n   339→│           │               │ - get(envelopeId): Checkpoint    │  │\n   340→│           │               │ - set(envelopeId, checkpoint)    │  │\n   341→│           │               │ - delete(envelopeId)             │  │\n   342→│           │               └──────────────────────────────────┘  │\n   343→│           │                              │                      │\n   344→│           │               ┌──────────────┴──────────────┐       │\n   345→│           │               ▼                             ▼       │\n   346→│           │         ┌──────────┐                 ┌───────────┐  │\n   347→│           │         │ Memory   │                 │ Redis     │  │\n   348→│           │         │ Store    │                 │ Store     │  │\n   349→│           │         └──────────┘                 └───────────┘  │\n   350→│           │                                                     │\n   351→│           ▼                                                     │\n   352→│  ┌─────────────────────────────────────────────────────────────┐│\n   353→│  │ Subscriber Callback                                         ││\n   354→│  │                                                             ││\n   355→│  │  callback(envelope, { io, all, attempt, isRetry })          ││\n   356→│  │                                                             ││\n   357→│  └─────────────────────────────────────────────────────────────┘│\n   358→└─────────────────────────────────────────────────────────────────┘\n   359→```\n   360→\n   361→### Checkpoint Data Structure\n   362→\n   363→```typescript\n   364→interface Checkpoint {\n   365→  envelopeId: string;\n   366→  subscriberName: string;\n   367→  completedSteps: Record<string, JsonSerializable>;  // key -> cached value\n   368→}\n   369→```\n   370→\n   371→The structure is intentionally minimal:\n   372→- `envelopeId` - identifies which message this checkpoint belongs to\n   373→- `subscriberName` - identifies which subscriber (for debugging/admin)\n   374→- `completedSteps` - map of step keys to their cached results\n   375→\n   376→### CheckpointStore Interface\n   377→\n   378→```typescript\n   379→interface CheckpointStore {\n   380→  /**\n   381→   * Retrieve checkpoint for an envelope\n   382→   */\n   383→  get(envelopeId: string): Promise<Checkpoint | undefined>;\n   384→\n   385→  /**\n   386→   * Save/update checkpoint\n   387→   */\n   388→  set(envelopeId: string, checkpoint: Checkpoint): Promise<void>;\n   389→\n   390→  /**\n   391→   * Delete checkpoint (on success or dead-letter)\n   392→   */\n   393→  delete(envelopeId: string): Promise<void>;\n   394→\n   395→  /**\n   396→   * Optional: TTL-based cleanup for orphaned checkpoints\n   397→   */\n   398→  cleanup?(olderThan: Date): Promise<number>;\n   399→}\n   400→```\n   401→\n   402→### Implementations\n   403→\n   404→#### 1. MemoryCheckpointStore (Default, for testing)\n   405→\n   406→```typescript\n   407→class MemoryCheckpointStore implements CheckpointStore {\n   408→  private checkpoints = new Map<string, Checkpoint>();\n   409→\n   410→  async get(envelopeId: string): Promise<Checkpoint | undefined> {\n   411→    return this.checkpoints.get(envelopeId);\n   412→  }\n   413→\n   414→  async set(envelopeId: string, checkpoint: Checkpoint): Promise<void> {\n   415→    this.checkpoints.set(envelopeId, checkpoint);\n   416→  }\n   417→\n   418→  async delete(envelopeId: string): Promise<void> {\n   419→    this.checkpoints.delete(envelopeId);\n   420→  }\n   421→}\n   422→```\n   423→\n   424→#### 2. RedisCheckpointStore (Production)\n   425→\n   426→```typescript\n   427→class RedisCheckpointStore implements CheckpointStore {\n   428→  constructor(private redis: Redis, private options: {\n   429→    prefix?: string;        // Key prefix, default: 'matador:checkpoint:'\n   430→    ttlSeconds?: number;    // TTL for cleanup, default: 86400 (24h)\n   431→  }) {}\n   432→\n   433→  async get(envelopeId: string): Promise<Checkpoint | undefined> {\n   434→    const data = await this.redis.get(this.key(envelopeId));\n   435→    return data ? JSON.parse(data) : undefined;\n   436→  }\n   437→\n   438→  async set(envelopeId: string, checkpoint: Checkpoint): Promise<void> {\n   439→    await this.redis.set(\n   440→      this.key(envelopeId),\n   441→      JSON.stringify(checkpoint),\n   442→      'EX', this.options.ttlSeconds\n   443→    );\n   444→  }\n   445→\n   446→  async delete(envelopeId: string): Promise<void> {\n   447→    await this.redis.del(this.key(envelopeId));\n   448→  }\n   449→\n   450→  private key(envelopeId: string): string {\n   451→    return `${this.options.prefix}${envelopeId}`;\n   452→  }\n   453→}\n   454→```\n   455→\n   456→## Implementation Details\n   457→\n   458→### ResumableContext Class\n   459→\n   460→```typescript\n   461→class ResumableContext implements SubscriberContext {\n   462→  private checkpoint: Checkpoint;\n   463→  private usedKeys = new Set<string>();\n   464→\n   465→  constructor(\n   466→    private store: CheckpointStore,\n   467→    private envelope: Envelope,\n   468→    private subscriberName: string,\n   469→    existingCheckpoint?: Checkpoint\n   470→  ) {\n   471→    this.checkpoint = existingCheckpoint ?? {\n   472→      envelopeId: envelope.id,\n   473→      subscriberName,\n   474→      completedSteps: {},\n   475→    };\n   476→  }\n   477→\n   478→  get attempt(): number {\n   479→    return this.envelope.docket.attempts;\n   480→  }\n   481→\n   482→  get isRetry(): boolean {\n   483→    return this.attempt > 1;\n   484→  }\n   485→\n   486→  async io<T extends JsonSerializable>(key: string, fn: () => Promise<T> | T): Promise<T> {\n   487→    // Validate key uniqueness within this execution\n   488→    if (this.usedKeys.has(key)) {\n   489→      throw new DuplicateIoKeyError(key, this.subscriberName);\n   490→    }\n   491→    this.usedKeys.add(key);\n   492→\n   493→    // Check cache first\n   494→    if (key in this.checkpoint.completedSteps) {\n   495→      return this.checkpoint.completedSteps[key] as T;\n   496→    }\n   497→\n   498→    // Execute the function - errors propagate, no caching on failure\n   499→    const result = await fn();\n   500→\n   501→    // Cache the result\n   502→    this.checkpoint.completedSteps[key] = result;\n   503→\n   504→    // Persist checkpoint immediately (incremental persistence)\n   505→    await this.store.set(this.envelope.id, this.checkpoint);\n   506→\n   507→    return result;\n   508→  }\n   509→\n   510→  async all<T extends readonly [string, () => Promise<JsonSerializable> | JsonSerializable][]>(\n   511→    ops: T\n   512→  ): Promise<{ [K in keyof T]: T[K] extends [string, () => Promise<infer R> | infer R] ? R : never }> {\n   513→    // Validate all keys are unique\n   514→    for (const [key] of ops) {\n   515→      if (this.usedKeys.has(key)) {\n   516→        throw new DuplicateIoKeyError(key, this.subscriberName);\n   517→      }\n   518→      this.usedKeys.add(key);\n   519→    }\n   520→\n   521→    const results = await Promise.all(\n   522→      ops.map(async ([key, fn]) => {\n   523→        // Check cache first\n   524→        if (key in this.checkpoint.completedSteps) {\n   525→          return this.checkpoint.completedSteps[key];\n   526→        }\n   527→\n   528→        // Execute - errors propagate\n   529→        const result = await fn();\n   530→\n   531→        // Cache individually\n   532→        this.checkpoint.completedSteps[key] = result;\n   533→\n   534→        return result;\n   535→      })\n   536→    );\n   537→\n   538→    // Persist after all parallel operations complete\n   539→    await this.store.set(this.envelope.id, this.checkpoint);\n   540→\n   541→    return results as { [K in keyof T]: T[K] extends [string, () => Promise<infer R> | infer R] ? R : never };\n   542→  }\n   543→\n   544→  async clear(): Promise<void> {\n   545→    await this.store.delete(this.envelope.id);\n   546→  }\n   547→}\n   548→```\n   549→\n   550→### Pipeline Integration\n   551→\n   552→Modify `ProcessingPipeline.executeCallback()` to create and manage the context:\n   553→\n   554→```typescript\n   555→// In pipeline.ts - executeCallback method\n   556→\n   557→private async executeCallback(\n   558→  envelope: Envelope,\n   559→  subscriber: Subscriber,\n   560→  receipt: MessageReceipt\n   561→): Promise<ProcessResult> {\n   562→  const startTime = Date.now();\n   563→\n   564→  try {\n   565→    // Load existing checkpoint if available\n   566→    const existingCheckpoint = this.checkpointStore\n   567→      ? await this.checkpointStore.get(envelope.id)\n   568→      : undefined;\n   569→\n   570→    // Create resumable context\n   571→    const context = new ResumableContext(\n   572→      this.checkpointStore ?? new NoOpCheckpointStore(),\n   573→      envelope,\n   574→      subscriber.name,\n   575→      existingCheckpoint\n   576→    );\n   577→\n   578→    // Execute with context\n   579→    await subscriber.callback(envelope, context);\n   580→\n   581→    // Success - clean up checkpoint\n   582→    await context.clear();\n   583→\n   584→    return {\n   585→      success: true,\n   586→      envelope,\n   587→      subscriber: toSubscriberDefinition(subscriber),\n   588→      durationMs: Date.now() - startTime,\n   589→    };\n   590→  } catch (error) {\n   591→    // Checkpoint persists for retry\n   592→    // (already saved incrementally in io() calls)\n   593→    return {\n   594→      success: false,\n   595→      envelope,\n   596→      subscriber: toSubscriberDefinition(subscriber),\n   597→      error: error as Error,\n   598→      durationMs: Date.now() - startTime,\n   599→    };\n   600→  }\n   601→}\n   602→```\n   603→\n   604→### Configuration\n   605→\n   606→```typescript\n   607→interface MatadorConfig {\n   608→  // ... existing config ...\n   609→\n   610→  /**\n   611→   * Checkpoint store for resumable subscribers.\n   612→   * If not provided, resumable context will be available but\n   613→   * checkpoints won't persist across retries.\n   614→   */\n   615→  checkpointStore?: CheckpointStore;\n   616→}\n   617→```\n   618→\n   619→### Retry Policy Integration\n   620→\n   621→The `StandardRetryPolicy` is updated to handle `'resumable'` idempotency:\n   622→\n   623→```typescript\n   624→// In standard-policy.ts - shouldRetry method\n   625→\n   626→// 6. Non-idempotent subscriber on redelivery\n   627→// 'resumable' is treated as idempotent (like 'yes') for retry purposes\n   628→if (receipt.redelivered && subscriber.idempotent === 'no') {\n   629→  const idempotentError = new IdempotentMessageCannotRetryError(\n   630→    envelope.id,\n   631→    subscriber.name,\n   632→  );\n   633→  return {\n   634→    action: 'dead-letter',\n   635→    queue: 'undeliverable',\n   636→    reason: idempotentError.message,\n   637→  };\n   638→}\n   639→\n   640→// 7. Default: retry with backoff\n   641→// For 'resumable' subscribers, checkpoint will be loaded on retry\n   642→return {\n   643→  action: 'retry',\n   644→  delay: this.getDelay(context),\n   645→};\n   646→```\n   647→\n   648→**Key behavior:**\n   649→- `idempotent: 'resumable'` is treated the same as `'yes'` for retry decisions\n   650→- The difference is in the pipeline: `'resumable'` triggers checkpoint loading\n   651→- This means `'resumable'` subscribers are always safe to retry\n   652→\n   653→### Schema Validation\n   654→\n   655→The schema registry validates `'resumable'` subscribers:\n   656→\n   657→```typescript\n   658→// In registry.ts - validate method\n   659→\n   660→function validateResumableSubscribers(\n   661→  schema: SchemaRegistry,\n   662→  checkpointStore: CheckpointStore | undefined\n   663→): ValidationError[] {\n   664→  const errors: ValidationError[] = [];\n   665→\n   666→  for (const [eventKey, subscribers] of schema.entries()) {\n   667→    for (const subscriber of subscribers) {\n   668→      if (subscriber.idempotent === 'resumable' && !checkpointStore) {\n   669→        errors.push({\n   670→          path: `${eventKey}.${subscriber.name}`,\n   671→          message: `Subscriber \"${subscriber.name}\" is marked as 'resumable' but no checkpointStore is configured. ` +\n   672→                   `Checkpoints will not persist across retries.`,\n   673→        });\n   674→      }\n   675→    }\n   676→  }\n   677→\n   678→  return errors;\n   679→}\n   680→```\n   681→\n   682→This validation produces a **warning** (not an error) allowing development/testing without Redis.\n   683→\n   684→## Key Design Decisions\n   685→\n   686→### 1. Explicit Keys\n   687→\n   688→**Decision: Developer-provided keys for each `io()` call**\n   689→\n   690→Rationale:\n   691→- **Resilient to code changes** - Inserting, removing, or reordering `io()` calls doesn't break existing checkpoints\n   692→- **Meaningful debugging** - Keys like `'fetch-user'` are more informative than `'step-0'`\n   693→- **Flexible patterns** - Supports conditional `io()`, dynamic loops, and code refactoring\n   694→- **No versioning needed** - No need for subscriber version fields or code hashing\n   695→\n   696→Trade-off:\n   697→- Developer must provide unique keys (small cognitive overhead)\n   698→- Runtime validation needed to detect duplicate keys\n   699→\n   700→### 2. Incremental Checkpoint Persistence\n   701→\n   702→**Decision: Save checkpoint after each `io()` call**\n   703→\n   704→Rationale:\n   705→- Ensures no work is lost if crash happens between `io()` calls\n   706→- Slightly more I/O but much safer\n   707→- For `all()`, save once after all parallel operations complete\n   708→\n   709→### 3. Checkpoint Cleanup Strategy\n   710→\n   711→**Decision: Clean on success, retain on failure with TTL**\n   712→\n   713→- On subscriber success: Delete checkpoint immediately\n   714→- On failure/retry: Checkpoint persists for next attempt\n   715→- On dead-letter: Delete checkpoint (terminal state)\n   716→- TTL on store: Cleanup orphaned checkpoints (24h default)\n   717→\n   718→### 4. Error Handling in io()\n   719→\n   720→**Decision: Errors propagate, no caching of failures**\n   721→\n   722→```typescript\n   723→async io<T extends JsonSerializable>(key: string, fn: () => Promise<T> | T): Promise<T> {\n   724→  // Check cache\n   725→  if (key in this.checkpoint.completedSteps) {\n   726→    return this.checkpoint.completedSteps[key] as T;\n   727→  }\n   728→\n   729→  // Execute - if this throws, it propagates up\n   730→  // The checkpoint is NOT updated on failure\n   731→  const result = await fn();\n   732→\n   733→  // Only cache on success\n   734→  this.checkpoint.completedSteps[key] = result;\n   735→  await this.store.set(...);\n   736→\n   737→  return result;\n   738→}\n   739→```\n   740→\n   741→### 5. Type-Safe Serialization\n   742→\n   743→**Decision: Enforce JSON-serializable types at compile time**\n   744→\n   745→```typescript\n   746→type JsonSerializable =\n   747→  | string\n   748→  | number\n   749→  | boolean\n   750→  | null\n   751→  | JsonSerializable[]\n   752→  | { [key: string]: JsonSerializable };\n   753→\n   754→// This will fail type checking:\n   755→await io('key', () => new Date());           // Error: Date is not JsonSerializable\n   756→await io('key', () => () => {});             // Error: Function is not JsonSerializable\n   757→await io('key', () => new Map());            // Error: Map is not JsonSerializable\n   758→\n   759→// This is fine:\n   760→await io('key', () => ({ createdAt: new Date().toISOString() }));  // OK\n   761→await io('key', () => [1, 2, 3]);                                   // OK\n   762→await io('key', () => null);                                        // OK\n   763→```\n   764→\n   765→### 6. Backward Compatibility\n   766→\n   767→**Decision: Context parameter is optional, existing subscribers work unchanged**\n   768→\n   769→```typescript\n   770→// New signature supports both:\n   771→type SubscriberCallback<T> = (\n   772→  envelope: Envelope<T>,\n   773→  context?: SubscriberContext  // Optional for backward compat\n   774→) => Promise<void> | void;\n   775→\n   776→// Old subscribers continue to work\n   777→callback: async (envelope) => { ... }\n   778→\n   779→// New subscribers can use context\n   780→callback: async (envelope, { io }) => { ... }\n   781→```\n   782→\n   783→## Hooks Integration\n   784→\n   785→New hooks for observability:\n   786→\n   787→```typescript\n   788→interface MatadorHooks {\n   789→  // ... existing hooks ...\n   790→\n   791→  /**\n   792→   * Called when a checkpoint is loaded for a retry\n   793→   */\n   794→  onCheckpointLoaded?(context: {\n   795→    envelope: Envelope;\n   796→    subscriber: SubscriberDefinition;\n   797→    checkpoint: Checkpoint;\n   798→    cachedSteps: number;\n   799→  }): void | Promise<void>;\n   800→\n   801→  /**\n   802→   * Called when an io() operation uses cached value\n   803→   */\n   804→  onCheckpointHit?(context: {\n   805→    envelope: Envelope;\n   806→    subscriber: SubscriberDefinition;\n   807→    stepKey: string;\n   808→  }): void | Promise<void>;\n   809→\n   810→  /**\n   811→   * Called when an io() operation executes (cache miss)\n   812→   */\n   813→  onCheckpointMiss?(context: {\n   814→    envelope: Envelope;\n   815→    subscriber: SubscriberDefinition;\n   816→    stepKey: string;\n   817→  }): void | Promise<void>;\n   818→\n   819→  /**\n   820→   * Called when checkpoint is cleared (success or dead-letter)\n   821→   */\n   822→  onCheckpointCleared?(context: {\n   823→    envelope: Envelope;\n   824→    subscriber: SubscriberDefinition;\n   825→    reason: 'success' | 'dead-letter';\n   826→  }): void | Promise<void>;\n   827→}\n   828→```\n   829→\n   830→## File Structure\n   831→\n   832→```\n   833→packages/matador/src/\n   834→├── checkpoint/\n   835→│   ├── index.ts                    # Public exports\n   836→│   ├── types.ts                    # Checkpoint, CheckpointStore, JsonSerializable\n   837→│   ├── context.ts                  # ResumableContext implementation\n   838→│   ├── stores/\n   839→│   │   ├── memory.ts               # MemoryCheckpointStore\n   840→│   │   └── noop.ts                 # NoOpCheckpointStore (default)\n   841→│   └── errors.ts                   # CheckpointError, etc.\n   842→├── types/\n   843→│   ├── common.ts                   # Add 'resumable' to Idempotency type\n   844→│   └── subscriber.ts               # Update SubscriberCallback signature\n   845→├── pipeline/\n   846→│   └── pipeline.ts                 # Integrate ResumableContext\n   847→├── schema/\n   848→│   └── registry.ts                 # Add resumable validation warning\n   849→└── hooks/\n   850→    └── types.ts                    # Add checkpoint hooks\n   851→```\n   852→\n   853→## Migration Guide\n   854→\n   855→### For Existing Subscribers (No Changes Required)\n   856→\n   857→Existing subscribers continue to work. The context parameter is optional:\n   858→\n   859→```typescript\n   860→// This still works\n   861→const mySubscriber = createSubscriber<MyEvent>({\n   862→  name: 'my-subscriber',\n   863→  callback: async (envelope) => {\n   864→    // existing code unchanged\n   865→  }\n   866→});\n   867→```\n   868→\n   869→### For New Resumable Subscribers\n   870→\n   871→1. Set `idempotent: 'resumable'` on the subscriber\n   872→2. Add context parameter to callback\n   873→3. Wrap side-effectful operations in `io()` with unique keys\n   874→4. Use descriptive keys that identify the operation\n   875→\n   876→```typescript\n   877→const myResumableSubscriber = createSubscriber<MyEvent>({\n   878→  name: 'my-resumable-subscriber',\n   879→  idempotent: 'resumable',  // Required for checkpoint-based idempotency\n   880→  callback: async (envelope, { io, all }) => {\n   881→    // Sequential operations with explicit keys\n   882→    const step1 = await io('do-something', () => doSomething());\n   883→    const step2 = await io('do-something-else', () => doSomethingElse(step1));\n   884→\n   885→    // Parallel operations with explicit keys\n   886→    const [a, b, c] = await all([\n   887→      ['fetch-a', () => fetchA()],\n   888→      ['fetch-b', () => fetchB()],\n   889→      ['fetch-c', () => fetchC()],\n   890→    ]);\n   891→\n   892→    await io('finalize', () => finalize(step2, a, b, c));\n   893→  }\n   894→});\n   895→```\n   896→\n   897→### For Production Deployments\n   898→\n   899→Configure a persistent checkpoint store:\n   900→\n   901→```typescript\n   902→import { RedisCheckpointStore } from 'matador/checkpoint';\n   903→import Redis from 'ioredis';\n   904→\n   905→const matador = new Matador({\n   906→  // ... other config ...\n   907→  checkpointStore: new RedisCheckpointStore(new Redis(), {\n   908→    prefix: 'myapp:checkpoint:',\n   909→    ttlSeconds: 86400, // 24 hours\n   910→  }),\n   911→});\n   912→```\n   913→\n   914→## Testing Strategy\n   915→\n   916→### Unit Tests\n   917→\n   918→1. **ResumableContext**\n   919→   - `io()` caches results with explicit keys\n   920→   - `io()` returns cached value when key exists in checkpoint\n   921→   - `io()` throws on duplicate key within same execution\n   922→   - `all()` executes in parallel and caches all results\n   923→   - Error in `io()` propagates without caching\n   924→   - `clear()` removes checkpoint\n   925→\n   926→2. **CheckpointStores**\n   927→   - CRUD operations for each implementation\n   928→   - TTL/cleanup behavior\n   929→   - Concurrent access handling\n   930→\n   931→3. **Pipeline Integration**\n   932→   - Context is passed to subscriber\n   933→   - Checkpoint loaded on retry\n   934→   - Checkpoint cleared on success\n   935→   - Checkpoint retained on failure\n   936→\n   937→4. **Type Safety**\n   938→   - Non-JsonSerializable types rejected at compile time\n   939→   - JsonSerializable types accepted\n   940→   - Discriminated union enforces `idempotent: 'resumable'` ↔ `ResumableCallback` pairing\n   941→   - Standard callbacks cannot have context parameter\n   942→   - Resumable callbacks must have context parameter\n   943→\n   944→### Integration Tests\n   945→\n   946→1. **End-to-end retry with checkpoints**\n   947→   - Subscriber fails after 2 io() calls\n   948→   - Retry executes, first 2 io() calls return cached\n   949→   - Third io() call executes fresh\n   950→   - Success clears checkpoint\n   951→\n   952→2. **Parallel operations with all()**\n   953→   - Some operations in all() succeed, some fail\n   954→   - Retry replays successful ones from cache\n   955→\n   956→3. **Checkpoint store reliability**\n   957→   - Redis connection loss handling\n   958→   - Checkpoint corruption recovery\n   959→\n   960→### Example Test Case\n   961→\n   962→```typescript\n   963→describe('Resumable Subscribers', () => {\n   964→  it('should replay cached io() results on retry', async () => {\n   965→    const executionLog: string[] = [];\n   966→    let shouldFail = true;\n   967→\n   968→    const subscriber = createSubscriber<TestEvent>({\n   969→      name: 'test-resumable',\n   970→      idempotent: 'resumable',\n   971→      callback: async (envelope, { io }) => {\n   972→        await io('step-0', () => {\n   973→          executionLog.push('step-0');\n   974→          return 'result-0';\n   975→        });\n   976→\n   977→        await io('step-1', () => {\n   978→          executionLog.push('step-1');\n   979→          return 'result-1';\n   980→        });\n   981→\n   982→        if (shouldFail) {\n   983→          shouldFail = false;\n   984→          throw new Error('Simulated failure');\n   985→        }\n   986→\n   987→        await io('step-2', () => {\n   988→          executionLog.push('step-2');\n   989→          return 'result-2';\n   990→        });\n   991→      }\n   992→    });\n   993→\n   994→    // First attempt - fails after step-1\n   995→    await processMessage(envelope, subscriber);\n   996→    expect(executionLog).toEqual(['step-0', 'step-1']);\n   997→\n   998→    // Retry - step-0 and step-1 use cache, step-2 executes\n   999→    executionLog.length = 0;\n  1000→    await processMessage(envelope, subscriber);\n  1001→    expect(executionLog).toEqual(['step-2']); // Only step-2 executed!\n  1002→  });\n  1003→\n  1004→  it('should handle parallel operations with all()', async () => {\n  1005→    const executionLog: string[] = [];\n  1006→\n  1007→    const subscriber = createSubscriber<TestEvent>({\n  1008→      name: 'test-parallel',\n  1009→      idempotent: 'resumable',\n  1010→      callback: async (envelope, { io, all }) => {\n  1011→        const [a, b, c] = await all([\n  1012→          ['fetch-a', () => { executionLog.push('a'); return 'result-a'; }],\n  1013→          ['fetch-b', () => { executionLog.push('b'); return 'result-b'; }],\n  1014→          ['fetch-c', () => { executionLog.push('c'); return 'result-c'; }],\n  1015→        ]);\n  1016→\n  1017→        expect(a).toBe('result-a');\n  1018→        expect(b).toBe('result-b');\n  1019→        expect(c).toBe('result-c');\n  1020→      }\n  1021→    });\n  1022→\n  1023→    await processMessage(envelope, subscriber);\n  1024→    expect(executionLog).toContain('a');\n  1025→    expect(executionLog).toContain('b');\n  1026→    expect(executionLog).toContain('c');\n  1027→  });\n  1028→\n  1029→  it('should throw on duplicate keys', async () => {\n  1030→    const subscriber = createSubscriber<TestEvent>({\n  1031→      name: 'test-duplicate-key',\n  1032→      idempotent: 'resumable',\n  1033→      callback: async (envelope, { io }) => {\n  1034→        await io('same-key', () => 'first');\n  1035→        await io('same-key', () => 'second');  // Should throw!\n  1036→      }\n  1037→    });\n  1038→\n  1039→    await expect(processMessage(envelope, subscriber))\n  1040→      .rejects.toThrow(DuplicateIoKeyError);\n  1041→  });\n  1042→});\n  1043→```\n  1044→\n  1045→## Future Enhancements\n  1046→\n  1047→### 1. Checkpoint inspection API\n  1048→\n  1049→```typescript\n  1050→// For debugging/admin tools\n  1051→const checkpoint = await matador.getCheckpoint(envelopeId);\n  1052→console.log(checkpoint.completedSteps);\n  1053→```\n  1054→\n  1055→### 2. Checkpoint metrics\n  1056→\n  1057→- Track checkpoint hit/miss ratios\n  1058→- Monitor checkpoint sizes\n  1059→- Alert on high checkpoint counts (indicating frequent failures)\n  1060→\n  1061→## Implementation Order\n  1062→\n  1063→1. **Phase 1: Core Types and Interfaces**\n  1064→   - [ ] Add `'resumable'` to `Idempotency` type in `types/common.ts`\n  1065→   - [ ] Define `Checkpoint`, `CheckpointStore`, `JsonSerializable` types\n  1066→   - [ ] Define `SubscriberContext` interface with `io()` and `all()`\n  1067→   - [ ] Define `StandardCallback<T>` and `ResumableCallback<T>` types\n  1068→   - [ ] Update `SubscriberOptions<T>` to discriminated union\n  1069→   - [ ] Update `createSubscriber` to accept the discriminated union\n  1070→\n  1071→2. **Phase 2: Checkpoint Stores**\n  1072→   - [ ] Implement `NoOpCheckpointStore` (default)\n  1073→   - [ ] Implement `MemoryCheckpointStore`\n  1074→   - [ ] Write unit tests for stores\n  1075→\n  1076→3. **Phase 3: ResumableContext**\n  1077→   - [ ] Implement `ResumableContext` class\n  1078→   - [ ] Implement `io(key, fn)` with explicit keys\n  1079→   - [ ] Implement duplicate key detection\n  1080→   - [ ] Implement `all(ops)` for parallel operations\n  1081→   - [ ] Add `DuplicateIoKeyError` to errors\n  1082→   - [ ] Write unit tests for context\n  1083→\n  1084→4. **Phase 4: Pipeline Integration**\n  1085→   - [ ] Add `checkpointStore` to `MatadorConfig`\n  1086→   - [ ] Modify `ProcessingPipeline` to create/manage context\n  1087→   - [ ] Only load checkpoints for `idempotent: 'resumable'` subscribers\n  1088→   - [ ] Pass context to subscriber callbacks\n  1089→   - [ ] Clear checkpoint on success/dead-letter\n  1090→\n  1091→5. **Phase 5: Schema Validation**\n  1092→   - [ ] Add validation warning for `'resumable'` without `checkpointStore`\n  1093→   - [ ] Update schema validation tests\n  1094→\n  1095→6. **Phase 6: Hooks**\n  1096→   - [ ] Add checkpoint-related hooks to `MatadorHooks`\n  1097→   - [ ] Integrate hooks into context operations\n  1098→\n  1099→7. **Phase 7: Integration Tests**\n  1100→   - [ ] End-to-end retry with checkpoints\n  1101→   - [ ] Parallel operations with all()\n  1102→   - [ ] Dead-letter checkpoint cleanup\n  1103→   - [ ] Test `'resumable'` idempotency behavior\n  1104→\n  1105→8. **Phase 8: Redis Store**\n  1106→   - [ ] Implement `RedisCheckpointStore`\n  1107→   - [ ] Write integration tests with Redis\n  1108→\n  1109→9. **Phase 9: Documentation**\n  1110→   - [ ] API documentation\n  1111→   - [ ] Migration guide\n  1112→   - [ ] Examples\n  1113→   - [ ] Document explicit key requirements\n  1114→   - [ ] Document `idempotent: 'resumable'` semantics\n  1115→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T14:25:55.395Z"
        },
        {
          "type": "assistant",
          "text": "Let me explore the current codebase structure to understand the existing types and architecture before implementing.",
          "timestamp": "2025-12-11T14:26:00.497Z"
        },
        {
          "type": "tool_use",
          "name": "Glob",
          "input": {
            "pattern": "packages/matador/src/**/*.ts"
          },
          "timestamp": "2025-12-11T14:26:00.667Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/types/common.ts"
          },
          "timestamp": "2025-12-11T14:26:00.826Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/types/subscriber.ts"
          },
          "timestamp": "2025-12-11T14:26:00.980Z"
        },
        {
          "type": "user",
          "text": "     1→/**\n     2→ * Delivery semantics for message processing.\n     3→ * - 'at-least-once': Acknowledge after processing (may redeliver on failure)\n     4→ * - 'at-most-once': Acknowledge before processing (no redelivery, may lose messages)\n     5→ */\n     6→export type DeliveryMode = 'at-least-once' | 'at-most-once';\n     7→\n     8→/**\n     9→ * Importance level for subscribers, used for monitoring and alerting prioritization.\n    10→ */\n    11→export type Importance =\n    12→  | 'can-ignore'\n    13→  | 'should-investigate'\n    14→  | 'must-investigate';\n    15→\n    16→/**\n    17→ * Idempotency declaration for subscribers.\n    18→ * - 'yes': Safe to retry on failure\n    19→ * - 'no': Not safe to retry, may cause duplicate side effects\n    20→ * - 'unknown': Idempotency not determined\n    21→ */\n    22→export type Idempotency = 'yes' | 'no' | 'unknown';\n    23→\n    24→/**\n    25→ * Result of a validation operation.\n    26→ */\n    27→export interface ValidationResult {\n    28→  readonly valid: boolean;\n    29→  readonly errors: readonly ValidationError[];\n    30→}\n    31→\n    32→/**\n    33→ * Individual validation error.\n    34→ */\n    35→export interface ValidationError {\n    36→  readonly path: string;\n    37→  readonly message: string;\n    38→}\n    39→\n    40→/**\n    41→ * Creates a successful validation result.\n    42→ */\n    43→export function validResult(): ValidationResult {\n    44→  return { valid: true, errors: [] };\n    45→}\n    46→\n    47→/**\n    48→ * Creates a failed validation result.\n    49→ */\n    50→export function invalidResult(errors: ValidationError[]): ValidationResult {\n    51→  return { valid: false, errors };\n    52→}\n    53→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T14:26:01.129Z"
        },
        {
          "type": "user",
          "text": "     1→import type { Idempotency, Importance } from './common.js';\n     2→import type { Envelope } from './envelope.js';\n     3→import type { MatadorEvent } from './event.js';\n     4→\n     5→/**\n     6→ * Helper type to get the envelope type for a subscriber callback.\n     7→ * Extracts the data type from a MatadorEvent and wraps it in an Envelope.\n     8→ *\n     9→ * @example\n    10→ * async callback(envelope: EnvelopeOf<MyEvent>) {\n    11→ *   console.log(envelope.data.someField); // Type-safe access\n    12→ * }\n    13→ */\n    14→export type EnvelopeOf<T extends MatadorEvent> = Envelope<T['data']>;\n    15→\n    16→/**\n    17→ * Callback function executed when an event is received.\n    18→ * Receives the full envelope containing id, data, and docket.\n    19→ */\n    20→export type SubscriberCallback<T = unknown> = (\n    21→  envelope: Envelope<T>,\n    22→) => Promise<void> | void;\n    23→\n    24→/**\n    25→ * Configuration options for a subscriber.\n    26→ */\n    27→export interface SubscriberOptions {\n    28→  /** Route this subscriber's events to a specific queue */\n    29→  readonly targetQueue?: string | undefined;\n    30→\n    31→  /** Idempotency declaration for retry handling */\n    32→  readonly idempotent?: Idempotency | undefined;\n    33→\n    34→  /** Importance level for monitoring and alerting */\n    35→  readonly importance?: Importance | undefined;\n    36→\n    37→  /** Feature flag function to conditionally enable/disable the subscriber */\n    38→  readonly enabled?: (() => boolean | Promise<boolean>) | undefined;\n    39→}\n    40→\n    41→/**\n    42→ * Full subscriber definition with callback.\n    43→ */\n    44→export interface Subscriber<T extends MatadorEvent> extends SubscriberOptions {\n    45→  /** Human-readable name for the subscriber */\n    46→  readonly name: string;\n    47→\n    48→  /** Callback function to execute when event is received */\n    49→  readonly callback: SubscriberCallback<T['data']>;\n    50→}\n    51→\n    52→/**\n    53→ * Subscriber stub for multi-codebase scenarios where subscriber implementation\n    54→ * is in a remote service. Declares the subscriber contract without providing\n    55→ * the callback.\n    56→ */\n    57→export interface SubscriberStub extends SubscriberOptions {\n    58→  /** Human-readable name for the subscriber */\n    59→  readonly name: string;\n    60→\n    61→  /** Indicates this is a stub without implementation */\n    62→  readonly isStub: true;\n    63→}\n    64→\n    65→/**\n    66→ * Union type for any subscriber definition (full or stub).\n    67→ * This is the type-erased version for use in collections and schema.\n    68→ * Uses `any` because Subscriber<T> is contravariant in T (callback parameter),\n    69→ * making it impossible to assign Subscriber<SpecificEvent> to Subscriber<MatadorEvent<unknown>>.\n    70→ */\n    71→// biome-ignore lint/suspicious/noExplicitAny: Required for variance compatibility in heterogeneous collections\n    72→export type AnySubscriber = Subscriber<MatadorEvent<any>> | SubscriberStub;\n    73→\n    74→/**\n    75→ * Type guard to check if a subscriber is a stub.\n    76→ */\n    77→export function isSubscriberStub(\n    78→  subscriber: AnySubscriber,\n    79→): subscriber is SubscriberStub {\n    80→  return 'isStub' in subscriber && subscriber.isStub === true;\n    81→}\n    82→\n    83→/**\n    84→ * Type guard to check if a subscriber has a callback implementation.\n    85→ */\n    86→export function isSubscriber(\n    87→  subscriber: AnySubscriber,\n    88→  // biome-ignore lint/suspicious/noExplicitAny: Required for variance compatibility\n    89→): subscriber is Subscriber<MatadorEvent<any>> {\n    90→  return 'callback' in subscriber && typeof subscriber.callback === 'function';\n    91→}\n    92→\n    93→/**\n    94→ * Creates a subscriber definition.\n    95→ */\n    96→export function createSubscriber<T extends MatadorEvent>(\n    97→  name: string,\n    98→  callback: SubscriberCallback<T['data']>,\n    99→  options: SubscriberOptions = {},\n   100→): Subscriber<T> {\n   101→  return {\n   102→    name,\n   103→    callback,\n   104→    idempotent: options.idempotent ?? 'unknown',\n   105→    importance: options.importance ?? 'should-investigate',\n   106→    ...(options.targetQueue !== undefined && {\n   107→      targetQueue: options.targetQueue,\n   108→    }),\n   109→    ...(options.enabled !== undefined && { enabled: options.enabled }),\n   110→  };\n   111→}\n   112→\n   113→/**\n   114→ * Creates a subscriber stub for remote implementations.\n   115→ */\n   116→export function createSubscriberStub(\n   117→  name: string,\n   118→  options: SubscriberOptions = {},\n   119→): SubscriberStub {\n   120→  return {\n   121→    name,\n   122→    isStub: true,\n   123→    idempotent: options.idempotent ?? 'unknown',\n   124→    importance: options.importance ?? 'should-investigate',\n   125→    ...(options.targetQueue !== undefined && {\n   126→      targetQueue: options.targetQueue,\n   127→    }),\n   128→    ...(options.enabled !== undefined && { enabled: options.enabled }),\n   129→  };\n   130→}\n   131→\n   132→/**\n   133→ * Definition interface used by the pipeline (excludes event class reference).\n   134→ */\n   135→export interface SubscriberDefinition {\n   136→  readonly name: string;\n   137→  readonly idempotent: Idempotency;\n   138→  readonly importance: Importance;\n   139→  readonly targetQueue?: string | undefined;\n   140→}\n   141→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T14:26:01.129Z"
        },
        {
          "type": "user",
          "text": "/home/z/Desktop/work/matador/packages/matador/src/codec/header-aware-codec.ts\n/home/z/Desktop/work/matador/packages/matador/src/codec/codec.ts\n/home/z/Desktop/work/matador/packages/matador/src/codec/index.ts\n/home/z/Desktop/work/matador/packages/matador/src/core/index.ts\n/home/z/Desktop/work/matador/packages/matador/src/hooks/index.ts\n/home/z/Desktop/work/matador/packages/matador/src/errors/has-description.ts\n/home/z/Desktop/work/matador/packages/matador/src/errors/retry-errors.ts\n/home/z/Desktop/work/matador/packages/matador/src/errors/matador-errors.ts\n/home/z/Desktop/work/matador/packages/matador/src/errors/index.ts\n/home/z/Desktop/work/matador/packages/matador/src/pipeline/index.ts\n/home/z/Desktop/work/matador/packages/matador/src/retry/policy.ts\n/home/z/Desktop/work/matador/packages/matador/src/retry/index.ts\n/home/z/Desktop/work/matador/packages/matador/src/schema/index.ts\n/home/z/Desktop/work/matador/packages/matador/src/topology/types.ts\n/home/z/Desktop/work/matador/packages/matador/src/topology/index.ts\n/home/z/Desktop/work/matador/packages/matador/src/transport/local/local-transport.test.ts\n/home/z/Desktop/work/matador/packages/matador/src/transport/capabilities.ts\n/home/z/Desktop/work/matador/packages/matador/src/transport/connection-manager.ts\n/home/z/Desktop/work/matador/packages/matador/src/types/common.ts\n/home/z/Desktop/work/matador/packages/matador/src/types/subscriber.ts\n/home/z/Desktop/work/matador/packages/matador/src/types/index.ts\n/home/z/Desktop/work/matador/packages/matador/src/core/matador.test.ts\n/home/z/Desktop/work/matador/packages/matador/src/schema/types.ts\n/home/z/Desktop/work/matador/packages/matador/src/types/event.ts\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.ts\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts\n/home/z/Desktop/work/matador/packages/matador/src/schema/registry.test.ts\n/home/z/Desktop/work/matador/packages/matador/src/transport/index.ts\n/home/z/Desktop/work/matador/packages/matador/src/index.ts\n/home/z/Desktop/work/matador/packages/matador/src/types/envelope.ts\n/home/z/Desktop/work/matador/packages/matador/src/types/event.test.ts\n/home/z/Desktop/work/matador/packages/matador/src/hooks/safe-hooks.ts\n/home/z/Desktop/work/matador/packages/matador/src/schema/registry.ts\n/home/z/Desktop/work/matador/packages/matador/src/retry/standard-policy.ts\n/home/z/Desktop/work/matador/packages/matador/src/core/shutdown.ts\n/home/z/Desktop/work/matador/packages/matador/src/codec/json-codec.ts\n/home/z/Desktop/work/matador/packages/matador/src/codec/rabbitmq-codec.ts\n/home/z/Desktop/work/matador/packages/matador/src/core/matador.ts\n/home/z/Desktop/work/matador/packages/matador/src/core/shutdown.test.ts\n/home/z/Desktop/work/matador/packages/matador/src/codec/rabbitmq-codec.test.ts\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.ts\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts\n/home/z/Desktop/work/matador/packages/matador/src/transport/transport.ts\n/home/z/Desktop/work/matador/packages/matador/src/retry/standard-policy.test.ts\n/home/z/Desktop/work/matador/packages/matador/src/pipeline/pipeline.ts\n/home/z/Desktop/work/matador/packages/matador/src/pipeline/pipeline.test.ts\n/home/z/Desktop/work/matador/packages/matador/src/transport/rabbitmq/rabbitmq-transport.ts\n/home/z/Desktop/work/matador/packages/matador/src/hooks/types.ts\n/home/z/Desktop/work/matador/packages/matador/src/transport/multi/multi-transport.ts\n/home/z/Desktop/work/matador/packages/matador/src/transport/multi/multi-transport.test.ts\n/home/z/Desktop/work/matador/packages/matador/src/transport/local/local-transport.ts",
          "timestamp": "2025-12-11T14:26:01.167Z"
        },
        {
          "type": "assistant",
          "text": "Now let me read more files to understand the pipeline, hooks, errors, and the envelope structure:",
          "timestamp": "2025-12-11T14:26:04.672Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/pipeline/pipeline.ts"
          },
          "timestamp": "2025-12-11T14:26:05.023Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/hooks/types.ts"
          },
          "timestamp": "2025-12-11T14:26:05.449Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/types/envelope.ts"
          },
          "timestamp": "2025-12-11T14:26:05.906Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/errors/index.ts"
          },
          "timestamp": "2025-12-11T14:26:06.383Z"
        },
        {
          "type": "user",
          "text": "     1→import type { Codec } from '../codec/index.js';\n     2→import { CodecDecodeError } from '../codec/index.js';\n     3→import {\n     4→  SubscriberIsStubError,\n     5→  SubscriberNotRegisteredError,\n     6→} from '../errors/index.js';\n     7→import type { SafeHooks } from '../hooks/index.js';\n     8→import type { RetryDecision, RetryPolicy } from '../retry/index.js';\n     9→import type { SchemaRegistry } from '../schema/index.js';\n    10→import type { MessageReceipt, Transport } from '../transport/index.js';\n    11→import type { Envelope, SubscriberDefinition } from '../types/index.js';\n    12→\n    13→/**\n    14→ * Configuration for the processing pipeline.\n    15→ */\n    16→export interface PipelineConfig {\n    17→  readonly transport: Transport;\n    18→  readonly schema: SchemaRegistry;\n    19→  readonly codec: Codec;\n    20→  readonly retryPolicy: RetryPolicy;\n    21→  readonly hooks: SafeHooks;\n    22→}\n    23→\n    24→/**\n    25→ * Result of pipeline processing.\n    26→ */\n    27→export interface ProcessResult {\n    28→  readonly success: boolean;\n    29→  readonly envelope?: Envelope | undefined;\n    30→  readonly subscriber?: SubscriberDefinition | undefined;\n    31→  readonly error?: Error | undefined;\n    32→  readonly decision?: RetryDecision | undefined;\n    33→  readonly durationMs: number;\n    34→}\n    35→\n    36→/**\n    37→ * Processing pipeline for incoming messages.\n    38→ *\n    39→ * Handles the complete message lifecycle:\n    40→ * 1. Decode envelope from raw bytes\n    41→ * 2. Lookup subscriber from schema\n    42→ * 3. Execute subscriber callback with hooks\n    43→ * 4. Handle success/failure with retry policy\n    44→ */\n    45→export class ProcessingPipeline {\n    46→  private readonly transport: Transport;\n    47→  private readonly schema: SchemaRegistry;\n    48→  private readonly codec: Codec;\n    49→  private readonly retryPolicy: RetryPolicy;\n    50→  private readonly hooks: SafeHooks;\n    51→\n    52→  constructor(config: PipelineConfig) {\n    53→    this.transport = config.transport;\n    54→    this.schema = config.schema;\n    55→    this.codec = config.codec;\n    56→    this.retryPolicy = config.retryPolicy;\n    57→    this.hooks = config.hooks;\n    58→  }\n    59→\n    60→  /**\n    61→   * Processes a raw message from the transport.\n    62→   */\n    63→  async process(\n    64→    rawMessage: Uint8Array,\n    65→    receipt: MessageReceipt,\n    66→  ): Promise<ProcessResult> {\n    67→    const startTime = performance.now();\n    68→\n    69→    // 1. Decode envelope\n    70→    let envelope: Envelope;\n    71→    try {\n    72→      envelope = this.codec.decode(rawMessage);\n    73→    } catch (error) {\n    74→      const decodeError =\n    75→        error instanceof CodecDecodeError\n    76→          ? error\n    77→          : new CodecDecodeError('Unknown decode error', error);\n    78→\n    79→      await this.transport.complete(receipt);\n    80→      await this.hooks.onDecodeError({\n    81→        error: decodeError,\n    82→        rawMessage,\n    83→        sourceQueue: receipt.sourceQueue,\n    84→        transport: receipt.sourceTransport,\n    85→      });\n    86→\n    87→      return {\n    88→        success: false,\n    89→        error: decodeError,\n    90→        durationMs: performance.now() - startTime,\n    91→      };\n    92→    }\n    93→\n    94→    // 2. Lookup subscriber from schema\n    95→    const subscriberDef = this.schema.getSubscriberDefinition(\n    96→      envelope.docket.eventKey,\n    97→      envelope.docket.targetSubscriber,\n    98→    );\n    99→\n   100→    if (!subscriberDef) {\n   101→      const error = new SubscriberNotRegisteredError(\n   102→        envelope.docket.targetSubscriber,\n   103→        envelope.docket.eventKey,\n   104→      );\n   105→      await this.sendToDeadLetter(\n   106→        receipt,\n   107→        envelope,\n   108→        'unhandled',\n   109→        error.message,\n   110→      );\n   111→\n   112→      return {\n   113→        success: false,\n   114→        envelope,\n   115→        error,\n   116→        durationMs: performance.now() - startTime,\n   117→      };\n   118→    }\n   119→\n   120→    // Get executable subscriber\n   121→    const subscriber = this.schema.getExecutableSubscriber(\n   122→      envelope.docket.eventKey,\n   123→      envelope.docket.targetSubscriber,\n   124→    );\n   125→\n   126→    if (!subscriber) {\n   127→      // Subscriber is a stub (remote implementation)\n   128→      const error = new SubscriberIsStubError(envelope.docket.targetSubscriber);\n   129→      await this.sendToDeadLetter(\n   130→        receipt,\n   131→        envelope,\n   132→        'unhandled',\n   133→        error.message,\n   134→      );\n   135→\n   136→      return {\n   137→        success: false,\n   138→        envelope,\n   139→        subscriber: subscriberDef,\n   140→        error,\n   141→        durationMs: performance.now() - startTime,\n   142→      };\n   143→    }\n   144→\n   145→    // 3. Execute subscriber callback with hooks\n   146→    let result: unknown;\n   147→    let error: Error | undefined;\n   148→\n   149→    await this.hooks.onWorkerWrap(envelope, subscriberDef, async () => {\n   150→      await this.hooks.onWorkerBeforeProcess(envelope, subscriberDef);\n   151→\n   152→      try {\n   153→        result = await subscriber.callback(envelope);\n   154→      } catch (e) {\n   155→        error = e instanceof Error ? e : new Error(String(e));\n   156→      }\n   157→    });\n   158→\n   159→    const durationMs = performance.now() - startTime;\n   160→\n   161→    // 4. Handle success\n   162→    if (!error) {\n   163→      await this.transport.complete(receipt);\n   164→      await this.hooks.onWorkerSuccess({\n   165→        envelope,\n   166→        subscriber: subscriberDef,\n   167→        result,\n   168→        durationMs,\n   169→        transport: receipt.sourceTransport,\n   170→      });\n   171→\n   172→      return {\n   173→        success: true,\n   174→        envelope,\n   175→        subscriber: subscriberDef,\n   176→        durationMs,\n   177→      };\n   178→    }\n   179→\n   180→    // 5. Handle failure - consult retry policy\n   181→    const decision = this.retryPolicy.shouldRetry({\n   182→      envelope,\n   183→      error,\n   184→      subscriber: subscriberDef,\n   185→      receipt,\n   186→    });\n   187→\n   188→    // Update envelope with error info\n   189→    envelope.docket.lastError = error.message;\n   190→    envelope.docket.firstError ??= error.message;\n   191→\n   192→    await this.handleRetryDecision(receipt, envelope, decision);\n   193→\n   194→    await this.hooks.onWorkerError({\n   195→      envelope,\n   196→      subscriber: subscriberDef,\n   197→      error,\n   198→      durationMs,\n   199→      decision,\n   200→      transport: receipt.sourceTransport,\n   201→    });\n   202→\n   203→    return {\n   204→      success: false,\n   205→      envelope,\n   206→      subscriber: subscriberDef,\n   207→      error,\n   208→      decision,\n   209→      durationMs,\n   210→    };\n   211→  }\n   212→\n   213→  private async handleRetryDecision(\n   214→    receipt: MessageReceipt,\n   215→    envelope: Envelope,\n   216→    decision: RetryDecision,\n   217→  ): Promise<void> {\n   218→    switch (decision.action) {\n   219→      case 'retry': {\n   220→        // Increment attempts and schedule retry\n   221→        envelope.docket.attempts++;\n   222→        envelope.docket.scheduledFor = new Date(\n   223→          Date.now() + decision.delay,\n   224→        ).toISOString();\n   225→\n   226→        await this.transport.send(receipt.sourceQueue, envelope, {\n   227→          delay: decision.delay,\n   228→        });\n   229→        await this.transport.complete(receipt);\n   230→        break;\n   231→      }\n   232→\n   233→      case 'dead-letter': {\n   234→        await this.sendToDeadLetter(\n   235→          receipt,\n   236→          envelope,\n   237→          decision.queue,\n   238→          decision.reason,\n   239→        );\n   240→        break;\n   241→      }\n   242→\n   243→      case 'discard': {\n   244→        await this.transport.complete(receipt);\n   245→        break;\n   246→      }\n   247→    }\n   248→  }\n   249→\n   250→  private async sendToDeadLetter(\n   251→    receipt: MessageReceipt,\n   252→    envelope: Envelope,\n   253→    dlqName: string,\n   254→    reason: string,\n   255→  ): Promise<void> {\n   256→    envelope.docket.originalQueue ??= receipt.sourceQueue;\n   257→\n   258→    if (this.transport.sendToDeadLetter) {\n   259→      await this.transport.sendToDeadLetter(receipt, dlqName, envelope, reason);\n   260→    } else {\n   261→      // Manual: send to DLQ then complete original\n   262→      const fullDlqName = `${receipt.sourceQueue}.${dlqName}`;\n   263→      await this.transport.send(fullDlqName, envelope);\n   264→      await this.transport.complete(receipt);\n   265→    }\n   266→  }\n   267→}\n   268→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T14:26:06.499Z"
        },
        {
          "type": "user",
          "text": "     1→import type { RetryDecision } from '../retry/index.js';\n     2→import type { ConnectionState, Transport } from '../transport/index.js';\n     3→import type { Envelope, SubscriberDefinition } from '../types/index.js';\n     4→\n     5→/**\n     6→ * Logger interface for Matador internal logging.\n     7→ */\n     8→export interface Logger {\n     9→  debug(message: string, ...args: unknown[]): void;\n    10→  info(message: string, ...args: unknown[]): void;\n    11→  warn(message: string, ...args: unknown[]): void;\n    12→  error(message: string, ...args: unknown[]): void;\n    13→}\n    14→\n    15→/**\n    16→ * Default logger that uses console.\n    17→ */\n    18→export const consoleLogger: Logger = {\n    19→  debug: (message, ...args) => console.debug(message, ...args),\n    20→  info: (message, ...args) => console.info(message, ...args),\n    21→  warn: (message, ...args) => console.warn(message, ...args),\n    22→  error: (message, ...args) => console.error(message, ...args),\n    23→};\n    24→\n    25→/**\n    26→ * Context for enqueue success hook.\n    27→ */\n    28→export interface EnqueueSuccessContext {\n    29→  readonly envelope: Envelope;\n    30→  readonly queue: string;\n    31→  /** The transport that was used (e.g., 'local', 'rabbitmq') */\n    32→  readonly transport: string;\n    33→}\n    34→\n    35→/**\n    36→ * Context for enqueue warning hook (fallback used).\n    37→ */\n    38→export interface EnqueueWarningContext {\n    39→  readonly envelope: Envelope;\n    40→  readonly originalQueue: string;\n    41→  readonly fallbackQueue: string;\n    42→  readonly error: Error;\n    43→}\n    44→\n    45→/**\n    46→ * Context for transport fallback hook.\n    47→ */\n    48→export interface TransportFallbackContext {\n    49→  /** The envelope that was being sent */\n    50→  readonly envelope: Envelope;\n    51→  /** The queue the message was being sent to */\n    52→  readonly queue: string;\n    53→  /** The transport that failed */\n    54→  readonly failedTransport: Transport['name'];\n    55→  /** The transport that will be tried next */\n    56→  readonly nextTransport: Transport['name'];\n    57→  /** The error from the failed transport */\n    58→  readonly error: Error;\n    59→}\n    60→\n    61→/**\n    62→ * Context for enqueue error hook.\n    63→ */\n    64→export interface EnqueueErrorContext {\n    65→  readonly envelope: Envelope;\n    66→  readonly error: Error;\n    67→  /** The transport that failed (e.g., 'local', 'rabbitmq') */\n    68→  readonly transport: string;\n    69→}\n    70→\n    71→/**\n    72→ * Context for decode error hook.\n    73→ */\n    74→export interface DecodeErrorContext {\n    75→  readonly error: Error;\n    76→  readonly rawMessage: Uint8Array;\n    77→  readonly sourceQueue: string;\n    78→  /** The transport that received the message (e.g., 'local', 'rabbitmq') */\n    79→  readonly transport: string;\n    80→}\n    81→\n    82→/**\n    83→ * Context for worker success hook.\n    84→ */\n    85→export interface WorkerSuccessContext {\n    86→  readonly envelope: Envelope;\n    87→  readonly subscriber: SubscriberDefinition;\n    88→  readonly result: unknown;\n    89→  readonly durationMs: number;\n    90→  /** The transport that received the message (e.g., 'local', 'rabbitmq') */\n    91→  readonly transport: string;\n    92→}\n    93→\n    94→/**\n    95→ * Context for worker error hook.\n    96→ */\n    97→export interface WorkerErrorContext {\n    98→  readonly envelope: Envelope;\n    99→  readonly subscriber: SubscriberDefinition;\n   100→  readonly error: Error;\n   101→  readonly durationMs: number;\n   102→  readonly decision: RetryDecision;\n   103→  /** The transport that received the message (e.g., 'local', 'rabbitmq') */\n   104→  readonly transport: string;\n   105→}\n   106→\n   107→/**\n   108→ * Execution function passed to onWorkerWrap for APM wrapping.\n   109→ */\n   110→export type WorkerExecuteFn = () => Promise<void>;\n   111→\n   112→/**\n   113→ * All available hooks for Matador.\n   114→ */\n   115→export interface MatadorHooks {\n   116→  /**\n   117→   * Logger for internal Matador logging.\n   118→   * Defaults to console logger if not provided.\n   119→   */\n   120→  logger?: Logger;\n   121→\n   122→  /**\n   123→   * Called when an event is successfully enqueued.\n   124→   */\n   125→  onEnqueueSuccess?(context: EnqueueSuccessContext): void | Promise<void>;\n   126→\n   127→  /**\n   128→   * Called when enqueue falls back to a secondary queue.\n   129→   */\n   130→  onEnqueueWarning?(context: EnqueueWarningContext): void | Promise<void>;\n   131→\n   132→  /**\n   133→   * Called when transport fallback occurs during send.\n   134→   * Only fires when using MultiTransport with fallbackEnabled=true.\n   135→   */\n   136→  onTransportFallback?(context: TransportFallbackContext): void | Promise<void>;\n   137→\n   138→  /**\n   139→   * Called when enqueue fails completely.\n   140→   */\n   141→  onEnqueueError?(context: EnqueueErrorContext): void | Promise<void>;\n   142→\n   143→  /**\n   144→   * Wraps entire worker processing (for APM context).\n   145→   * Must call execute() to run the actual processing.\n   146→   */\n   147→  onWorkerWrap?(\n   148→    envelope: Envelope,\n   149→    subscriber: SubscriberDefinition,\n   150→    execute: WorkerExecuteFn,\n   151→  ): Promise<void>;\n   152→\n   153→  /**\n   154→   * Called before processing begins.\n   155→   */\n   156→  onWorkerBeforeProcess?(\n   157→    envelope: Envelope,\n   158→    subscriber: SubscriberDefinition,\n   159→  ): void | Promise<void>;\n   160→\n   161→  /**\n   162→   * Called after successful processing.\n   163→   */\n   164→  onWorkerSuccess?(context: WorkerSuccessContext): void | Promise<void>;\n   165→\n   166→  /**\n   167→   * Called after processing error.\n   168→   */\n   169→  onWorkerError?(context: WorkerErrorContext): void | Promise<void>;\n   170→\n   171→  /**\n   172→   * Called when message decoding fails.\n   173→   */\n   174→  onDecodeError?(context: DecodeErrorContext): void | Promise<void>;\n   175→\n   176→  /**\n   177→   * Called when transport connection state changes.\n   178→   */\n   179→  onConnectionStateChange?(state: ConnectionState): void | Promise<void>;\n   180→\n   181→  /**\n   182→   * Loads universal metadata to add to all envelopes.\n   183→   */\n   184→  loadUniversalMetadata?():\n   185→    | Record<string, unknown>\n   186→    | Promise<Record<string, unknown>>;\n   187→\n   188→  /**\n   189→   * Dynamic queue concurrency lookup.\n   190→   */\n   191→  getQueueConcurrency?(\n   192→    queueName: string,\n   193→  ): number | undefined | Promise<number | undefined>;\n   194→\n   195→  /**\n   196→   * Dynamic retry delay lookup.\n   197→   */\n   198→  getRetryDelay?(\n   199→    envelope: Envelope,\n   200→    attemptNumber: number,\n   201→  ): number | undefined | Promise<number | undefined>;\n   202→\n   203→  /**\n   204→   * Dynamic max attempts lookup.\n   205→   */\n   206→  getAttempts?(\n   207→    envelope: Envelope,\n   208→  ): number | undefined | Promise<number | undefined>;\n   209→\n   210→  /**\n   211→   * Dynamic max deliveries (poison threshold) lookup.\n   212→   */\n   213→  getMaxDeliveries?(\n   214→    envelope: Envelope,\n   215→  ): number | undefined | Promise<number | undefined>;\n   216→}\n   217→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T14:26:06.500Z"
        },
        {
          "type": "user",
          "text": "     1→import type { Importance } from './common.js';\n     2→\n     3→/**\n     4→ * Message envelope containing the event data and routing/observability metadata.\n     5→ * This is the transport-agnostic message format used throughout Matador.\n     6→ */\n     7→export interface Envelope<T = unknown> {\n     8→  /** Unique message ID (UUID v4) */\n     9→  readonly id: string;\n    10→\n    11→  /** The event data */\n    12→  readonly data: T;\n    13→\n    14→  /** Routing, processing state, and observability metadata */\n    15→  readonly docket: Docket;\n    16→}\n    17→\n    18→/**\n    19→ * Metadata associated with an envelope for routing, processing state, and observability.\n    20→ */\n    21→export interface Docket {\n    22→  // === Routing ===\n    23→\n    24→  /** Event key for routing */\n    25→  readonly eventKey: string;\n    26→\n    27→  /** Human-readable description of the event (for observability/logging) */\n    28→  readonly eventDescription?: string | undefined;\n    29→\n    30→  /** Target subscriber name for 1:1 routing */\n    31→  readonly targetSubscriber: string;\n    32→\n    33→  /** Original queue before any dead-letter routing */\n    34→  originalQueue?: string | undefined;\n    35→\n    36→  /** Scheduled processing time for delayed messages (ISO 8601 string) */\n    37→  scheduledFor?: string | undefined;\n    38→\n    39→  // === Processing State ===\n    40→\n    41→  /**\n    42→   * Attempt counter managed by Matador (1-based).\n    43→   * Incremented on each retry. Used when transport doesn't track attempts.\n    44→   */\n    45→  attempts: number;\n    46→\n    47→  /** When the envelope was first created (ISO 8601 string) */\n    48→  readonly createdAt: string;\n    49→\n    50→  /** Error message from first failure (for debugging) */\n    51→  firstError?: string | undefined;\n    52→\n    53→  /** Error message from most recent failure */\n    54→  lastError?: string | undefined;\n    55→\n    56→  // === Observability ===\n    57→\n    58→  /** Importance level for monitoring */\n    59→  readonly importance: Importance;\n    60→\n    61→  /** Correlation ID for request tracing */\n    62→  readonly correlationId?: string | undefined;\n    63→\n    64→  /**\n    65→   * Custom metadata provided by the application.\n    66→   * This is the merged result of universal metadata (from loadUniversalMetadata hook)\n    67→   * and event-specific metadata (from dispatch options). Event-specific metadata\n    68→   * overrides universal metadata when keys conflict.\n    69→   */\n    70→  readonly metadata?: Record<string, unknown> | undefined;\n    71→}\n    72→\n    73→/**\n    74→ * Fields from Docket that can be specified when creating an envelope.\n    75→ */\n    76→type DocketCreateFields = Pick<\n    77→  Docket,\n    78→  'eventKey' | 'eventDescription' | 'targetSubscriber' | 'importance' | 'correlationId'\n    79→>;\n    80→\n    81→/**\n    82→ * Options for creating an envelope.\n    83→ */\n    84→export interface CreateEnvelopeOptions<T> extends DocketCreateFields {\n    85→  /** Optional custom ID (defaults to UUID v4) */\n    86→  readonly id?: string | undefined;\n    87→\n    88→  /** The event data */\n    89→  readonly data: T;\n    90→\n    91→  /**\n    92→   * Event-specific metadata to include in the docket.\n    93→   * Will be merged with universal metadata, with these values taking precedence.\n    94→   */\n    95→  readonly metadata?: Record<string, unknown> | undefined;\n    96→\n    97→  /**\n    98→   * Universal metadata loaded from the loadUniversalMetadata hook.\n    99→   * This is provided by the fanout engine, not by the caller.\n   100→   * @internal\n   101→   */\n   102→  readonly universalMetadata?: Record<string, unknown> | undefined;\n   103→\n   104→  /** Delay processing by this many milliseconds */\n   105→  readonly delayMs?: number | undefined;\n   106→}\n   107→\n   108→/**\n   109→ * Creates a new envelope with the provided options.\n   110→ */\n   111→export function createEnvelope<T>(\n   112→  options: CreateEnvelopeOptions<T>,\n   113→): Envelope<T> {\n   114→  const now = new Date().toISOString();\n   115→\n   116→  // Merge universal metadata with event-specific metadata\n   117→  // Event-specific metadata takes precedence\n   118→  const mergedMetadata =\n   119→    options.universalMetadata || options.metadata\n   120→      ? { ...options.universalMetadata, ...options.metadata }\n   121→      : undefined;\n   122→\n   123→  return {\n   124→    id: options.id ?? crypto.randomUUID(),\n   125→    data: options.data,\n   126→    docket: {\n   127→      // Routing\n   128→      eventKey: options.eventKey,\n   129→      ...(options.eventDescription !== undefined && {\n   130→        eventDescription: options.eventDescription,\n   131→      }),\n   132→      targetSubscriber: options.targetSubscriber,\n   133→      ...(options.delayMs !== undefined &&\n   134→        options.delayMs > 0 && {\n   135→          scheduledFor: new Date(Date.now() + options.delayMs).toISOString(),\n   136→        }),\n   137→      // Processing state\n   138→      attempts: 1,\n   139→      createdAt: now,\n   140→      // Observability\n   141→      importance: options.importance,\n   142→      ...(options.correlationId !== undefined && {\n   143→        correlationId: options.correlationId,\n   144→      }),\n   145→      ...(mergedMetadata !== undefined && { metadata: mergedMetadata }),\n   146→    },\n   147→  };\n   148→}\n   149→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T14:26:06.500Z"
        },
        {
          "type": "user",
          "text": "     1→export type { HasDescription } from './has-description.js';\n     2→export { hasDescription } from './has-description.js';\n     3→\n     4→export {\n     5→  DontRetry,\n     6→  DoRetry,\n     7→  EventAssertionError,\n     8→  isAssertionError,\n     9→  isDontRetry,\n    10→  isDoRetry,\n    11→  RetryControlError,\n    12→} from './retry-errors.js';\n    13→\n    14→export {\n    15→  // Base class\n    16→  MatadorError,\n    17→  isMatadorError,\n    18→  // Lifecycle errors\n    19→  NotStartedError,\n    20→  isNotStartedError,\n    21→  ShutdownInProgressError,\n    22→  // Transport errors\n    23→  TransportNotConnectedError,\n    24→  isTransportNotConnectedError,\n    25→  TransportClosedError,\n    26→  TransportSendError,\n    27→  AllTransportsFailedError,\n    28→  DelayedMessagesNotSupportedError,\n    29→  // Schema & configuration errors\n    30→  EventNotRegisteredError,\n    31→  isEventNotRegisteredError,\n    32→  SubscriberNotRegisteredError,\n    33→  isSubscriberNotRegisteredError,\n    34→  NoSubscribersExistError,\n    35→  InvalidSchemaError,\n    36→  SubscriberIsStubError,\n    37→  LocalTransportCannotProcessStubError,\n    38→  // Queue errors\n    39→  QueueNotFoundError,\n    40→  // Event validation errors\n    41→  InvalidEventError,\n    42→  // Message processing errors\n    43→  MessageMaybePoisonedError,\n    44→  isMessageMaybePoisonedError,\n    45→  IdempotentMessageCannotRetryError,\n    46→  isIdempotentMessageCannotRetryError,\n    47→  // Timeout errors\n    48→  TimeoutError,\n    49→} from './matador-errors.js';\n    50→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T14:26:06.500Z"
        },
        {
          "type": "assistant",
          "text": "Let me also read the existing errors file to understand the error pattern, and also examine the index files and matador config:",
          "timestamp": "2025-12-11T14:26:12.580Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/errors/matador-errors.ts"
          },
          "timestamp": "2025-12-11T14:26:14.194Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/core/matador.ts"
          },
          "timestamp": "2025-12-11T14:26:15.036Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/retry/standard-policy.ts"
          },
          "timestamp": "2025-12-11T14:26:16.136Z"
        },
        {
          "type": "user",
          "text": "     1→/**\n     2→ * Base class for all Matador errors.\n     3→ * All errors have a unique name that appears in monitoring tools (e.g., DataDog)\n     4→ * and a description explaining the error and actions to resolve it.\n     5→ *\n     6→ * The `name` property is automatically set to the class name for proper\n     7→ * identification in error monitoring and logging systems.\n     8→ */\n     9→export abstract class MatadorError extends Error {\n    10→  /**\n    11→   * Error class name (e.g., \"NotStartedError\", \"TransportNotConnectedError\").\n    12→   * This is preserved during serialization for error monitoring tools.\n    13→   */\n    14→  declare readonly name: string;\n    15→\n    16→  /**\n    17→   * Human-readable description explaining what went wrong and\n    18→   * what ACTION the user should take to resolve the issue.\n    19→   */\n    20→  abstract readonly description: string;\n    21→\n    22→  constructor(message: string) {\n    23→    super(message);\n    24→    this.name = this.constructor.name;\n    25→    // Ensure name is preserved when serialized\n    26→    Object.defineProperty(this, 'name', {\n    27→      value: this.constructor.name,\n    28→      enumerable: true,\n    29→      configurable: false,\n    30→      writable: false,\n    31→    });\n    32→  }\n    33→\n    34→  /**\n    35→   * Returns a serializable representation for logging/monitoring.\n    36→   */\n    37→  toJSON(): Record<string, unknown> {\n    38→    return {\n    39→      name: this.name,\n    40→      message: this.message,\n    41→      description: this.description,\n    42→      stack: this.stack,\n    43→    };\n    44→  }\n    45→}\n    46→\n    47→// ============================================================================\n    48→// Lifecycle Errors\n    49→// ============================================================================\n    50→\n    51→/**\n    52→ * Thrown when attempting to use Matador before calling start().\n    53→ */\n    54→export class NotStartedError extends MatadorError {\n    55→  readonly description =\n    56→    'Matador has not been started. ' +\n    57→    'ACTION: Call matador.start() before dispatching events or performing other operations. ' +\n    58→    'Ensure start() completes successfully before using other methods.';\n    59→\n    60→  constructor(operation = 'operation') {\n    61→    super(\n    62→      `Cannot perform ${operation}: Matador has not been started. Call start() first.`,\n    63→    );\n    64→  }\n    65→}\n    66→\n    67→/**\n    68→ * Thrown when attempting to dispatch events during shutdown.\n    69→ */\n    70→export class ShutdownInProgressError extends MatadorError {\n    71→  readonly description =\n    72→    'Matador is shutting down and will not accept new events. ' +\n    73→    'ACTION: Do not dispatch events after calling shutdown(). ' +\n    74→    'If you need to send events, do so before initiating shutdown. ' +\n    75→    'Consider implementing a pre-shutdown event flush if needed.';\n    76→\n    77→  constructor() {\n    78→    super('Cannot dispatch events: Matador is shutting down.');\n    79→  }\n    80→}\n    81→\n    82→// ============================================================================\n    83→// Transport Errors\n    84→// ============================================================================\n    85→\n    86→/**\n    87→ * Thrown when a transport operation is attempted but the transport is not connected.\n    88→ */\n    89→export class TransportNotConnectedError extends MatadorError {\n    90→  readonly description =\n    91→    'The transport is not connected to the message broker. ' +\n    92→    'ACTION: Ensure the transport is connected by calling transport.connect() or matador.start(). ' +\n    93→    'Check that the broker (e.g., RabbitMQ) is running and accessible. ' +\n    94→    'Verify connection settings (URL, credentials, network access).';\n    95→\n    96→  constructor(\n    97→    public readonly transportName: string,\n    98→    operation = 'operation',\n    99→  ) {\n   100→    super(\n   101→      `Cannot perform ${operation}: Transport \"${transportName}\" is not connected. ` +\n   102→        `Ensure connect() was called and the broker is accessible.`,\n   103→    );\n   104→  }\n   105→}\n   106→\n   107→/**\n   108→ * Thrown when the transport has been closed (during shutdown).\n   109→ */\n   110→export class TransportClosedError extends MatadorError {\n   111→  readonly description =\n   112→    'The transport has been closed and will not accept new operations. ' +\n   113→    'ACTION: This typically occurs during application shutdown. ' +\n   114→    'If unexpected, check for early shutdown triggers. ' +\n   115→    'Events sent after transport closure will be lost.';\n   116→\n   117→  constructor(public readonly transportName: string) {\n   118→    super(\n   119→      `Transport \"${transportName}\" has been closed and will not accept new operations.`,\n   120→    );\n   121→  }\n   122→}\n   123→\n   124→/**\n   125→ * Thrown when all transports in a fallback chain fail.\n   126→ */\n   127→export class AllTransportsFailedError extends MatadorError {\n   128→  readonly description =\n   129→    'All transports failed to send the message. ' +\n   130→    'ACTION: Check the health of all configured transports (primary and fallbacks). ' +\n   131→    'Review the errors array for specific failure reasons. ' +\n   132→    'Ensure at least one transport is properly configured and reachable. ' +\n   133→    'Consider adding a LocalTransport as a last-resort fallback.';\n   134→\n   135→  constructor(\n   136→    public readonly queue: string,\n   137→    public readonly errors: readonly Error[],\n   138→  ) {\n   139→    super(\n   140→      `All transports failed to send message to queue \"${queue}\". ` +\n   141→        `Errors: ${errors.map((e) => e.message).join('; ')}`,\n   142→    );\n   143→  }\n   144→}\n   145→\n   146→/**\n   147→ * Thrown when sending a message to the transport fails.\n   148→ */\n   149→export class TransportSendError extends MatadorError {\n   150→  readonly description =\n   151→    'Failed to send a message through the transport. ' +\n   152→    'ACTION: Check the underlying error for details. Common causes: ' +\n   153→    '(1) Transport disconnected during send, ' +\n   154→    '(2) Network issues between application and broker, ' +\n   155→    '(3) Broker rejected the message (size, permissions, queue limits). ' +\n   156→    'The message was NOT delivered and should be retried or logged.';\n   157→\n   158→  constructor(\n   159→    public readonly queue: string,\n   160→    public readonly cause: Error,\n   161→  ) {\n   162→    super(`Failed to send message to queue \"${queue}\": ${cause.message}`);\n   163→  }\n   164→\n   165→  override toJSON(): Record<string, unknown> {\n   166→    return {\n   167→      ...super.toJSON(),\n   168→      queue: this.queue,\n   169→      cause: {\n   170→        name: this.cause.name,\n   171→        message: this.cause.message,\n   172→      },\n   173→    };\n   174→  }\n   175→}\n   176→\n   177→/**\n   178→ * Thrown when delayed messages are requested but the plugin is not available.\n   179→ */\n   180→export class DelayedMessagesNotSupportedError extends MatadorError {\n   181→  readonly description =\n   182→    'Delayed messages were requested but the transport does not support them. ' +\n   183→    'ACTION: For RabbitMQ, install the rabbitmq_delayed_message_exchange plugin. ' +\n   184→    'Run: rabbitmq-plugins enable rabbitmq_delayed_message_exchange ' +\n   185→    'Then restart RabbitMQ and reconnect. ' +\n   186→    'Alternatively, remove delayMs from your event options if delays are not required.';\n   187→\n   188→  constructor(public readonly transportName: string) {\n   189→    super(\n   190→      `Delayed messages require the RabbitMQ delayed message exchange plugin. ` +\n   191→        `Install rabbitmq_delayed_message_exchange or remove delayMs from event options.`,\n   192→    );\n   193→  }\n   194→}\n   195→\n   196→// ============================================================================\n   197→// Schema & Configuration Errors\n   198→// ============================================================================\n   199→\n   200→/**\n   201→ * Thrown when an event is not registered in the schema.\n   202→ */\n   203→export class EventNotRegisteredError extends MatadorError {\n   204→  readonly description =\n   205→    'The event type is not registered in the schema. ' +\n   206→    'ACTION: Register the event using matador.register(EventClass, subscribers) before dispatching. ' +\n   207→    'If this occurs during message consumption, it may indicate schema drift between services. ' +\n   208→    'Ensure all services have matching schema registrations for shared events.';\n   209→\n   210→  constructor(public readonly eventKey: string) {\n   211→    super(\n   212→      `Event \"${eventKey}\" is not registered in schema. ` +\n   213→        `Register it using matador.register(EventClass, subscribers).`,\n   214→    );\n   215→  }\n   216→}\n   217→\n   218→/**\n   219→ * Thrown when a subscriber is not found for an event.\n   220→ */\n   221→export class SubscriberNotRegisteredError extends MatadorError {\n   222→  readonly description =\n   223→    'The subscriber is not registered for this event in the schema. ' +\n   224→    'ACTION: Ensure the subscriber is included in the registration for this event. ' +\n   225→    'This may occur if: (1) The subscriber was removed from the schema but messages still exist, ' +\n   226→    '(2) Schema drift between producer and consumer services, ' +\n   227→    '(3) A deployment is in progress with different schema versions. ' +\n   228→    'Check the dead-letter queue for affected messages.';\n   229→\n   230→  constructor(\n   231→    public readonly subscriberName: string,\n   232→    public readonly eventKey?: string,\n   233→  ) {\n   234→    super(\n   235→      `Subscriber \"${subscriberName}\" is not registered` +\n   236→        (eventKey ? ` for event \"${eventKey}\"` : '') +\n   237→        '. Check schema registration.',\n   238→    );\n   239→  }\n   240→}\n   241→\n   242→/**\n   243→ * Thrown when no subscribers exist for an event during fanout.\n   244→ */\n   245→export class NoSubscribersExistError extends MatadorError {\n   246→  readonly description =\n   247→    'The event has no subscribers registered. ' +\n   248→    'ACTION: Register at least one subscriber for this event type. ' +\n   249→    'If subscribers were intentionally removed, consider also removing the event dispatch. ' +\n   250→    'Events without subscribers are not useful and may indicate configuration issues.';\n   251→\n   252→  constructor(public readonly eventKey: string) {\n   253→    super(\n   254→      `No subscribers registered for event \"${eventKey}\". ` +\n   255→        `Add subscribers using matador.register(EventClass, [subscriber1, subscriber2]).`,\n   256→    );\n   257→  }\n   258→}\n   259→\n   260→/**\n   261→ * Thrown when the schema configuration is invalid.\n   262→ */\n   263→export class InvalidSchemaError extends MatadorError {\n   264→  readonly description =\n   265→    'The schema configuration is invalid. ' +\n   266→    'ACTION: Review the schema registration for issues. Common problems: ' +\n   267→    '(1) Duplicate subscriber names for the same event, ' +\n   268→    '(2) Missing required fields on event class (key, description), ' +\n   269→    '(3) Invalid alias configuration. ' +\n   270→    'Check the cause property for specific details.';\n   271→\n   272→  constructor(\n   273→    message: string,\n   274→    public readonly cause?: string,\n   275→  ) {\n   276→    super(`Invalid schema: ${message}` + (cause ? `. Cause: ${cause}` : ''));\n   277→  }\n   278→}\n   279→\n   280→/**\n   281→ * Thrown when a subscriber is a stub but is being processed locally.\n   282→ */\n   283→export class SubscriberIsStubError extends MatadorError {\n   284→  readonly description =\n   285→    'A SubscriberStub was registered in a consuming schema. ' +\n   286→    'ACTION: SubscriberStubs should only be used in producer schemas to declare ' +\n   287→    'that a subscriber exists in another service. ' +\n   288→    'In the consumer service, provide a full Subscriber with a callback function. ' +\n   289→    'Remove the stub from the consumer schema and add the actual implementation.';\n   290→\n   291→  constructor(public readonly subscriberName: string) {\n   292→    super(\n   293→      `Subscriber \"${subscriberName}\" is a stub and cannot be processed locally. ` +\n   294→        `Replace with a full Subscriber implementation in the consumer schema.`,\n   295→    );\n   296→  }\n   297→}\n   298→\n   299→/**\n   300→ * Thrown when a LocalTransport tries to process a stub subscriber.\n   301→ */\n   302→export class LocalTransportCannotProcessStubError extends MatadorError {\n   303→  readonly description =\n   304→    'The LocalTransport cannot process events for SubscriberStubs. ' +\n   305→    'ACTION: SubscriberStubs represent remote implementations that only RabbitMQ can route. ' +\n   306→    'If using LocalTransport for testing, provide mock implementations instead of stubs. ' +\n   307→    'For production fallback scenarios, be aware that stub-targeted events will be dropped.';\n   308→\n   309→  constructor(public readonly subscriberName: string) {\n   310→    super(\n   311→      `LocalTransport cannot process stub subscriber \"${subscriberName}\". ` +\n   312→        `Stub subscribers require a distributed transport like RabbitMQ.`,\n   313→    );\n   314→  }\n   315→}\n   316→\n   317→// ============================================================================\n   318→// Queue Errors\n   319→// ============================================================================\n   320→\n   321→/**\n   322→ * Thrown when a queue is not found or not created.\n   323→ */\n   324→export class QueueNotFoundError extends MatadorError {\n   325→  readonly description =\n   326→    'The specified queue does not exist or has not been created. ' +\n   327→    'ACTION: Ensure the queue is defined in the topology configuration. ' +\n   328→    'Call transport.applyTopology() or matador.start() to create queues. ' +\n   329→    'Check that the queue name matches the topology definition.';\n   330→\n   331→  constructor(public readonly queueName: string) {\n   332→    super(\n   333→      `Queue \"${queueName}\" not found. ` +\n   334→        `Ensure it is defined in topology and applyTopology() was called.`,\n   335→    );\n   336→  }\n   337→}\n   338→\n   339→// ============================================================================\n   340→// Event Validation Errors\n   341→// ============================================================================\n   342→\n   343→/**\n   344→ * Thrown when an event is invalid or malformed.\n   345→ */\n   346→export class InvalidEventError extends MatadorError {\n   347→  readonly description =\n   348→    'The event is invalid or missing required fields. ' +\n   349→    'ACTION: Ensure the event has all required properties. ' +\n   350→    'Common issues: missing targetSubscriber during processing, ' +\n   351→    'null/undefined data when the event type requires data, ' +\n   352→    'malformed event structure from codec decode failure.';\n   353→\n   354→  constructor(\n   355→    message: string,\n   356→    public readonly cause?: string,\n   357→  ) {\n   358→    super(`Invalid event: ${message}` + (cause ? `. Cause: ${cause}` : ''));\n   359→  }\n   360→}\n   361→\n   362→// ============================================================================\n   363→// Message Processing Errors\n   364→// ============================================================================\n   365→\n   366→/**\n   367→ * Thrown when a message has been redelivered too many times (poison message).\n   368→ */\n   369→export class MessageMaybePoisonedError extends MatadorError {\n   370→  readonly description =\n   371→    'A message was redelivered multiple times without successful processing. ' +\n   372→    'This usually indicates the message causes a crash or timeout during processing. ' +\n   373→    'ACTION: (1) Check application logs for errors/crashes during message processing, ' +\n   374→    '(2) Inspect the message in the dead-letter queue for malformed data, ' +\n   375→    '(3) Review the subscriber code for bugs that cause crashes, ' +\n   376→    '(4) Consider increasing processing timeout if the operation is legitimately slow. ' +\n   377→    'This message will NOT be retried to prevent crash loops.';\n   378→\n   379→  constructor(\n   380→    public readonly eventId: string,\n   381→    public readonly deliveryCount: number,\n   382→    public readonly maxDeliveries: number,\n   383→  ) {\n   384→    super(\n   385→      `Message \"${eventId}\" delivered ${deliveryCount} times (max: ${maxDeliveries}). ` +\n   386→        `Possible poison message - will not be retried.`,\n   387→    );\n   388→  }\n   389→}\n   390→\n   391→/**\n   392→ * Thrown when a non-idempotent message cannot be retried after redelivery.\n   393→ */\n   394→export class IdempotentMessageCannotRetryError extends MatadorError {\n   395→  readonly description =\n   396→    'A non-idempotent subscriber received a redelivered message. ' +\n   397→    'Retrying would risk duplicate side effects (e.g., double payments, duplicate emails). ' +\n   398→    'ACTION: (1) Mark the subscriber as idempotent if it safely handles duplicates, ' +\n   399→    '(2) Implement idempotency keys in the subscriber logic, ' +\n   400→    '(3) Manually inspect and replay the message from the dead-letter queue after verification. ' +\n   401→    'The message will be sent to the dead-letter queue for manual review.';\n   402→\n   403→  constructor(\n   404→    public readonly eventId: string,\n   405→    public readonly subscriberName: string,\n   406→  ) {\n   407→    super(\n   408→      `Non-idempotent subscriber \"${subscriberName}\" cannot retry redelivered message \"${eventId}\". ` +\n   409→        `Mark subscriber as idempotent='yes' or implement idempotency handling.`,\n   410→    );\n   411→  }\n   412→}\n   413→\n   414→// ============================================================================\n   415→// Timeout Errors\n   416→// ============================================================================\n   417→\n   418→/**\n   419→ * Thrown when an operation times out.\n   420→ */\n   421→export class TimeoutError extends MatadorError {\n   422→  readonly description =\n   423→    'An operation timed out before completing. ' +\n   424→    'ACTION: (1) Increase the timeout if the operation legitimately needs more time, ' +\n   425→    '(2) Optimize the operation to complete faster, ' +\n   426→    '(3) Check for deadlocks or blocking operations, ' +\n   427→    '(4) Verify external service dependencies are responsive.';\n   428→\n   429→  constructor(\n   430→    public readonly operation: string,\n   431→    public readonly timeoutMs: number,\n   432→  ) {\n   433→    super(`Operation \"${operation}\" timed out after ${timeoutMs}ms.`);\n   434→  }\n   435→}\n   436→\n   437→// ============================================================================\n   438→// Type Guards\n   439→// ============================================================================\n   440→\n   441→export function isMatadorError(error: unknown): error is MatadorError {\n   442→  return error instanceof MatadorError;\n   443→}\n   444→\n   445→export function isNotStartedError(error: unknown): error is NotStartedError {\n   446→  return error instanceof NotStartedError;\n   447→}\n   448→\n   449→export function isTransportNotConnectedError(\n   450→  error: unknown,\n   451→): error is TransportNotConnectedError {\n   452→  return error instanceof TransportNotConnectedError;\n   453→}\n   454→\n   455→export function isEventNotRegisteredError(\n   456→  error: unknown,\n   457→): error is EventNotRegisteredError {\n   458→  return error instanceof EventNotRegisteredError;\n   459→}\n   460→\n   461→export function isSubscriberNotRegisteredError(\n   462→  error: unknown,\n   463→): error is SubscriberNotRegisteredError {\n   464→  return error instanceof SubscriberNotRegisteredError;\n   465→}\n   466→\n   467→export function isMessageMaybePoisonedError(\n   468→  error: unknown,\n   469→): error is MessageMaybePoisonedError {\n   470→  return error instanceof MessageMaybePoisonedError;\n   471→}\n   472→\n   473→export function isIdempotentMessageCannotRetryError(\n   474→  error: unknown,\n   475→): error is IdempotentMessageCannotRetryError {\n   476→  return error instanceof IdempotentMessageCannotRetryError;\n   477→}\n   478→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T14:26:16.360Z"
        },
        {
          "type": "user",
          "text": "     1→import type { Codec } from '../codec/index.js';\n     2→import { JsonCodec } from '../codec/index.js';\n     3→import {\n     4→  InvalidSchemaError,\n     5→  NotStartedError,\n     6→  ShutdownInProgressError,\n     7→} from '../errors/index.js';\n     8→import type { MatadorHooks } from '../hooks/index.js';\n     9→import { SafeHooks } from '../hooks/index.js';\n    10→import { ProcessingPipeline } from '../pipeline/index.js';\n    11→import type { RetryPolicy } from '../retry/index.js';\n    12→import { StandardRetryPolicy } from '../retry/index.js';\n    13→import type { MatadorSchema } from '../schema/index.js';\n    14→import { SchemaRegistry, isSchemaEntryTuple } from '../schema/index.js';\n    15→import type { Topology } from '../topology/index.js';\n    16→import { getQualifiedQueueName } from '../topology/index.js';\n    17→import type { Subscription, Transport } from '../transport/index.js';\n    18→import type {\n    19→  AnySubscriber,\n    20→  Event,\n    21→  EventClass,\n    22→  EventOptions,\n    23→} from '../types/index.js';\n    24→import type { SendResult } from './fanout.js';\n    25→import { FanoutEngine } from './fanout.js';\n    26→import type { HandlersState, ShutdownConfig } from './shutdown.js';\n    27→import { ShutdownManager } from './shutdown.js';\n    28→\n    29→/**\n    30→ * Configuration for Matador.\n    31→ */\n    32→export interface MatadorConfig {\n    33→  /** Transport for message delivery */\n    34→  readonly transport: Transport;\n    35→\n    36→  /** Topology configuration */\n    37→  readonly topology: Topology;\n    38→\n    39→  /** Event schema mapping event keys to event classes and subscribers */\n    40→  readonly schema: MatadorSchema;\n    41→\n    42→  /** Queues to consume from (empty = no consumption) */\n    43→  readonly consumeFrom?: readonly string[] | undefined;\n    44→\n    45→  /** Custom codec (defaults to JSON) */\n    46→  readonly codec?: Codec | undefined;\n    47→\n    48→  /** Custom retry policy */\n    49→  readonly retryPolicy?: RetryPolicy | undefined;\n    50→\n    51→  /** Shutdown configuration */\n    52→  readonly shutdownConfig?: Partial<ShutdownConfig> | undefined;\n    53→}\n    54→\n    55→/**\n    56→ * Matador - Transport-agnostic event processing library.\n    57→ *\n    58→ * Main orchestrator that wires together:\n    59→ * - Transport: Message delivery\n    60→ * - Schema: Event-subscriber registry\n    61→ * - Pipeline: Message processing\n    62→ * - Fanout: Event sending\n    63→ * - Shutdown: Graceful termination\n    64→ */\n    65→export class Matador {\n    66→  private readonly transport: Transport;\n    67→  private readonly topology: Topology;\n    68→  private readonly schema;\n    69→  private readonly codec: Codec;\n    70→  private readonly retryPolicy: RetryPolicy;\n    71→  private readonly hooks;\n    72→  private readonly pipeline;\n    73→  private readonly fanout;\n    74→  private readonly shutdownManager;\n    75→  private readonly consumeFrom: readonly string[];\n    76→  private readonly subscriptions: Subscription[] = [];\n    77→  private started = false;\n    78→\n    79→  /**\n    80→   * Creates a new Matador instance.\n    81→   *\n    82→   * @param config - Static configuration (transport, topology, schema, etc.)\n    83→   * @param hooks - Lifecycle hooks for logging, monitoring, and dynamic configuration.\n    84→   *                Passed separately to support NestJS dependency injection.\n    85→   */\n    86→  constructor(config: MatadorConfig, hooks?: MatadorHooks) {\n    87→    this.transport = config.transport;\n    88→    this.topology = config.topology;\n    89→    this.consumeFrom = config.consumeFrom ?? [];\n    90→\n    91→    // Initialize components\n    92→    this.schema = new SchemaRegistry();\n    93→    this.codec = config.codec ?? new JsonCodec();\n    94→    this.retryPolicy = config.retryPolicy ?? new StandardRetryPolicy();\n    95→    this.hooks = new SafeHooks(hooks);\n    96→\n    97→    // Register schema from config\n    98→    this.registerSchema(config.schema);\n    99→\n   100→    // Create pipeline\n   101→    this.pipeline = new ProcessingPipeline({\n   102→      transport: this.transport,\n   103→      schema: this.schema,\n   104→      codec: this.codec,\n   105→      retryPolicy: this.retryPolicy,\n   106→      hooks: this.hooks,\n   107→    });\n   108→\n   109→    // Create fanout engine\n   110→    const defaultQueue = this.topology.queues[0]?.name ?? 'default';\n   111→    this.fanout = new FanoutEngine({\n   112→      transport: this.transport,\n   113→      schema: this.schema,\n   114→      hooks: this.hooks,\n   115→      namespace: this.topology.namespace,\n   116→      defaultQueue,\n   117→    });\n   118→\n   119→    // Create shutdown manager\n   120→    this.shutdownManager = new ShutdownManager(\n   121→      () => this.fanout.eventsBeingEnqueuedCount,\n   122→      () => this.stopReceiving(),\n   123→      () => this.transport.disconnect(),\n   124→      config.shutdownConfig,\n   125→    );\n   126→  }\n   127→\n   128→  /**\n   129→   * Registers an event class with its subscribers.\n   130→   */\n   131→  register<T>(\n   132→    eventClass: EventClass<T>,\n   133→    subscribers: readonly AnySubscriber[],\n   134→  ): this {\n   135→    this.schema.register(eventClass, subscribers);\n   136→    return this;\n   137→  }\n   138→\n   139→  /**\n   140→   * Registers events from a schema object.\n   141→   * Supports both object format and tuple format entries.\n   142→   *\n   143→   * @example\n   144→   * ```typescript\n   145→   * // Tuple format\n   146→   * matador.registerSchema({\n   147→   *   [UserCreatedEvent.key]: [UserCreatedEvent, [emailSubscriber]],\n   148→   *   [OrderPlacedEvent.key]: [OrderPlacedEvent, [invoiceSubscriber]],\n   149→   * });\n   150→   *\n   151→   * // Object format\n   152→   * matador.registerSchema({\n   153→   *   [UserCreatedEvent.key]: { eventClass: UserCreatedEvent, subscribers: [emailSubscriber] },\n   154→   * });\n   155→   * ```\n   156→   */\n   157→  registerSchema(schema: MatadorSchema): this {\n   158→    for (const entry of Object.values(schema)) {\n   159→      if (isSchemaEntryTuple(entry)) {\n   160→        // Tuple format: [EventClass, Subscriber[]]\n   161→        const [eventClass, subscribers] = entry;\n   162→        this.schema.register(eventClass, subscribers);\n   163→      } else {\n   164→        // Object format: { eventClass, subscribers }\n   165→        this.schema.register(entry.eventClass, entry.subscribers);\n   166→      }\n   167→    }\n   168→    return this;\n   169→  }\n   170→\n   171→  /**\n   172→   * Starts Matador - connects transport and begins consuming.\n   173→   * This method is idempotent - calling it multiple times is safe.\n   174→   */\n   175→  async start(): Promise<void> {\n   176→    // Idempotent: if already started, just return\n   177→    if (this.started) {\n   178→      return;\n   179→    }\n   180→\n   181→    // Validate schema\n   182→    const validation = this.schema.validate();\n   183→    if (!validation.valid) {\n   184→      const errors = validation.issues.filter((i) => i.severity === 'error');\n   185→      throw new InvalidSchemaError(\n   186→        'Schema validation failed',\n   187→        errors.map((e) => e.message).join(', '),\n   188→      );\n   189→    }\n   190→\n   191→    // Connect transport\n   192→    await this.transport.connect();\n   193→\n   194→    // Apply topology\n   195→    await this.transport.applyTopology(this.topology);\n   196→\n   197→    // Subscribe to queues\n   198→    for (const queueName of this.consumeFrom) {\n   199→      const qualifiedName = getQualifiedQueueName(\n   200→        this.topology.namespace,\n   201→        queueName,\n   202→      );\n   203→      const queueDef = this.topology.queues.find((q) => q.name === queueName);\n   204→\n   205→      const subscription = await this.transport.subscribe(\n   206→        qualifiedName,\n   207→        async (envelope, receipt) => {\n   208→          this.shutdownManager.incrementProcessing();\n   209→          try {\n   210→            const rawMessage = this.codec.encode(envelope);\n   211→            await this.pipeline.process(rawMessage, receipt);\n   212→          } finally {\n   213→            this.shutdownManager.decrementProcessing();\n   214→          }\n   215→        },\n   216→        queueDef?.concurrency !== undefined\n   217→          ? { concurrency: queueDef.concurrency }\n   218→          : undefined,\n   219→      );\n   220→\n   221→      this.subscriptions.push(subscription);\n   222→    }\n   223→\n   224→    this.started = true;\n   225→  }\n   226→\n   227→  /**\n   228→   * Sends an event to all registered subscribers.\n   229→   *\n   230→   * @example\n   231→   * ```typescript\n   232→   * // Pass the event class and data directly\n   233→   * await matador.send(UserCreatedEvent, { userId: '123' });\n   234→   *\n   235→   * // Or pass an event instance\n   236→   * const event = new UserCreatedEvent({ userId: '123' });\n   237→   * await matador.send(event);\n   238→   * ```\n   239→   */\n   240→  async send<T>(\n   241→    eventClass: EventClass<T>,\n   242→    data: T,\n   243→    options?: EventOptions,\n   244→  ): Promise<SendResult>;\n   245→  async send<T>(event: Event<T>, options?: EventOptions): Promise<SendResult>;\n   246→  async send<T>(\n   247→    eventOrClass: Event<T> | EventClass<T>,\n   248→    dataOrOptions?: T | EventOptions,\n   249→    maybeOptions?: EventOptions,\n   250→  ): Promise<SendResult> {\n   251→    if (!this.started) {\n   252→      throw new NotStartedError('send');\n   253→    }\n   254→\n   255→    if (!this.shutdownManager.isEnqueueAllowed) {\n   256→      throw new ShutdownInProgressError();\n   257→    }\n   258→\n   259→    // Determine if first arg is an event instance or event class\n   260→    const isEventClass =\n   261→      typeof eventOrClass === 'function' && 'key' in eventOrClass;\n   262→\n   263→    if (isEventClass) {\n   264→      // Called as: send(EventClass, data, options?)\n   265→      const eventClass = eventOrClass as EventClass<T>;\n   266→      const data = dataOrOptions as T;\n   267→      const options = maybeOptions;\n   268→      const event = new eventClass(data);\n   269→      return this.fanout.send(eventClass, event, options);\n   270→    } else {\n   271→      // Called as: send(event, options?)\n   272→      const event = eventOrClass as Event<T>;\n   273→      const options = dataOrOptions as EventOptions | undefined;\n   274→      const eventClass = event.constructor as EventClass<T>;\n   275→      return this.fanout.send(eventClass, event, options);\n   276→    }\n   277→  }\n   278→\n   279→  /**\n   280→   * Gets current handler state.\n   281→   */\n   282→  getHandlersState(): HandlersState {\n   283→    return this.shutdownManager.getHandlersState();\n   284→  }\n   285→\n   286→  /**\n   287→   * Checks if Matador is idle (no processing or enqueuing).\n   288→   */\n   289→  isIdle(): boolean {\n   290→    return this.shutdownManager.getHandlersState().isIdle;\n   291→  }\n   292→\n   293→  /**\n   294→   * Waits for all handlers to become idle.\n   295→   */\n   296→  async waitForIdle(timeoutMs = 30000): Promise<boolean> {\n   297→    const deadline = Date.now() + timeoutMs;\n   298→\n   299→    while (!this.isIdle()) {\n   300→      if (Date.now() > deadline) {\n   301→        return false;\n   302→      }\n   303→      await new Promise((resolve) => setTimeout(resolve, 100));\n   304→    }\n   305→\n   306→    return true;\n   307→  }\n   308→\n   309→  /**\n   310→   * Gracefully shuts down Matador.\n   311→   */\n   312→  async shutdown(): Promise<void> {\n   313→    if (!this.started) {\n   314→      return;\n   315→    }\n   316→\n   317→    await this.shutdownManager.shutdown();\n   318→    this.started = false;\n   319→  }\n   320→\n   321→  /**\n   322→   * Checks if transport is connected.\n   323→   */\n   324→  isConnected(): boolean {\n   325→    return this.transport.isConnected();\n   326→  }\n   327→\n   328→  private async stopReceiving(): Promise<void> {\n   329→    for (const subscription of this.subscriptions) {\n   330→      await subscription.unsubscribe();\n   331→    }\n   332→    this.subscriptions.length = 0;\n   333→  }\n   334→}\n   335→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T14:26:16.360Z"
        },
        {
          "type": "user",
          "text": "     1→import {\n     2→  IdempotentMessageCannotRetryError,\n     3→  MessageMaybePoisonedError,\n     4→  isAssertionError,\n     5→  isDoRetry,\n     6→  isDontRetry,\n     7→} from '../errors/index.js';\n     8→import type { RetryContext, RetryDecision, RetryPolicy } from './policy.js';\n     9→\n    10→/**\n    11→ * Configuration for the standard retry policy.\n    12→ */\n    13→export interface StandardRetryPolicyConfig {\n    14→  /** Maximum number of attempts before dead-lettering */\n    15→  readonly maxAttempts: number;\n    16→\n    17→  /** Base delay between retries in milliseconds */\n    18→  readonly baseDelay: number;\n    19→\n    20→  /** Maximum delay between retries in milliseconds */\n    21→  readonly maxDelay: number;\n    22→\n    23→  /** Multiplier for exponential backoff */\n    24→  readonly backoffMultiplier: number;\n    25→\n    26→  /**\n    27→   * Maximum native delivery count before considering message poisoned.\n    28→   * This prevents crash loops from messages that crash the worker.\n    29→   * Poison messages are sent directly to the dead-letter queue.\n    30→   * Default: 5\n    31→   */\n    32→  readonly maxDeliveries: number;\n    33→}\n    34→\n    35→/**\n    36→ * Default configuration values.\n    37→ */\n    38→export const defaultRetryConfig: StandardRetryPolicyConfig = {\n    39→  maxAttempts: 3,\n    40→  baseDelay: 1000,\n    41→  maxDelay: 300000, // 5 minutes\n    42→  backoffMultiplier: 2,\n    43→  maxDeliveries: 5,\n    44→};\n    45→\n    46→/**\n    47→ * Standard retry policy implementing Matador v1 behavior.\n    48→ *\n    49→ * Decision logic (in priority order):\n    50→ * 1. Poison message → dead-letter (prevent crash loops)\n    51→ * 2. EventAssertionError → dead-letter (never retry)\n    52→ * 3. DontRetry → dead-letter (explicit no-retry)\n    53→ * 4. DoRetry → retry if under max attempts\n    54→ * 5. Max attempts exceeded → dead-letter\n    55→ * 6. Non-idempotent subscriber on redelivery → dead-letter\n    56→ * 7. Default → retry with exponential backoff\n    57→ */\n    58→export class StandardRetryPolicy implements RetryPolicy {\n    59→  private readonly config: StandardRetryPolicyConfig;\n    60→\n    61→  constructor(config: Partial<StandardRetryPolicyConfig> = {}) {\n    62→    this.config = { ...defaultRetryConfig, ...config };\n    63→  }\n    64→\n    65→  shouldRetry(context: RetryContext): RetryDecision {\n    66→    const { envelope, error, subscriber, receipt } = context;\n    67→    const errorMessage = error.message;\n    68→\n    69→    // 1. Poison message detection - prevent crash loops\n    70→    if (receipt.deliveryCount >= this.config.maxDeliveries) {\n    71→      const poisonError = new MessageMaybePoisonedError(\n    72→        envelope.id,\n    73→        receipt.deliveryCount,\n    74→        this.config.maxDeliveries,\n    75→      );\n    76→      return {\n    77→        action: 'dead-letter',\n    78→        queue: 'undeliverable',\n    79→        reason: poisonError.message,\n    80→      };\n    81→    }\n    82→\n    83→    // 2. Assertion errors never retry\n    84→    if (isAssertionError(error)) {\n    85→      return {\n    86→        action: 'dead-letter',\n    87→        queue: 'undeliverable',\n    88→        reason: `assertion error: ${errorMessage}`,\n    89→      };\n    90→    }\n    91→\n    92→    // 3. Explicit no-retry\n    93→    if (isDontRetry(error)) {\n    94→      return {\n    95→        action: 'dead-letter',\n    96→        queue: 'undeliverable',\n    97→        reason: errorMessage,\n    98→      };\n    99→    }\n   100→\n   101→    // 4. Explicit retry request\n   102→    if (isDoRetry(error)) {\n   103→      if (receipt.attemptNumber >= this.config.maxAttempts) {\n   104→        return {\n   105→          action: 'dead-letter',\n   106→          queue: 'undeliverable',\n   107→          reason: `max attempts exceeded (${this.config.maxAttempts}) with forced retry`,\n   108→        };\n   109→      }\n   110→      return {\n   111→        action: 'retry',\n   112→        delay: this.getDelay(context),\n   113→      };\n   114→    }\n   115→\n   116→    // 5. Max attempts exceeded\n   117→    if (receipt.attemptNumber >= this.config.maxAttempts) {\n   118→      return {\n   119→        action: 'dead-letter',\n   120→        queue: 'undeliverable',\n   121→        reason: `max attempts exceeded (${this.config.maxAttempts})`,\n   122→      };\n   123→    }\n   124→\n   125→    // 6. Non-idempotent subscriber on redelivery\n   126→    if (receipt.redelivered && subscriber.idempotent === 'no') {\n   127→      const idempotentError = new IdempotentMessageCannotRetryError(\n   128→        envelope.id,\n   129→        subscriber.name,\n   130→      );\n   131→      return {\n   132→        action: 'dead-letter',\n   133→        queue: 'undeliverable',\n   134→        reason: idempotentError.message,\n   135→      };\n   136→    }\n   137→\n   138→    // 7. Default: retry with backoff\n   139→    return {\n   140→      action: 'retry',\n   141→      delay: this.getDelay(context),\n   142→    };\n   143→  }\n   144→\n   145→  getDelay(context: RetryContext): number {\n   146→    const attempt = context.receipt.attemptNumber;\n   147→    const delay =\n   148→      this.config.baseDelay *\n   149→      Math.pow(this.config.backoffMultiplier, attempt - 1);\n   150→    return Math.min(delay, this.config.maxDelay);\n   151→  }\n   152→}\n   153→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T14:26:16.361Z"
        },
        {
          "type": "assistant",
          "text": "Now let me also check the index files and schema registry:",
          "timestamp": "2025-12-11T14:26:20.316Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/types/index.ts"
          },
          "timestamp": "2025-12-11T14:26:20.945Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/schema/registry.ts"
          },
          "timestamp": "2025-12-11T14:26:21.468Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/index.ts"
          },
          "timestamp": "2025-12-11T14:26:21.882Z"
        },
        {
          "type": "user",
          "text": "     1→export type {\n     2→  DeliveryMode,\n     3→  Idempotency,\n     4→  Importance,\n     5→  ValidationError,\n     6→  ValidationResult,\n     7→} from './common.js';\n     8→export { invalidResult, validResult } from './common.js';\n     9→\n    10→export type { CreateEnvelopeOptions, Docket, Envelope } from './envelope.js';\n    11→export { createEnvelope } from './envelope.js';\n    12→\n    13→export type {\n    14→  Event,\n    15→  EventClass,\n    16→  EventData,\n    17→  EventKey,\n    18→  EventOptions,\n    19→  EventStatic,\n    20→  JsonPrimitive,\n    21→  JsonRecord,\n    22→  JsonValue,\n    23→} from './event.js';\n    24→export { MatadorEvent } from './event.js';\n    25→\n    26→export type {\n    27→  AnySubscriber,\n    28→  EnvelopeOf,\n    29→  Subscriber,\n    30→  SubscriberCallback,\n    31→  SubscriberDefinition,\n    32→  SubscriberOptions,\n    33→  SubscriberStub,\n    34→} from './subscriber.js';\n    35→export {\n    36→  createSubscriber,\n    37→  createSubscriberStub,\n    38→  isSubscriber,\n    39→  isSubscriberStub,\n    40→} from './subscriber.js';\n    41→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T14:26:21.991Z"
        },
        {
          "type": "user",
          "text": "     1→import type { HasDescription } from '../errors/index.js';\n     2→import type {\n     3→  AnySubscriber,\n     4→  EventClass,\n     5→  MatadorEvent,\n     6→  Subscriber,\n     7→  SubscriberDefinition,\n     8→} from '../types/index.js';\n     9→import { isSubscriber } from '../types/index.js';\n    10→import type {\n    11→  RegisterOptions,\n    12→  SchemaEntry,\n    13→  SchemaIssue,\n    14→  SchemaValidationResult,\n    15→} from './types.js';\n    16→\n    17→/**\n    18→ * Error thrown when schema operations fail.\n    19→ */\n    20→export class SchemaError extends Error implements HasDescription {\n    21→  readonly description =\n    22→    'A schema operation failed, such as registering a duplicate event or ' +\n    23→    'conflicting alias. This is a configuration error that should be fixed ' +\n    24→    'during development. Review the event and subscriber registrations to ' +\n    25→    'resolve the conflict.';\n    26→\n    27→  constructor(message: string) {\n    28→    super(message);\n    29→    this.name = 'SchemaError';\n    30→  }\n    31→}\n    32→\n    33→/**\n    34→ * Registry for managing event-subscriber relationships.\n    35→ */\n    36→export class SchemaRegistry {\n    37→  private readonly entries = new Map<string, SchemaEntry>();\n    38→  private readonly aliases = new Map<string, string>();\n    39→\n    40→  /**\n    41→   * Registers an event class with its subscribers.\n    42→   */\n    43→  register<T>(\n    44→    eventClass: EventClass<T>,\n    45→    subscribers: readonly AnySubscriber[],\n    46→    options: RegisterOptions = {},\n    47→  ): void {\n    48→    const key = eventClass.key;\n    49→\n    50→    if (this.entries.has(key) && !options.override) {\n    51→      throw new SchemaError(`Event \"${key}\" is already registered`);\n    52→    }\n    53→\n    54→    this.entries.set(key, {\n    55→      eventClass,\n    56→      subscribers,\n    57→    } as SchemaEntry);\n    58→\n    59→    // Register aliases\n    60→    if (eventClass.aliases) {\n    61→      for (const alias of eventClass.aliases) {\n    62→        if (\n    63→          this.aliases.has(alias) &&\n    64→          this.aliases.get(alias) !== key &&\n    65→          !options.override\n    66→        ) {\n    67→          throw new SchemaError(\n    68→            `Alias \"${alias}\" is already registered for event \"${this.aliases.get(alias)}\"`,\n    69→          );\n    70→        }\n    71→        this.aliases.set(alias, key);\n    72→      }\n    73→    }\n    74→  }\n    75→\n    76→  /**\n    77→   * Gets the event class for a given key.\n    78→   */\n    79→  getEventClass(key: string): EventClass | undefined {\n    80→    const entry = this.entries.get(key);\n    81→    if (entry) return entry.eventClass;\n    82→\n    83→    // Check aliases\n    84→    const aliasKey = this.aliases.get(key);\n    85→    if (aliasKey) {\n    86→      return this.entries.get(aliasKey)?.eventClass;\n    87→    }\n    88→\n    89→    return undefined;\n    90→  }\n    91→\n    92→  /**\n    93→   * Gets all subscribers for an event key.\n    94→   */\n    95→  getSubscribers(eventKey: string): readonly AnySubscriber[] {\n    96→    const entry = this.getEntry(eventKey);\n    97→    return entry?.subscribers ?? [];\n    98→  }\n    99→\n   100→  /**\n   101→   * Gets a specific subscriber by event key and subscriber name.\n   102→   */\n   103→  getSubscriber(\n   104→    eventKey: string,\n   105→    subscriberName: string,\n   106→  ): AnySubscriber | undefined {\n   107→    const subscribers = this.getSubscribers(eventKey);\n   108→    return subscribers.find((s) => s.name === subscriberName);\n   109→  }\n   110→\n   111→  /**\n   112→   * Gets a subscriber definition for the pipeline.\n   113→   */\n   114→  getSubscriberDefinition(\n   115→    eventKey: string,\n   116→    subscriberName: string,\n   117→  ): SubscriberDefinition | undefined {\n   118→    const subscriber = this.getSubscriber(eventKey, subscriberName);\n   119→    if (!subscriber) return undefined;\n   120→\n   121→    const def: SubscriberDefinition = {\n   122→      name: subscriber.name,\n   123→      idempotent: subscriber.idempotent ?? 'unknown',\n   124→      importance: subscriber.importance ?? 'should-investigate',\n   125→    };\n   126→\n   127→    if (subscriber.targetQueue !== undefined) {\n   128→      (def as { targetQueue?: string }).targetQueue = subscriber.targetQueue;\n   129→    }\n   130→\n   131→    return def;\n   132→  }\n   133→\n   134→  /**\n   135→   * Gets a subscriber with callback for execution.\n   136→   */\n   137→  getExecutableSubscriber(\n   138→    eventKey: string,\n   139→    subscriberName: string,\n   140→  ): Subscriber<MatadorEvent<unknown>> | undefined {\n   141→    const subscriber = this.getSubscriber(eventKey, subscriberName);\n   142→    if (!subscriber || !isSubscriber(subscriber)) return undefined;\n   143→    return subscriber;\n   144→  }\n   145→\n   146→  /**\n   147→   * Gets the event class by alias.\n   148→   */\n   149→  getEventByAlias(alias: string): EventClass | undefined {\n   150→    const key = this.aliases.get(alias);\n   151→    if (!key) return undefined;\n   152→    return this.entries.get(key)?.eventClass;\n   153→  }\n   154→\n   155→  /**\n   156→   * Checks if an event key is registered.\n   157→   */\n   158→  hasEvent(key: string): boolean {\n   159→    return this.entries.has(key) || this.aliases.has(key);\n   160→  }\n   161→\n   162→  /**\n   163→   * Gets all registered event keys.\n   164→   */\n   165→  getEventKeys(): readonly string[] {\n   166→    return [...this.entries.keys()];\n   167→  }\n   168→\n   169→  /**\n   170→   * Validates the schema for issues.\n   171→   */\n   172→  validate(): SchemaValidationResult {\n   173→    const issues: SchemaIssue[] = [];\n   174→\n   175→    for (const [key, entry] of this.entries) {\n   176→      // Check for duplicate subscriber names\n   177→      const names = new Set<string>();\n   178→      for (const subscriber of entry.subscribers) {\n   179→        if (names.has(subscriber.name)) {\n   180→          issues.push({\n   181→            severity: 'error',\n   182→            eventKey: key,\n   183→            message: `Duplicate subscriber name: \"${subscriber.name}\"`,\n   184→          });\n   185→        }\n   186→        names.add(subscriber.name);\n   187→      }\n   188→\n   189→      // Check for subscribers without callbacks (stubs in consuming instance)\n   190→      const stubs = entry.subscribers.filter((s) => !isSubscriber(s));\n   191→      if (stubs.length === entry.subscribers.length && stubs.length > 0) {\n   192→        issues.push({\n   193→          severity: 'warning',\n   194→          eventKey: key,\n   195→          message: 'All subscribers are stubs, no local handlers',\n   196→        });\n   197→      }\n   198→    }\n   199→\n   200→    return {\n   201→      valid: issues.filter((i) => i.severity === 'error').length === 0,\n   202→      issues,\n   203→    };\n   204→  }\n   205→\n   206→  /**\n   207→   * Clears all registered entries.\n   208→   */\n   209→  clear(): void {\n   210→    this.entries.clear();\n   211→    this.aliases.clear();\n   212→  }\n   213→\n   214→  private getEntry(eventKey: string): SchemaEntry | undefined {\n   215→    const entry = this.entries.get(eventKey);\n   216→    if (entry) return entry;\n   217→\n   218→    const aliasKey = this.aliases.get(eventKey);\n   219→    if (aliasKey) {\n   220→      return this.entries.get(aliasKey);\n   221→    }\n   222→\n   223→    return undefined;\n   224→  }\n   225→}\n   226→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T14:26:21.991Z"
        },
        {
          "type": "user",
          "text": "     1→// Core\n     2→export type {\n     3→  FanoutConfig,\n     4→  HandlersState,\n     5→  MatadorConfig,\n     6→  SendError,\n     7→  SendResult,\n     8→  ShutdownConfig,\n     9→  ShutdownState,\n    10→} from './core/index.js';\n    11→export {\n    12→  defaultShutdownConfig,\n    13→  FanoutEngine,\n    14→  Matador,\n    15→  ShutdownManager,\n    16→} from './core/index.js';\n    17→\n    18→// Types\n    19→export type {\n    20→  AnySubscriber,\n    21→  CreateEnvelopeOptions,\n    22→  DeliveryMode,\n    23→  Docket,\n    24→  Envelope,\n    25→  EnvelopeOf,\n    26→  Event,\n    27→  EventClass,\n    28→  EventData,\n    29→  EventKey,\n    30→  EventOptions,\n    31→  EventStatic,\n    32→  Idempotency,\n    33→  Importance,\n    34→  JsonRecord,\n    35→  Subscriber,\n    36→  SubscriberCallback,\n    37→  SubscriberDefinition,\n    38→  SubscriberOptions,\n    39→  SubscriberStub,\n    40→  ValidationError,\n    41→  ValidationResult,\n    42→} from './types/index.js';\n    43→export {\n    44→  MatadorEvent,\n    45→  createEnvelope,\n    46→  createSubscriber,\n    47→  createSubscriberStub,\n    48→  invalidResult,\n    49→  isSubscriber,\n    50→  isSubscriberStub,\n    51→  validResult,\n    52→} from './types/index.js';\n    53→\n    54→// Transport\n    55→export type {\n    56→  ConnectFn,\n    57→  ConnectionManagerConfig,\n    58→  ConnectionState,\n    59→  DisconnectFn,\n    60→  MessageHandler,\n    61→  MessageReceipt,\n    62→  RabbitMQSendOptions,\n    63→  RabbitMQSubscribeOptions,\n    64→  RabbitMQTransportConfig,\n    65→  SendOptions,\n    66→  StateChangeCallback,\n    67→  SubscribeOptions,\n    68→  Subscription,\n    69→  Transport,\n    70→  TransportCapabilities,\n    71→  TransportSendOptions,\n    72→  TransportSubscribeOptions,\n    73→} from './transport/index.js';\n    74→export {\n    75→  ConnectionManager,\n    76→  defaultConnectionConfig,\n    77→  hasNativeDeadLetter,\n    78→  LocalTransport,\n    79→  RabbitMQTransport,\n    80→  MultiTransport,\n    81→  type MultiTransportConfig,\n    82→  type MultiTransportHooks,\n    83→  supportsDeliveryMode,\n    84→  supportsDelayedMessages,\n    85→} from './transport/index.js';\n    86→\n    87→// Topology\n    88→export type {\n    89→  DeadLetterConfig,\n    90→  DeadLetterQueueConfig,\n    91→  QueueDefinition,\n    92→  QueueOptions,\n    93→  RetryConfig,\n    94→  Topology,\n    95→} from './topology/index.js';\n    96→export {\n    97→  getDeadLetterQueueName,\n    98→  getQualifiedQueueName,\n    99→  getRetryQueueName,\n   100→  TopologyBuilder,\n   101→  TopologyValidationError,\n   102→} from './topology/index.js';\n   103→\n   104→// Codec\n   105→export type {\n   106→  Codec,\n   107→  EncodedMessage,\n   108→  HeaderAwareCodec,\n   109→} from './codec/index.js';\n   110→export { CodecDecodeError, JsonCodec, RabbitMQCodec } from './codec/index.js';\n   111→\n   112→// Schema\n   113→export type {\n   114→  MatadorSchema,\n   115→  RegisterOptions,\n   116→  SchemaEntry,\n   117→  SchemaEntryTuple,\n   118→  SchemaIssue,\n   119→  SchemaValidationResult,\n   120→} from './schema/index.js';\n   121→export {\n   122→  bind,\n   123→  isSchemaEntryTuple,\n   124→  SchemaError,\n   125→  SchemaRegistry,\n   126→} from './schema/index.js';\n   127→\n   128→// Retry\n   129→export type {\n   130→  RetryContext,\n   131→  RetryDecision,\n   132→  RetryPolicy,\n   133→  StandardRetryPolicyConfig,\n   134→} from './retry/index.js';\n   135→export {\n   136→  defaultRetryConfig,\n   137→  StandardRetryPolicy,\n   138→} from './retry/index.js';\n   139→\n   140→// Hooks\n   141→export type {\n   142→  DecodeErrorContext,\n   143→  EnqueueErrorContext,\n   144→  EnqueueSuccessContext,\n   145→  EnqueueWarningContext,\n   146→  Logger,\n   147→  MatadorHooks,\n   148→  WorkerErrorContext,\n   149→  WorkerExecuteFn,\n   150→  WorkerSuccessContext,\n   151→} from './hooks/index.js';\n   152→export { consoleLogger, SafeHooks } from './hooks/index.js';\n   153→\n   154→// Pipeline\n   155→export type { PipelineConfig, ProcessResult } from './pipeline/index.js';\n   156→export { ProcessingPipeline } from './pipeline/index.js';\n   157→\n   158→// Errors\n   159→export type { HasDescription } from './errors/index.js';\n   160→export {\n   161→  // Retry control errors\n   162→  DontRetry,\n   163→  DoRetry,\n   164→  EventAssertionError,\n   165→  RetryControlError,\n   166→  isAssertionError,\n   167→  isDontRetry,\n   168→  isDoRetry,\n   169→  // Matador errors with descriptions\n   170→  MatadorError,\n   171→  isMatadorError,\n   172→  // Lifecycle errors\n   173→  NotStartedError,\n   174→  isNotStartedError,\n   175→  ShutdownInProgressError,\n   176→  // Transport errors\n   177→  TransportNotConnectedError,\n   178→  isTransportNotConnectedError,\n   179→  TransportClosedError,\n   180→  TransportSendError,\n   181→  AllTransportsFailedError,\n   182→  DelayedMessagesNotSupportedError,\n   183→  // Schema & configuration errors\n   184→  EventNotRegisteredError,\n   185→  isEventNotRegisteredError,\n   186→  SubscriberNotRegisteredError,\n   187→  isSubscriberNotRegisteredError,\n   188→  NoSubscribersExistError,\n   189→  InvalidSchemaError,\n   190→  SubscriberIsStubError,\n   191→  LocalTransportCannotProcessStubError,\n   192→  // Queue errors\n   193→  QueueNotFoundError,\n   194→  // Event validation errors\n   195→  InvalidEventError,\n   196→  // Message processing errors\n   197→  MessageMaybePoisonedError,\n   198→  isMessageMaybePoisonedError,\n   199→  IdempotentMessageCannotRetryError,\n   200→  isIdempotentMessageCannotRetryError,\n   201→  // Timeout errors\n   202→  TimeoutError,\n   203→  // Utility\n   204→  hasDescription,\n   205→} from './errors/index.js';\n   206→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T14:26:21.992Z"
        },
        {
          "type": "assistant",
          "text": "Now I have a good understanding of the codebase. Let me create a todo list and start implementing the resumable subscribers feature according to the plan.",
          "timestamp": "2025-12-11T14:26:25.896Z"
        },
        {
          "type": "tool_use",
          "name": "TodoWrite",
          "input": {
            "todos": [
              {
                "activeForm": "Adding 'resumable' to Idempotency type and defining checkpoint types",
                "content": "Phase 1: Add 'resumable' to Idempotency type and define checkpoint types",
                "status": "in_progress"
              },
              {
                "activeForm": "Implementing NoOpCheckpointStore and MemoryCheckpointStore",
                "content": "Phase 2: Implement NoOpCheckpointStore and MemoryCheckpointStore",
                "status": "pending"
              },
              {
                "activeForm": "Implementing ResumableContext class",
                "content": "Phase 3: Implement ResumableContext class with io() and all()",
                "status": "pending"
              },
              {
                "activeForm": "Updating SubscriberOptions with discriminated union",
                "content": "Phase 4: Update SubscriberOptions with discriminated union for resumable",
                "status": "pending"
              },
              {
                "activeForm": "Integrating checkpoint into ProcessingPipeline",
                "content": "Phase 5: Integrate checkpoint into ProcessingPipeline",
                "status": "pending"
              },
              {
                "activeForm": "Adding checkpoint-related hooks",
                "content": "Phase 6: Add checkpoint-related hooks to MatadorHooks",
                "status": "pending"
              },
              {
                "activeForm": "Adding checkpointStore to MatadorConfig",
                "content": "Phase 7: Add checkpointStore to MatadorConfig",
                "status": "pending"
              },
              {
                "activeForm": "Writing unit tests",
                "content": "Phase 8: Write unit tests",
                "status": "pending"
              },
              {
                "activeForm": "Updating exports in index files",
                "content": "Phase 9: Update exports in index files",
                "status": "pending"
              }
            ]
          },
          "timestamp": "2025-12-11T14:26:31.901Z"
        },
        {
          "type": "user",
          "text": "Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable",
          "timestamp": "2025-12-11T14:26:31.964Z"
        },
        {
          "type": "assistant",
          "text": "Let me start implementing Phase 1. First, I'll update the `Idempotency` type and create the checkpoint types file:",
          "timestamp": "2025-12-11T14:26:35.513Z"
        },
        {
          "type": "tool_use",
          "name": "Edit",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/types/common.ts",
            "new_string": "/**\n * Idempotency declaration for subscribers.\n * - 'yes': Safe to retry on failure (subscriber handles duplicates)\n * - 'no': Not safe to retry, may cause duplicate side effects\n * - 'unknown': Idempotency not determined (default)\n * - 'resumable': Uses checkpoint-based idempotency via io() calls\n */\nexport type Idempotency = 'yes' | 'no' | 'unknown' | 'resumable';",
            "old_string": "/**\n * Idempotency declaration for subscribers.\n * - 'yes': Safe to retry on failure\n * - 'no': Not safe to retry, may cause duplicate side effects\n * - 'unknown': Idempotency not determined\n */\nexport type Idempotency = 'yes' | 'no' | 'unknown';"
          },
          "timestamp": "2025-12-11T14:26:39.709Z"
        }
      ],
      "total_additions": 1590,
      "total_deletions": 42,
      "accepted_lines": 1581,
      "overriden_lines": 13
    }
  }
}
