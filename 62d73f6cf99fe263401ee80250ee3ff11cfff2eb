packages/matador/test/integration/matador.integration.test.ts
  afc290f3bab0f88c 75,114,120,126,163,169,291,327,377,457,464
packages/matador/src/codec/rabbitmq-codec.test.ts
  afc290f3bab0f88c 1-516
packages/matador/examples/config.ts
  afc290f3bab0f88c 60,71,78,87
packages/matador/src/types/subscriber.ts
  afc290f3bab0f88c 2,7,10
---
{
  "schema_version": "authorship/3.0.0",
  "git_ai_version": "1.0.22",
  "base_commit_sha": "62d73f6cf99fe263401ee80250ee3ff11cfff2eb",
  "prompts": {
    "afc290f3bab0f88c": {
      "agent_id": {
        "tool": "claude",
        "id": "b0b7e705-e863-4e8a-9c69-466cb8acc7ee",
        "model": "claude-opus-4-5-20251101"
      },
      "human_author": "Zachary Davison <zachary.davison@meetsmore.com>",
      "messages": [
        {
          "type": "user",
          "text": "Write test cases that test the RabbitMQ translation of v1 messages into v2 for consumption\n\nit's not necessary to convert v2 into v1\n\nmake it easy for me to add examples of v1 messages for test, i will provide many examples",
          "timestamp": "2025-12-05T14:55:37.164Z"
        },
        {
          "type": "assistant",
          "text": "I'll explore the codebase to understand the v1/v2 message formats and the RabbitMQ codec structure.",
          "timestamp": "2025-12-05T14:55:42.716Z"
        },
        {
          "type": "tool_use",
          "name": "Task",
          "input": {
            "description": "Explore v1/v2 message codec",
            "prompt": "Explore the matador codebase to understand:\n\n1. The structure of v1 and v2 messages (look in codec/ or transport/ directories)\n2. How the RabbitMQ codec works for translating v1 to v2 messages\n3. Existing test patterns used in the codebase\n\nFocus on:\n- packages/matador/src/codec/\n- packages/matador/src/transport/rabbitmq/\n- Any existing tests for the codec\n\nReturn:\n- The file paths for v1/v2 message definitions\n- The RabbitMQCodec implementation details\n- How v1 messages are structured vs v2 messages\n- Example test file patterns used in the project",
            "subagent_type": "Explore"
          },
          "timestamp": "2025-12-05T14:55:46.925Z"
        },
        {
          "type": "assistant",
          "text": "Let me read the RabbitMQ codec file to get the exact implementation details:",
          "timestamp": "2025-12-05T14:56:39.504Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/codec/rabbitmq-codec.ts"
          },
          "timestamp": "2025-12-05T14:56:40.284Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/types/envelope.ts"
          },
          "timestamp": "2025-12-05T14:56:40.903Z"
        },
        {
          "type": "user",
          "text": "     1→import type { Docket, Envelope } from '../types/index.js';\n     2→import { CodecDecodeError } from './codec.js';\n     3→import type { EncodedMessage, HeaderAwareCodec } from './header-aware-codec.js';\n     4→\n     5→/**\n     6→ * Header names used by Matador in RabbitMQ messages.\n     7→ */\n     8→const HEADERS = {\n     9→  // Routing\n    10→  EVENT_KEY: 'x-matador-event-key',\n    11→  TARGET_SUBSCRIBER: 'x-matador-subscriber',\n    12→  SCHEDULED_FOR: 'x-matador-scheduled-for',\n    13→  ORIGINAL_QUEUE: 'x-matador-original-queue',\n    14→\n    15→  // Processing state\n    16→  ATTEMPTS: 'x-matador-attempts',\n    17→  CREATED_AT: 'x-matador-created-at',\n    18→  FIRST_ERROR: 'x-matador-first-error',\n    19→  LAST_ERROR: 'x-matador-last-error',\n    20→\n    21→  // Observability\n    22→  IMPORTANCE: 'x-matador-importance',\n    23→  CORRELATION_ID: 'x-matador-correlation-id',\n    24→\n    25→  // v1 compatibility headers\n    26→  V1_EVENT_ID: 'x-event-id',\n    27→  V1_CORRELATION_ID: 'x-correlation-id',\n    28→  V1_USER_ID: 'x-user-id',\n    29→} as const;\n    30→\n    31→/**\n    32→ * Body structure for v2 messages.\n    33→ * Only contains id, data, and optionally metadata (since it can be large).\n    34→ */\n    35→interface V2Body {\n    36→  readonly id: string;\n    37→  readonly data: unknown;\n    38→  readonly metadata?: Record<string, unknown>;\n    39→}\n    40→\n    41→/**\n    42→ * v1 message format (for backwards compatibility).\n    43→ */\n    44→interface V1Body {\n    45→  key: string;\n    46→  data: unknown;\n    47→  metadata: unknown;\n    48→  universal?: {\n    49→    event_id?: string | null;\n    50→    user_id?: string | null;\n    51→    correlation_id?: string | null;\n    52→    [key: string]: unknown;\n    53→  };\n    54→  before?: unknown;\n    55→  options?: { delayMs?: number };\n    56→  targetSubscriber: string;\n    57→}\n    58→\n    59→/**\n    60→ * RabbitMQ-specific codec that stores routing/metadata in headers.\n    61→ *\n    62→ * Benefits:\n    63→ * - No duplication between body and headers\n    64→ * - RabbitMQ can route/filter based on headers\n    65→ * - Smaller message body\n    66→ * - v1 message format compatibility built-in\n    67→ */\n    68→export class RabbitMQCodec implements HeaderAwareCodec {\n    69→  /**\n    70→   * Creates a new RabbitMQ codec instance.\n    71→   */\n    72→  static create(): RabbitMQCodec {\n    73→    return new RabbitMQCodec();\n    74→  }\n    75→\n    76→  readonly contentType = 'application/json';\n    77→\n    78→  encode(envelope: Envelope): EncodedMessage {\n    79→    const { docket } = envelope;\n    80→\n    81→    // Body only contains id, data, and metadata (since metadata can be large)\n    82→    const body: V2Body = {\n    83→      id: envelope.id,\n    84→      data: envelope.data,\n    85→      ...(docket.metadata !== undefined && { metadata: docket.metadata }),\n    86→    };\n    87→\n    88→    // All docket fields go in headers\n    89→    const headers: Record<string, unknown> = {\n    90→      // Routing\n    91→      [HEADERS.EVENT_KEY]: docket.eventKey,\n    92→      [HEADERS.TARGET_SUBSCRIBER]: docket.targetSubscriber,\n    93→\n    94→      // Processing state\n    95→      [HEADERS.ATTEMPTS]: docket.attempts,\n    96→      [HEADERS.CREATED_AT]: docket.createdAt,\n    97→\n    98→      // Observability\n    99→      [HEADERS.IMPORTANCE]: docket.importance,\n   100→    };\n   101→\n   102→    // Optional fields\n   103→    if (docket.scheduledFor !== undefined) {\n   104→      headers[HEADERS.SCHEDULED_FOR] = docket.scheduledFor;\n   105→    }\n   106→    if (docket.originalQueue !== undefined) {\n   107→      headers[HEADERS.ORIGINAL_QUEUE] = docket.originalQueue;\n   108→    }\n   109→    if (docket.firstError !== undefined) {\n   110→      headers[HEADERS.FIRST_ERROR] = docket.firstError;\n   111→    }\n   112→    if (docket.lastError !== undefined) {\n   113→      headers[HEADERS.LAST_ERROR] = docket.lastError;\n   114→    }\n   115→    if (docket.correlationId !== undefined) {\n   116→      headers[HEADERS.CORRELATION_ID] = docket.correlationId;\n   117→    }\n   118→\n   119→    return {\n   120→      body: new TextEncoder().encode(JSON.stringify(body)),\n   121→      headers,\n   122→      contentType: this.contentType,\n   123→    };\n   124→  }\n   125→\n   126→  decode(body: Uint8Array, headers: Record<string, unknown>): Envelope {\n   127→    if (body.length === 0) {\n   128→      throw new CodecDecodeError('Cannot decode empty buffer');\n   129→    }\n   130→\n   131→    let json: string;\n   132→    try {\n   133→      json = new TextDecoder('utf-8').decode(body);\n   134→    } catch (error) {\n   135→      throw new CodecDecodeError('Invalid UTF-8 encoding', error);\n   136→    }\n   137→\n   138→    let parsed: unknown;\n   139→    try {\n   140→      parsed = JSON.parse(json);\n   141→    } catch (error) {\n   142→      throw new CodecDecodeError('Invalid JSON', error);\n   143→    }\n   144→\n   145→    // Detect format: v1 has 'key' and 'targetSubscriber' at top level\n   146→    if (this.isV1Body(parsed)) {\n   147→      return this.decodeV1(parsed, headers);\n   148→    }\n   149→\n   150→    // v2 format\n   151→    if (!this.isV2Body(parsed)) {\n   152→      throw new CodecDecodeError('Invalid message body structure');\n   153→    }\n   154→\n   155→    return this.decodeV2(parsed, headers);\n   156→  }\n   157→\n   158→  private isV1Body(value: unknown): value is V1Body {\n   159→    if (typeof value !== 'object' || value === null) return false;\n   160→    const obj = value as Record<string, unknown>;\n   161→    return (\n   162→      typeof obj['key'] === 'string' &&\n   163→      typeof obj['targetSubscriber'] === 'string' &&\n   164→      'data' in obj &&\n   165→      !('payload' in obj)\n   166→    );\n   167→  }\n   168→\n   169→  private isV2Body(value: unknown): value is V2Body {\n   170→    if (typeof value !== 'object' || value === null) return false;\n   171→    const obj = value as Record<string, unknown>;\n   172→    return (\n   173→      typeof obj['id'] === 'string' &&\n   174→      'data' in obj &&\n   175→      !('key' in obj) // Distinguish from v1 which also has 'data'\n   176→    );\n   177→  }\n   178→\n   179→  private decodeV2(body: V2Body, headers: Record<string, unknown>): Envelope {\n   180→    // Required headers\n   181→    const eventKey = this.requireStringHeader(headers, HEADERS.EVENT_KEY);\n   182→    const targetSubscriber = this.requireStringHeader(\n   183→      headers,\n   184→      HEADERS.TARGET_SUBSCRIBER,\n   185→    );\n   186→    const attempts = this.requireNumberHeader(headers, HEADERS.ATTEMPTS);\n   187→    const createdAt = this.requireStringHeader(headers, HEADERS.CREATED_AT);\n   188→    const importance = this.requireStringHeader(headers, HEADERS.IMPORTANCE);\n   189→\n   190→    // Optional headers\n   191→    const scheduledFor = this.optionalStringHeader(\n   192→      headers,\n   193→      HEADERS.SCHEDULED_FOR,\n   194→    );\n   195→    const originalQueue = this.optionalStringHeader(\n   196→      headers,\n   197→      HEADERS.ORIGINAL_QUEUE,\n   198→    );\n   199→    const firstError = this.optionalStringHeader(headers, HEADERS.FIRST_ERROR);\n   200→    const lastError = this.optionalStringHeader(headers, HEADERS.LAST_ERROR);\n   201→    const correlationId = this.optionalStringHeader(\n   202→      headers,\n   203→      HEADERS.CORRELATION_ID,\n   204→    );\n   205→\n   206→    const docket: Docket = {\n   207→      // Routing\n   208→      eventKey,\n   209→      targetSubscriber,\n   210→      ...(scheduledFor !== undefined && { scheduledFor }),\n   211→      ...(originalQueue !== undefined && { originalQueue }),\n   212→      // Processing state\n   213→      attempts,\n   214→      createdAt,\n   215→      ...(firstError !== undefined && { firstError }),\n   216→      ...(lastError !== undefined && { lastError }),\n   217→      // Observability\n   218→      importance: importance as Docket['importance'],\n   219→      ...(correlationId !== undefined && { correlationId }),\n   220→      ...(body.metadata !== undefined && { metadata: body.metadata }),\n   221→    };\n   222→\n   223→    return {\n   224→      id: body.id,\n   225→      data: body.data,\n   226→      docket,\n   227→    };\n   228→  }\n   229→\n   230→  /**\n   231→   * Decodes a v1 format message for backwards compatibility.\n   232→   * v1 format: { key, data, metadata, universal, targetSubscriber, ... }\n   233→   */\n   234→  private decodeV1(body: V1Body, headers: Record<string, unknown>): Envelope {\n   235→    const { event_id, user_id, correlation_id, ...otherUniversal } =\n   236→      body.universal ?? {};\n   237→\n   238→    // Merge metadata: event metadata + remaining universal fields\n   239→    const mergedMetadata: Record<string, unknown> = {};\n   240→    if (body.metadata && typeof body.metadata === 'object') {\n   241→      Object.assign(mergedMetadata, body.metadata);\n   242→    }\n   243→    if (user_id !== undefined && user_id !== null) {\n   244→      mergedMetadata['user_id'] = user_id;\n   245→    }\n   246→    Object.assign(mergedMetadata, otherUniversal);\n   247→\n   248→    // Try to get attempts from header (v1 also uses x-matador-attempts)\n   249→    const attempts =\n   250→      typeof headers[HEADERS.ATTEMPTS] === 'number'\n   251→        ? (headers[HEADERS.ATTEMPTS] as number)\n   252→        : 1;\n   253→\n   254→    // Try to get importance from header\n   255→    const importance =\n   256→      typeof headers[HEADERS.IMPORTANCE] === 'string'\n   257→        ? (headers[HEADERS.IMPORTANCE] as string)\n   258→        : 'should-investigate';\n   259→\n   260→    // Get correlation ID from either v1 or v2 header\n   261→    const correlationId =\n   262→      (headers[HEADERS.CORRELATION_ID] as string | undefined) ??\n   263→      (headers[HEADERS.V1_CORRELATION_ID] as string | undefined) ??\n   264→      correlation_id ??\n   265→      undefined;\n   266→\n   267→    // Get event ID from v1 header or body\n   268→    const eventId =\n   269→      (headers[HEADERS.V1_EVENT_ID] as string | undefined) ??\n   270→      event_id ??\n   271→      crypto.randomUUID();\n   272→\n   273→    const now = new Date().toISOString();\n   274→\n   275→    // Calculate scheduledFor if delayMs was specified (though it's likely already passed)\n   276→    let scheduledFor: string | undefined;\n   277→    if (body.options?.delayMs) {\n   278→      scheduledFor = new Date(Date.now() + body.options.delayMs).toISOString();\n   279→    }\n   280→\n   281→    const docket: Docket = {\n   282→      // Routing\n   283→      eventKey: body.key,\n   284→      targetSubscriber: body.targetSubscriber,\n   285→      ...(scheduledFor !== undefined && { scheduledFor }),\n   286→      // Processing state\n   287→      attempts,\n   288→      createdAt: now,\n   289→      // Observability\n   290→      importance: importance as Docket['importance'],\n   291→      ...(correlationId !== undefined && { correlationId }),\n   292→      ...(Object.keys(mergedMetadata).length > 0 && { metadata: mergedMetadata }),\n   293→    };\n   294→\n   295→    return {\n   296→      id: eventId,\n   297→      data: body.data,\n   298→      docket,\n   299→    };\n   300→  }\n   301→\n   302→  private requireStringHeader(\n   303→    headers: Record<string, unknown>,\n   304→    name: string,\n   305→  ): string {\n   306→    const value = headers[name];\n   307→    if (value === undefined) {\n   308→      throw new CodecDecodeError(`Missing required header: ${name}`);\n   309→    }\n   310→    if (typeof value !== 'string') {\n   311→      throw new CodecDecodeError(\n   312→        `Header ${name} must be string, got ${typeof value}`,\n   313→      );\n   314→    }\n   315→    return value;\n   316→  }\n   317→\n   318→  private requireNumberHeader(\n   319→    headers: Record<string, unknown>,\n   320→    name: string,\n   321→  ): number {\n   322→    const value = headers[name];\n   323→    if (value === undefined) {\n   324→      throw new CodecDecodeError(`Missing required header: ${name}`);\n   325→    }\n   326→    if (typeof value !== 'number') {\n   327→      throw new CodecDecodeError(\n   328→        `Header ${name} must be number, got ${typeof value}`,\n   329→      );\n   330→    }\n   331→    return value;\n   332→  }\n   333→\n   334→  private optionalStringHeader(\n   335→    headers: Record<string, unknown>,\n   336→    name: string,\n   337→  ): string | undefined {\n   338→    const value = headers[name];\n   339→    if (value === undefined) return undefined;\n   340→    if (typeof value !== 'string') return undefined;\n   341→    return value;\n   342→  }\n   343→}\n   344→\n   345→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-05T14:56:41.069Z"
        },
        {
          "type": "user",
          "text": "     1→import type { Importance } from './common.js';\n     2→\n     3→/**\n     4→ * Message envelope containing the event data and routing/observability metadata.\n     5→ * This is the transport-agnostic message format used throughout Matador.\n     6→ */\n     7→export interface Envelope<T = unknown> {\n     8→  /** Unique message ID (UUID v4) */\n     9→  readonly id: string;\n    10→\n    11→  /** The event data */\n    12→  readonly data: T;\n    13→\n    14→  /** Routing, processing state, and observability metadata */\n    15→  readonly docket: Docket;\n    16→}\n    17→\n    18→/**\n    19→ * Metadata associated with an envelope for routing, processing state, and observability.\n    20→ */\n    21→export interface Docket {\n    22→  // === Routing ===\n    23→\n    24→  /** Event key for routing */\n    25→  readonly eventKey: string;\n    26→\n    27→  /** Target subscriber name for 1:1 routing */\n    28→  readonly targetSubscriber: string;\n    29→\n    30→  /** Original queue before any dead-letter routing */\n    31→  originalQueue?: string | undefined;\n    32→\n    33→  /** Scheduled processing time for delayed messages (ISO 8601 string) */\n    34→  scheduledFor?: string | undefined;\n    35→\n    36→  // === Processing State ===\n    37→\n    38→  /**\n    39→   * Attempt counter managed by Matador (1-based).\n    40→   * Incremented on each retry. Used when transport doesn't track attempts.\n    41→   */\n    42→  attempts: number;\n    43→\n    44→  /** When the envelope was first created (ISO 8601 string) */\n    45→  readonly createdAt: string;\n    46→\n    47→  /** Error message from first failure (for debugging) */\n    48→  firstError?: string | undefined;\n    49→\n    50→  /** Error message from most recent failure */\n    51→  lastError?: string | undefined;\n    52→\n    53→  // === Observability ===\n    54→\n    55→  /** Importance level for monitoring */\n    56→  readonly importance: Importance;\n    57→\n    58→  /** Correlation ID for request tracing */\n    59→  readonly correlationId?: string | undefined;\n    60→\n    61→  /**\n    62→   * Custom metadata provided by the application.\n    63→   * This is the merged result of universal metadata (from loadUniversalMetadata hook)\n    64→   * and event-specific metadata (from dispatch options). Event-specific metadata\n    65→   * overrides universal metadata when keys conflict.\n    66→   */\n    67→  readonly metadata?: Record<string, unknown> | undefined;\n    68→}\n    69→\n    70→/**\n    71→ * Fields from Docket that can be specified when creating an envelope.\n    72→ */\n    73→type DocketCreateFields = Pick<\n    74→  Docket,\n    75→  'eventKey' | 'targetSubscriber' | 'importance' | 'correlationId'\n    76→>;\n    77→\n    78→/**\n    79→ * Options for creating an envelope.\n    80→ */\n    81→export interface CreateEnvelopeOptions<T> extends DocketCreateFields {\n    82→  /** Optional custom ID (defaults to UUID v4) */\n    83→  readonly id?: string | undefined;\n    84→\n    85→  /** The event data */\n    86→  readonly data: T;\n    87→\n    88→  /**\n    89→   * Event-specific metadata to include in the docket.\n    90→   * Will be merged with universal metadata, with these values taking precedence.\n    91→   */\n    92→  readonly metadata?: Record<string, unknown> | undefined;\n    93→\n    94→  /**\n    95→   * Universal metadata loaded from the loadUniversalMetadata hook.\n    96→   * This is provided by the fanout engine, not by the caller.\n    97→   * @internal\n    98→   */\n    99→  readonly universalMetadata?: Record<string, unknown> | undefined;\n   100→\n   101→  /** Delay processing by this many milliseconds */\n   102→  readonly delayMs?: number | undefined;\n   103→}\n   104→\n   105→/**\n   106→ * Creates a new envelope with the provided options.\n   107→ */\n   108→export function createEnvelope<T>(\n   109→  options: CreateEnvelopeOptions<T>,\n   110→): Envelope<T> {\n   111→  const now = new Date().toISOString();\n   112→\n   113→  // Merge universal metadata with event-specific metadata\n   114→  // Event-specific metadata takes precedence\n   115→  const mergedMetadata =\n   116→    options.universalMetadata || options.metadata\n   117→      ? { ...options.universalMetadata, ...options.metadata }\n   118→      : undefined;\n   119→\n   120→  return {\n   121→    id: options.id ?? crypto.randomUUID(),\n   122→    data: options.data,\n   123→    docket: {\n   124→      // Routing\n   125→      eventKey: options.eventKey,\n   126→      targetSubscriber: options.targetSubscriber,\n   127→      ...(options.delayMs !== undefined &&\n   128→        options.delayMs > 0 && {\n   129→          scheduledFor: new Date(Date.now() + options.delayMs).toISOString(),\n   130→        }),\n   131→      // Processing state\n   132→      attempts: 1,\n   133→      createdAt: now,\n   134→      // Observability\n   135→      importance: options.importance,\n   136→      ...(options.correlationId !== undefined && {\n   137→        correlationId: options.correlationId,\n   138→      }),\n   139→      ...(mergedMetadata !== undefined && { metadata: mergedMetadata }),\n   140→    },\n   141→  };\n   142→}\n   143→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-05T14:56:41.069Z"
        },
        {
          "type": "assistant",
          "text": "Let me check an existing test file for patterns:",
          "timestamp": "2025-12-05T14:56:46.837Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/transport/local/local-transport.test.ts"
          },
          "timestamp": "2025-12-05T14:56:47.850Z"
        },
        {
          "type": "user",
          "text": "     1→import { beforeEach, describe, expect, it } from 'bun:test';\n     2→import type { Topology } from '../../topology/types.js';\n     3→import { createEnvelope } from '../../types/index.js';\n     4→import { LocalTransport } from './local-transport.js';\n     5→\n     6→describe('LocalTransport', () => {\n     7→  let transport: LocalTransport;\n     8→\n     9→  beforeEach(() => {\n    10→    transport = new LocalTransport();\n    11→  });\n    12→\n    13→  describe('connection', () => {\n    14→    it('should start disconnected', () => {\n    15→      expect(transport.isConnected()).toBe(false);\n    16→    });\n    17→\n    18→    it('should connect successfully', async () => {\n    19→      await transport.connect();\n    20→      expect(transport.isConnected()).toBe(true);\n    21→    });\n    22→\n    23→    it('should disconnect successfully', async () => {\n    24→      await transport.connect();\n    25→      await transport.disconnect();\n    26→      expect(transport.isConnected()).toBe(false);\n    27→    });\n    28→  });\n    29→\n    30→  describe('capabilities', () => {\n    31→    it('should report correct capabilities', () => {\n    32→      expect(transport.name).toBe('local');\n    33→      expect(transport.capabilities.deliveryModes).toContain('at-least-once');\n    34→      expect(transport.capabilities.delayedMessages).toBe(true);\n    35→      expect(transport.capabilities.deadLetterRouting).toBe('manual');\n    36→    });\n    37→  });\n    38→\n    39→  describe('send and receive', () => {\n    40→    beforeEach(async () => {\n    41→      await transport.connect();\n    42→    });\n    43→\n    44→    it('should throw when sending while disconnected', async () => {\n    45→      await transport.disconnect();\n    46→      const envelope = createTestEnvelope();\n    47→\n    48→      await expect(transport.send('test-queue', envelope)).rejects.toThrow(\n    49→        'is not connected',\n    50→      );\n    51→    });\n    52→\n    53→    it('should send and receive a message', async () => {\n    54→      const envelope = createTestEnvelope();\n    55→      await transport.send('test-queue', envelope);\n    56→\n    57→      const received = await transport.receiveOne('test-queue');\n    58→      expect(received).not.toBeNull();\n    59→      expect(received?.envelope.id).toBe(envelope.id);\n    60→      expect(received?.envelope.data).toEqual({ test: 'data' });\n    61→    });\n    62→\n    63→    it('should track queue size correctly', async () => {\n    64→      expect(transport.getQueueSize('test-queue')).toBe(0);\n    65→\n    66→      await transport.send('test-queue', createTestEnvelope());\n    67→      expect(transport.getQueueSize('test-queue')).toBe(1);\n    68→\n    69→      await transport.send('test-queue', createTestEnvelope());\n    70→      expect(transport.getQueueSize('test-queue')).toBe(2);\n    71→    });\n    72→\n    73→    it('should complete messages and remove from queue', async () => {\n    74→      const envelope = createTestEnvelope();\n    75→      await transport.send('test-queue', envelope);\n    76→\n    77→      const received = await transport.receiveOne('test-queue');\n    78→      expect(received).not.toBeNull();\n    79→\n    80→      await transport.complete(received!.receipt);\n    81→\n    82→      expect(transport.getQueueSize('test-queue')).toBe(0);\n    83→      expect(transport.getCompleted()).toHaveLength(1);\n    84→    });\n    85→\n    86→    it('should return null when queue is empty', async () => {\n    87→      const received = await transport.receiveOne('empty-queue');\n    88→      expect(received).toBeNull();\n    89→    });\n    90→  });\n    91→\n    92→  describe('subscriptions', () => {\n    93→    beforeEach(async () => {\n    94→      await transport.connect();\n    95→    });\n    96→\n    97→    it('should throw when subscribing while disconnected', async () => {\n    98→      await transport.disconnect();\n    99→\n   100→      await expect(\n   101→        transport.subscribe('test-queue', async () => {}),\n   102→      ).rejects.toThrow('is not connected');\n   103→    });\n   104→\n   105→    it('should deliver messages to subscribers', async () => {\n   106→      const receivedMessages: unknown[] = [];\n   107→\n   108→      await transport.subscribe('test-queue', async (envelope) => {\n   109→        receivedMessages.push(envelope);\n   110→      });\n   111→\n   112→      const envelope = createTestEnvelope();\n   113→      await transport.send('test-queue', envelope);\n   114→\n   115→      expect(receivedMessages).toHaveLength(1);\n   116→      expect((receivedMessages[0] as { id: string }).id).toBe(envelope.id);\n   117→    });\n   118→\n   119→    it('should deliver pending messages when subscribing', async () => {\n   120→      const envelope = createTestEnvelope();\n   121→      await transport.send('test-queue', envelope);\n   122→\n   123→      const receivedMessages: unknown[] = [];\n   124→      await transport.subscribe('test-queue', async (env) => {\n   125→        receivedMessages.push(env);\n   126→      });\n   127→\n   128→      expect(receivedMessages).toHaveLength(1);\n   129→    });\n   130→\n   131→    it('should stop delivering after unsubscribe', async () => {\n   132→      const receivedMessages: unknown[] = [];\n   133→\n   134→      const subscription = await transport.subscribe(\n   135→        'test-queue',\n   136→        async (envelope) => {\n   137→          receivedMessages.push(envelope);\n   138→        },\n   139→      );\n   140→\n   141→      await transport.send('test-queue', createTestEnvelope());\n   142→      expect(receivedMessages).toHaveLength(1);\n   143→\n   144→      await subscription.unsubscribe();\n   145→      expect(subscription.isActive).toBe(false);\n   146→    });\n   147→  });\n   148→\n   149→  describe('dead letter queue', () => {\n   150→    beforeEach(async () => {\n   151→      await transport.connect();\n   152→    });\n   153→\n   154→    it('should send messages to dead letter queue', async () => {\n   155→      const envelope = createTestEnvelope();\n   156→      await transport.send('test-queue', envelope);\n   157→\n   158→      const received = await transport.receiveOne('test-queue');\n   159→      expect(received).not.toBeNull();\n   160→\n   161→      await transport.sendToDeadLetter(\n   162→        received!.receipt,\n   163→        'dlq',\n   164→        envelope,\n   165→        'test error',\n   166→      );\n   167→\n   168→      expect(transport.getQueueSize('test-queue')).toBe(0);\n   169→      expect(transport.getQueueSize('test-queue.dlq')).toBe(1);\n   170→    });\n   171→  });\n   172→\n   173→  describe('topology', () => {\n   174→    it('should apply topology and create queues', async () => {\n   175→      const topology: Topology = {\n   176→        namespace: 'test',\n   177→        queues: [{ name: 'events' }, { name: 'notifications' }],\n   178→        deadLetter: {\n   179→          unhandled: { enabled: true },\n   180→          undeliverable: { enabled: true },\n   181→        },\n   182→        retry: {\n   183→          enabled: true,\n   184→          defaultDelayMs: 1000,\n   185→          maxDelayMs: 30000,\n   186→        },\n   187→      };\n   188→\n   189→      await transport.connect();\n   190→      await transport.applyTopology(topology);\n   191→\n   192→      // Queues should be created\n   193→      expect(transport.getQueueSize('test.events')).toBe(0);\n   194→      expect(transport.getQueueSize('test.notifications')).toBe(0);\n   195→    });\n   196→  });\n   197→\n   198→  describe('clear', () => {\n   199→    it('should reset all state', async () => {\n   200→      await transport.connect();\n   201→      await transport.send('test-queue', createTestEnvelope());\n   202→\n   203→      const received = await transport.receiveOne('test-queue');\n   204→      await transport.complete(received!.receipt);\n   205→\n   206→      transport.clear();\n   207→\n   208→      expect(transport.getQueueSize('test-queue')).toBe(0);\n   209→      expect(transport.getCompleted()).toHaveLength(0);\n   210→    });\n   211→  });\n   212→\n   213→  describe('delayed messages', () => {\n   214→    beforeEach(async () => {\n   215→      await transport.connect();\n   216→    });\n   217→\n   218→    it('should return immediately and delay message delivery', async () => {\n   219→      const envelope = createTestEnvelope();\n   220→\n   221→      // Send returns immediately (non-blocking)\n   222→      await transport.send('test-queue', envelope, {\n   223→        delay: 100,\n   224→      });\n   225→\n   226→      // Message should not be in queue immediately\n   227→      expect(transport.getQueueSize('test-queue')).toBe(0);\n   228→\n   229→      // Wait for the delay to pass\n   230→      await new Promise((resolve) => setTimeout(resolve, 150));\n   231→\n   232→      // Message should now be in queue\n   233→      expect(transport.getQueueSize('test-queue')).toBe(1);\n   234→    });\n   235→\n   236→    it('should cancel delayed messages on disconnect', async () => {\n   237→      const envelope = createTestEnvelope();\n   238→\n   239→      await transport.send('test-queue', envelope, {\n   240→        delay: 100,\n   241→      });\n   242→\n   243→      // Disconnect before delay expires\n   244→      await transport.disconnect();\n   245→\n   246→      // Wait past the original delay\n   247→      await new Promise((resolve) => setTimeout(resolve, 150));\n   248→\n   249→      // Message should never have been delivered\n   250→      expect(transport.getQueueSize('test-queue')).toBe(0);\n   251→    });\n   252→  });\n   253→});\n   254→\n   255→function createTestEnvelope() {\n   256→  return createEnvelope({\n   257→    eventKey: 'test.event',\n   258→    targetSubscriber: 'test-subscriber',\n   259→    data: { test: 'data' },\n   260→    importance: 'should-investigate',\n   261→  });\n   262→}\n   263→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-05T14:56:47.944Z"
        },
        {
          "type": "assistant",
          "text": "Now I'll create the test file with a structure that makes it easy for you to add v1 message examples:",
          "timestamp": "2025-12-05T14:56:55.297Z"
        },
        {
          "type": "tool_use",
          "name": "Write",
          "input": {
            "content": "import { describe, expect, it } from 'bun:test';\nimport { RabbitMQCodec } from './rabbitmq-codec.js';\n\n/**\n * V1 message body format for test fixtures.\n */\ninterface V1MessageBody {\n  key: string;\n  data: unknown;\n  metadata?: unknown;\n  universal?: {\n    event_id?: string | null;\n    user_id?: string | null;\n    correlation_id?: string | null;\n    [key: string]: unknown;\n  };\n  before?: unknown;\n  options?: { delayMs?: number };\n  targetSubscriber: string;\n}\n\n/**\n * A v1 message fixture with optional headers.\n */\ninterface V1MessageFixture {\n  name: string;\n  body: V1MessageBody;\n  headers?: Record<string, unknown>;\n  expected: {\n    id?: string;\n    eventKey: string;\n    targetSubscriber: string;\n    data: unknown;\n    metadata?: Record<string, unknown>;\n    correlationId?: string;\n    attempts?: number;\n    importance?: string;\n  };\n}\n\n/**\n * Add your v1 message examples here.\n * Each fixture describes:\n * - name: A descriptive name for the test case\n * - body: The v1 message body (what goes in the RabbitMQ message content)\n * - headers: Optional RabbitMQ headers that accompany the message\n * - expected: The expected v2 envelope fields after translation\n */\nconst V1_MESSAGE_FIXTURES: V1MessageFixture[] = [\n  // === BASIC EXAMPLES ===\n  {\n    name: 'minimal v1 message with only required fields',\n    body: {\n      key: 'user.created',\n      data: { userId: '123' },\n      targetSubscriber: 'email-service',\n    },\n    expected: {\n      eventKey: 'user.created',\n      targetSubscriber: 'email-service',\n      data: { userId: '123' },\n      attempts: 1,\n      importance: 'should-investigate',\n    },\n  },\n\n  {\n    name: 'v1 message with metadata',\n    body: {\n      key: 'order.placed',\n      data: { orderId: 'ORD-456', amount: 99.99 },\n      metadata: { source: 'web', region: 'us-east' },\n      targetSubscriber: 'fulfillment-service',\n    },\n    expected: {\n      eventKey: 'order.placed',\n      targetSubscriber: 'fulfillment-service',\n      data: { orderId: 'ORD-456', amount: 99.99 },\n      metadata: { source: 'web', region: 'us-east' },\n    },\n  },\n\n  // === UNIVERSAL METADATA EXAMPLES ===\n  {\n    name: 'v1 message with universal.event_id',\n    body: {\n      key: 'payment.processed',\n      data: { paymentId: 'PAY-789' },\n      universal: {\n        event_id: 'evt-abc-123',\n      },\n      targetSubscriber: 'notification-service',\n    },\n    expected: {\n      id: 'evt-abc-123',\n      eventKey: 'payment.processed',\n      targetSubscriber: 'notification-service',\n      data: { paymentId: 'PAY-789' },\n    },\n  },\n\n  {\n    name: 'v1 message with universal.user_id (merged into metadata)',\n    body: {\n      key: 'profile.updated',\n      data: { field: 'email' },\n      universal: {\n        user_id: 'user-456',\n      },\n      targetSubscriber: 'audit-service',\n    },\n    expected: {\n      eventKey: 'profile.updated',\n      targetSubscriber: 'audit-service',\n      data: { field: 'email' },\n      metadata: { user_id: 'user-456' },\n    },\n  },\n\n  {\n    name: 'v1 message with universal.correlation_id',\n    body: {\n      key: 'request.received',\n      data: { requestId: 'req-001' },\n      universal: {\n        correlation_id: 'corr-xyz-789',\n      },\n      targetSubscriber: 'logger-service',\n    },\n    expected: {\n      eventKey: 'request.received',\n      targetSubscriber: 'logger-service',\n      data: { requestId: 'req-001' },\n      correlationId: 'corr-xyz-789',\n    },\n  },\n\n  {\n    name: 'v1 message with all universal fields',\n    body: {\n      key: 'checkout.completed',\n      data: { cartId: 'cart-999' },\n      universal: {\n        event_id: 'evt-full-123',\n        user_id: 'user-777',\n        correlation_id: 'corr-full-456',\n        custom_field: 'custom_value',\n      },\n      targetSubscriber: 'analytics-service',\n    },\n    expected: {\n      id: 'evt-full-123',\n      eventKey: 'checkout.completed',\n      targetSubscriber: 'analytics-service',\n      data: { cartId: 'cart-999' },\n      correlationId: 'corr-full-456',\n      metadata: {\n        user_id: 'user-777',\n        custom_field: 'custom_value',\n      },\n    },\n  },\n\n  // === METADATA MERGING EXAMPLES ===\n  {\n    name: 'v1 message with both metadata and universal (merged)',\n    body: {\n      key: 'item.added',\n      data: { itemId: 'item-123' },\n      metadata: { category: 'electronics', priority: 'high' },\n      universal: {\n        user_id: 'user-888',\n        tenant_id: 'tenant-001',\n      },\n      targetSubscriber: 'inventory-service',\n    },\n    expected: {\n      eventKey: 'item.added',\n      targetSubscriber: 'inventory-service',\n      data: { itemId: 'item-123' },\n      metadata: {\n        category: 'electronics',\n        priority: 'high',\n        user_id: 'user-888',\n        tenant_id: 'tenant-001',\n      },\n    },\n  },\n\n  // === HEADER-BASED EXAMPLES ===\n  {\n    name: 'v1 message with attempt count from header',\n    body: {\n      key: 'task.retry',\n      data: { taskId: 'task-555' },\n      targetSubscriber: 'worker-service',\n    },\n    headers: {\n      'x-matador-attempts': 3,\n    },\n    expected: {\n      eventKey: 'task.retry',\n      targetSubscriber: 'worker-service',\n      data: { taskId: 'task-555' },\n      attempts: 3,\n    },\n  },\n\n  {\n    name: 'v1 message with importance from header',\n    body: {\n      key: 'alert.triggered',\n      data: { alertId: 'alert-111' },\n      targetSubscriber: 'pager-service',\n    },\n    headers: {\n      'x-matador-importance': 'critical',\n    },\n    expected: {\n      eventKey: 'alert.triggered',\n      targetSubscriber: 'pager-service',\n      data: { alertId: 'alert-111' },\n      importance: 'critical',\n    },\n  },\n\n  {\n    name: 'v1 message with correlation_id from v1 header',\n    body: {\n      key: 'trace.event',\n      data: { traceId: 'trace-222' },\n      targetSubscriber: 'tracing-service',\n    },\n    headers: {\n      'x-correlation-id': 'header-corr-id',\n    },\n    expected: {\n      eventKey: 'trace.event',\n      targetSubscriber: 'tracing-service',\n      data: { traceId: 'trace-222' },\n      correlationId: 'header-corr-id',\n    },\n  },\n\n  {\n    name: 'v1 message with event_id from v1 header',\n    body: {\n      key: 'legacy.event',\n      data: { legacyId: 'leg-333' },\n      targetSubscriber: 'legacy-handler',\n    },\n    headers: {\n      'x-event-id': 'header-event-id-456',\n    },\n    expected: {\n      id: 'header-event-id-456',\n      eventKey: 'legacy.event',\n      targetSubscriber: 'legacy-handler',\n      data: { legacyId: 'leg-333' },\n    },\n  },\n\n  // === EDGE CASES ===\n  {\n    name: 'v1 message with null universal fields (ignored)',\n    body: {\n      key: 'null.test',\n      data: { test: true },\n      universal: {\n        event_id: null,\n        user_id: null,\n        correlation_id: null,\n      },\n      targetSubscriber: 'null-handler',\n    },\n    expected: {\n      eventKey: 'null.test',\n      targetSubscriber: 'null-handler',\n      data: { test: true },\n    },\n  },\n\n  {\n    name: 'v1 message with empty metadata object',\n    body: {\n      key: 'empty.metadata',\n      data: { value: 42 },\n      metadata: {},\n      targetSubscriber: 'empty-handler',\n    },\n    expected: {\n      eventKey: 'empty.metadata',\n      targetSubscriber: 'empty-handler',\n      data: { value: 42 },\n    },\n  },\n\n  {\n    name: 'v1 message with complex nested data',\n    body: {\n      key: 'complex.event',\n      data: {\n        nested: {\n          deeply: {\n            value: [1, 2, { three: 'four' }],\n          },\n        },\n        array: ['a', 'b', 'c'],\n      },\n      targetSubscriber: 'complex-handler',\n    },\n    expected: {\n      eventKey: 'complex.event',\n      targetSubscriber: 'complex-handler',\n      data: {\n        nested: {\n          deeply: {\n            value: [1, 2, { three: 'four' }],\n          },\n        },\n        array: ['a', 'b', 'c'],\n      },\n    },\n  },\n\n  {\n    name: 'v1 message with before field (ignored in v2)',\n    body: {\n      key: 'update.event',\n      data: { newValue: 'after' },\n      before: { oldValue: 'before' },\n      targetSubscriber: 'update-handler',\n    },\n    expected: {\n      eventKey: 'update.event',\n      targetSubscriber: 'update-handler',\n      data: { newValue: 'after' },\n    },\n  },\n\n  // === ADD YOUR EXAMPLES BELOW ===\n  // Copy this template and fill in your v1 message data:\n  //\n  // {\n  //   name: 'descriptive name for your test case',\n  //   body: {\n  //     key: 'your.event.key',\n  //     data: { /* your event data */ },\n  //     metadata: { /* optional metadata */ },\n  //     universal: {\n  //       event_id: 'optional-event-id',\n  //       user_id: 'optional-user-id',\n  //       correlation_id: 'optional-correlation-id',\n  //       // any other custom fields\n  //     },\n  //     before: { /* optional, will be ignored */ },\n  //     options: { delayMs: 1000 }, // optional\n  //     targetSubscriber: 'your-subscriber-name',\n  //   },\n  //   headers: {\n  //     // optional headers\n  //     'x-matador-attempts': 1,\n  //     'x-matador-importance': 'should-investigate',\n  //     'x-event-id': 'header-event-id',\n  //     'x-correlation-id': 'header-correlation-id',\n  //   },\n  //   expected: {\n  //     id: 'expected-id', // optional, will be generated if not in body/headers\n  //     eventKey: 'your.event.key',\n  //     targetSubscriber: 'your-subscriber-name',\n  //     data: { /* expected data */ },\n  //     metadata: { /* expected merged metadata */ },\n  //     correlationId: 'expected-correlation-id',\n  //     attempts: 1,\n  //     importance: 'should-investigate',\n  //   },\n  // },\n];\n\ndescribe('RabbitMQCodec', () => {\n  const codec = RabbitMQCodec.create();\n\n  describe('v1 to v2 translation', () => {\n    for (const fixture of V1_MESSAGE_FIXTURES) {\n      it(`should translate: ${fixture.name}`, () => {\n        const body = new TextEncoder().encode(JSON.stringify(fixture.body));\n        const headers = fixture.headers ?? {};\n\n        const envelope = codec.decode(body, headers);\n\n        // Check required fields\n        expect(envelope.docket.eventKey).toBe(fixture.expected.eventKey);\n        expect(envelope.docket.targetSubscriber).toBe(\n          fixture.expected.targetSubscriber,\n        );\n        expect(envelope.data).toEqual(fixture.expected.data);\n\n        // Check optional ID (may be generated if not specified)\n        if (fixture.expected.id !== undefined) {\n          expect(envelope.id).toBe(fixture.expected.id);\n        } else {\n          expect(envelope.id).toMatch(\n            /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i,\n          );\n        }\n\n        // Check metadata\n        if (fixture.expected.metadata !== undefined) {\n          expect(envelope.docket.metadata).toEqual(fixture.expected.metadata);\n        } else {\n          expect(\n            envelope.docket.metadata === undefined ||\n              Object.keys(envelope.docket.metadata).length === 0,\n          ).toBe(true);\n        }\n\n        // Check correlation ID\n        if (fixture.expected.correlationId !== undefined) {\n          expect(envelope.docket.correlationId).toBe(\n            fixture.expected.correlationId,\n          );\n        }\n\n        // Check attempts (defaults to 1)\n        if (fixture.expected.attempts !== undefined) {\n          expect(envelope.docket.attempts).toBe(fixture.expected.attempts);\n        } else {\n          expect(envelope.docket.attempts).toBe(1);\n        }\n\n        // Check importance (defaults to 'should-investigate')\n        if (fixture.expected.importance !== undefined) {\n          expect(envelope.docket.importance).toBe(fixture.expected.importance);\n        } else {\n          expect(envelope.docket.importance).toBe('should-investigate');\n        }\n\n        // Check createdAt is a valid ISO string\n        expect(envelope.docket.createdAt).toMatch(\n          /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$/,\n        );\n      });\n    }\n  });\n\n  describe('v1 edge cases', () => {\n    it('should handle options.delayMs by setting scheduledFor', () => {\n      const body: V1MessageBody = {\n        key: 'delayed.event',\n        data: { test: true },\n        options: { delayMs: 5000 },\n        targetSubscriber: 'delay-handler',\n      };\n\n      const encoded = new TextEncoder().encode(JSON.stringify(body));\n      const before = Date.now();\n      const envelope = codec.decode(encoded, {});\n      const after = Date.now();\n\n      expect(envelope.docket.scheduledFor).toBeDefined();\n\n      const scheduledTime = new Date(envelope.docket.scheduledFor!).getTime();\n      expect(scheduledTime).toBeGreaterThanOrEqual(before + 5000);\n      expect(scheduledTime).toBeLessThanOrEqual(after + 5000);\n    });\n\n    it('should prefer header event_id over body universal.event_id', () => {\n      const body: V1MessageBody = {\n        key: 'priority.test',\n        data: {},\n        universal: { event_id: 'body-event-id' },\n        targetSubscriber: 'test-handler',\n      };\n\n      const encoded = new TextEncoder().encode(JSON.stringify(body));\n      const envelope = codec.decode(encoded, {\n        'x-event-id': 'header-event-id',\n      });\n\n      expect(envelope.id).toBe('header-event-id');\n    });\n\n    it('should prefer v2 correlation header over v1 header', () => {\n      const body: V1MessageBody = {\n        key: 'corr.priority',\n        data: {},\n        targetSubscriber: 'test-handler',\n      };\n\n      const encoded = new TextEncoder().encode(JSON.stringify(body));\n      const envelope = codec.decode(encoded, {\n        'x-matador-correlation-id': 'v2-corr-id',\n        'x-correlation-id': 'v1-corr-id',\n      });\n\n      expect(envelope.docket.correlationId).toBe('v2-corr-id');\n    });\n\n    it('should prefer header correlation_id over body universal.correlation_id', () => {\n      const body: V1MessageBody = {\n        key: 'corr.priority',\n        data: {},\n        universal: { correlation_id: 'body-corr-id' },\n        targetSubscriber: 'test-handler',\n      };\n\n      const encoded = new TextEncoder().encode(JSON.stringify(body));\n      const envelope = codec.decode(encoded, {\n        'x-correlation-id': 'header-corr-id',\n      });\n\n      expect(envelope.docket.correlationId).toBe('header-corr-id');\n    });\n  });\n});\n",
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/codec/rabbitmq-codec.test.ts"
          },
          "timestamp": "2025-12-05T14:58:02.842Z"
        }
      ],
      "total_additions": 538,
      "total_deletions": 25,
      "accepted_lines": 534,
      "overriden_lines": 0
    }
  }
}
