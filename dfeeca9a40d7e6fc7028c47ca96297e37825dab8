packages/matador/src/checkpoint/index.ts
  07b7f149f1151d4b 24,30
packages/matador/src/retry/standard-policy.test.ts
  07b7f149f1151d4b 108-134,263
README.md
  07b7f149f1151d4b 374-382,428-434,441,447-517,653-659
packages/matador/src/retry/standard-policy.ts
  07b7f149f1151d4b 126,129
packages/matador/src/errors/checkpoint-errors.ts
  07b7f149f1151d4b 1-62
packages/matador/src/errors/index.ts
  07b7f149f1151d4b 50-57
packages/matador/src/checkpoint/context.ts
  07b7f149f1151d4b 2
packages/matador/src/checkpoint/context.test.ts
  07b7f149f1151d4b 4
---
{
  "schema_version": "authorship/3.0.0",
  "git_ai_version": "1.0.22",
  "base_commit_sha": "dfeeca9a40d7e6fc7028c47ca96297e37825dab8",
  "prompts": {
    "07b7f149f1151d4b": {
      "agent_id": {
        "tool": "claude",
        "id": "809b45b0-4782-4d0a-a103-6e5297fc0d74",
        "model": "claude-opus-4-5-20251101"
      },
      "human_author": "Zachary Davison <zachary.davison@meetsmore.com>",
      "messages": [
        {
          "type": "user",
          "text": "readme has this\n\n### `ResumableSubscriber`\n\nMatador supports durable / resumable subscribers.\n\nThis allows subscribers that fail to resume where they left off, allowing you to retry subscribers that otherwise would not be idempotent.\n\nThis requires a Redis instance to be configured.\n\nWhen using `idempotent: 'resumable'`, you can use the `io` function argument to wrap side-effects, which will be cached when successful.\n\nOn subsequent retries, those successful `io` calls will return the cached value, instead of executing again.\n\n> TODO: Add example.\n\nadd the example",
          "timestamp": "2025-12-11T15:56:04.280Z"
        },
        {
          "type": "assistant",
          "text": "I'll add an example for the `ResumableSubscriber` section in the README. Let me first read the current README and understand the existing patterns, as well as look at the resumable subscriber implementation to create an accurate example.",
          "timestamp": "2025-12-11T15:56:09.290Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/README.md"
          },
          "timestamp": "2025-12-11T15:56:09.922Z"
        },
        {
          "type": "tool_use",
          "name": "Glob",
          "input": {
            "pattern": "**/*resumable*"
          },
          "timestamp": "2025-12-11T15:56:10.296Z"
        },
        {
          "type": "tool_use",
          "name": "Glob",
          "input": {
            "pattern": "**/checkpoint/**/*.ts"
          },
          "timestamp": "2025-12-11T15:56:10.570Z"
        },
        {
          "type": "user",
          "text": "/home/z/Desktop/work/matador/docs/plans/resumable-subscribers.md",
          "timestamp": "2025-12-11T15:56:10.757Z"
        },
        {
          "type": "user",
          "text": "/home/z/Desktop/work/matador/packages/matador/src/checkpoint/context.test.ts\n/home/z/Desktop/work/matador/packages/matador/src/checkpoint/context.ts\n/home/z/Desktop/work/matador/packages/matador/src/checkpoint/stores/memory.ts\n/home/z/Desktop/work/matador/packages/matador/src/checkpoint/errors.ts\n/home/z/Desktop/work/matador/packages/matador/src/checkpoint/index.ts\n/home/z/Desktop/work/matador/packages/matador/src/checkpoint/stores/noop.ts\n/home/z/Desktop/work/matador/packages/matador/src/checkpoint/types.ts\n/home/z/Desktop/work/matador/packages/matador/src/checkpoint/stores/stores.test.ts",
          "timestamp": "2025-12-11T15:56:10.784Z"
        },
        {
          "type": "user",
          "text": "     1â†’# Matador\n     2â†’\n     3â†’![image](./assets/logo-small.png)\n     4â†’\n     5â†’An opinionated, batteries-included framework for using event transports (e.g. `RabbitMQ`) with a lot of useful conventions built in.\n     6â†’\n     7â†’## Table of Contents\n     8â†’\n     9â†’- [Vision](#vision)\n    10â†’- [History](#history)\n    11â†’- [Features](#features)\n    12â†’- [Getting Started](#getting-started)\n    13â†’  - [Define a MatadorEvent](#define-a-matadorevent)\n    14â†’  - [Define a Subscriber](#define-a-subscriber)\n    15â†’  - [Define a Schema](#define-a-schema)\n    16â†’  - [Instantiate Matador and send events](#instantiate-matador-and-send-events)\n    17â†’- [Concepts](#concepts)\n    18â†’  - [MatadorEvent](#matadorevent)\n    19â†’  - [Subscriber](#subscriber)\n    20â†’  - [Schema](#schema)\n    21â†’  - [Envelope](#envelope)\n    22â†’  - [Docket](#docket)\n    23â†’  - [Fanout](#fanout)\n    24â†’  - [Transport](#transport)\n    25â†’  - [Topology](#topology)\n    26â†’  - [Codec](#codec)\n    27â†’  - [Config](#config)\n    28â†’  - [Hooks](#hooks)\n    29â†’  - [idempotent](#idempotent)\n    30â†’- [Why it works this way](#why-it-works-this-way)\n    31â†’  - [Sending one message will result in a unique message per subscriber](#sending-one-message-will-result-in-a-unique-message-per-subscriber)\n    32â†’  - [You are working in a monorepo](#you-are-working-in-a-monorepo)\n    33â†’  - [You want at-least-once delivery](#you-want-at-least-once-delivery)\n    34â†’- [Logging](#logging)\n    35â†’- [Errors](#errors)\n    36â†’- [Other features](#other-features)\n    37â†’  - [universalMetadata](#universalmetadata)\n    38â†’  - [Schema plugins](#schema-plugins)\n    39â†’  - [DoRetry & DontRetry](#doretry--dontretry)\n    40â†’  - [LocalTransport](#localtransport)\n    41â†’  - [MultiTransport](#multitransport)\n    42â†’  - [enabled() hook for Subscriber](#enabled-hook-for-subscriber)\n    43â†’  - [importance](#importance)\n    44â†’  - [Delayed messages](#delayed-messages)\n    45â†’- [CLI](#cli)\n    46â†’\n    47â†’# Vision\n    48â†’\n    49â†’Matador aims to provide a ready-to-use framework for dispatching messages and moving work off your API servers onto workers.\n    50â†’It is an _opinionated_ library that may-or-may not suit your expectations about how to work with queues.\n    51â†’\n    52â†’You can use it to very quickly set up a framework for your events, with battle-tested conventions, edge-case coverage, and observability baked in.\n    53â†’\n    54â†’It works best under the following conditions.\n    55â†’\n    56â†’- You want the queue topology to be created and managed for you.\n    57â†’- You are working in a monorepo, where you can easily share code.\n    58â†’- You want a 1:N fanout strategy, where each _subscriber_ receives a unique copy of each event.\n    59â†’- You want `at-least-once` delivery semantics.\n    60â†’\n    61â†’These conditions are explained later.\n    62â†’\n    63â†’# History\n    64â†’\n    65â†’Matador has been used at [MeetsMore Inc](https://meetsmore.com/) for over 2 years to publish, consume, and observe 1,000,000+ successful events per day.\n    66â†’\n    67â†’This version of Matador is Matador V2, and was re-written from the ground up using our learnings over that 2 year period.\n    68â†’\n    69â†’# Features\n    70â†’\n    71â†’- Conventional types for `Event` and `Subscriber`\n    72â†’- Map an event to a list of subscribers that will consume it.\n    73â†’- Each subscriber receives a unique copy of each event that can be individually retried and re-queued.\n    74â†’- Automatically create and manage your queue topology.\n    75â†’- Automatic reconnection when connection drops.\n    76â†’- Async hooks for changing behaviour at runtime.\n    77â†’- Async lifecycle hooks for plugging into your observability platform.\n    78â†’- Required fields enforcing good, observable documentation practices.\n    79â†’- `idempotency` declaration for subscribers, allowing you to indicate if events can be retried safely or not.\n    80â†’- `metadata` separated from event payloads, to clearly separate data used for logic, and data that is just used for debugging.\n    81â†’- Gracefully wait for pending enqueues and subscribers to complete work before shutting down.\n    82â†’- Fallback to a different message broker if enqueuing fails.\n    83â†’- Local broker for executing code locally (useful for fallback).\n    84â†’- Retry control flow errors (`DoRetry` and `DontRetry`), so subscribers can manually dictate retry logic.\n    85â†’- Clear, documented, actionable errors for all error cases.\n    86â†’- Poisoned message detection.\n    87â†’- Resumable subscribers.\n    88â†’\n    89â†’# Getting Started\n    90â†’\n    91â†’### Define a MatadorEvent\n    92â†’\n    93â†’```ts\n    94â†’export class UserLoggedInEvent extends MatadorEvent {\n    95â†’  static readonly key = 'user.logged-in';                   // The unique event name (used to route events).\n    96â†’  static readonly description = 'Fired when a user logs.';  // A description of when the event is triggered.\n    97â†’\n    98â†’  constructor(\n    99â†’    public data: {                                          // The data payload used by business logic.\n   100â†’      userId: string;\n   101â†’      username: string;\n   102â†’    },\n   103â†’    public metadata: {                                      // Additional data helpful for logging or debugging.\n   104â†’      loginMethod: 'email' | 'social'\n   105â†’    }\n   106â†’  ) {\n   107â†’    super();\n   108â†’  }\n   109â†’}\n   110â†’```\n   111â†’\n   112â†’### Define a Subscriber\n   113â†’\n   114â†’```ts\n   115â†’const detectLoginFraud: Subscriber<UserLoggedInEvent> = {\n   116â†’  name: 'detect-login-fraud',                                           // Unique subscriber name.\n   117â†’  description: 'Send an email if unusual login behaviour is detected.'  // A description of what the subscriber does.\n   118â†’  idempotent: 'no'                                                      // Dictates if the operation can be safely retried.\n   119â†’  targetQueue: 'compliance-jobs-worker'                                 // The queue this subscriber consumes from.\n   120â†’  callback: async (event: EnvelopeOf<UserLoggedIn>) => { /** process event */ }\n   121â†’}\n   122â†’```\n   123â†’\n   124â†’### Define a Schema\n   125â†’\n   126â†’```ts\n   127â†’const myMatadorSchema = MatadorSchema = {\n   128â†’  [UserLoggedIn.key]: [UserLoggedIn, bind([ detectLoginFraud, logEventToBigQuery ])]\n   129â†’}\n   130â†’```\n   131â†’\n   132â†’### Instantiate Matador and send events\n   133â†’\n   134â†’```ts\n   135â†’// Create topology\n   136â†’const topology = TopologyBuilder.create()\n   137â†’  .withNamespace('my-app')\n   138â†’  .addQueue('events')\n   139â†’  .build();\n   140â†’\n   141â†’// Create transport\n   142â†’const transport = new RabbitMQTransport({ url: 'amqp://localhost' });\n   143â†’\n   144â†’// Create Matador instance\n   145â†’const matador = new Matador({\n   146â†’  transport,\n   147â†’  topology,\n   148â†’  schema: myMatadorSchema,\n   149â†’  consumeFrom: ['events'],  // Queues to consume from (optional, empty = producer only)\n   150â†’});\n   151â†’\n   152â†’await matador.start();\n   153â†’```\n   154â†’\n   155â†’```ts\n   156â†’await matador.send(UserLoggedInEvent, { userId: '123', username: 'john' });\n   157â†’```\n   158â†’\n   159â†’# Concepts\n   160â†’\n   161â†’### `MatadorEvent`\n   162â†’\n   163â†’A definition of an event. You extend `MatadorEvent` in order to create the _template_ for your event.\n   164â†’\n   165â†’### `Subscriber`\n   166â†’\n   167â†’A subscriber defines the logic that will execute when an event is consumed.\n   168â†’It also defines details about the event that are used to _fanout_ the event.\n   169â†’\n   170â†’```ts\n   171â†’/**\n   172â†’ * Standard subscriber definition with standard callback.\n   173â†’ */\n   174â†’export interface StandardSubscriber<T extends MatadorEvent> {\n   175â†’  /** Human-readable name for the subscriber */\n   176â†’  readonly name: string;\n   177â†’\n   178â†’  /** A description of what the event does. */\n   179â†’  readonly description: string\n   180â†’\n   181â†’  /** Idempotency declaration for retry handling (non-resumable) */\n   182â†’  readonly idempotent?: 'yes' | 'no' | 'unknown' | undefined;\n   183â†’\n   184â†’  /** Route this subscriber's events to a specific queue */\n   185â†’  readonly targetQueue?: string | undefined;\n   186â†’\n   187â†’  /** Importance level for monitoring and alerting */\n   188â†’  readonly importance?: Importance | undefined;\n   189â†’\n   190â†’  /** Feature flag function to conditionally enable/disable the subscriber */\n   191â†’  readonly enabled?: (() => boolean | Promise<boolean>) | undefined;\n   192â†’\n   193â†’  /** Callback function to execute when event is received */\n   194â†’  readonly callback: StandardCallback<T['data']>;\n   195â†’}\n   196â†’```\n   197â†’\n   198â†’If you want to reference a subscriber which is defined in another codebase, you can use `SubscriberStub`:\n   199â†’\n   200â†’```ts\n   201â†’/**\n   202â†’ * Subscriber stub for multi-codebase scenarios where subscriber implementation\n   203â†’ * is in a remote service. Declares the subscriber contract without providing\n   204â†’ * the callback.\n   205â†’ */\n   206â†’export interface SubscriberStub extends StandardSubscriberOptions {\n   207â†’  /** Human-readable name for the subscriber */\n   208â†’  readonly name: string;\n   209â†’\n   210â†’  /** Indicates this is a stub without implementation */\n   211â†’  readonly isStub: true;\n   212â†’}\n   213â†’```\n   214â†’\n   215â†’### `Schema`\n   216â†’\n   217â†’Defines the mapping of `Events` to `Subscribers`.\n   218â†’```ts\n   219â†’const myMatadorSchema = MatadorSchema = {\n   220â†’  // user.logged-in -> UserLoggedInEvent (class) -> subscribers\n   221â†’  [UserLoggedInEvent.key]: [UserLoggedInEvent, bind([ detectLoginFraud, logEventToBigQuery ])]\n   222â†’}\n   223â†’```\n   224â†’\n   225â†’### `Envelope`\n   226â†’\n   227â†’Combines both your event data + metadata with a `Docket`.\n   228â†’Subscribers receive an `EnvelopeOf<MyEvent>`, which is an envelope with a `data` and `metadata` field typed according to your `MatadorEvent` subclass.\n   229â†’\n   230â†’```ts\n   231â†’/**\n   232â†’ * Message envelope containing the event data and routing/observability metadata.\n   233â†’ * This is the transport-agnostic message format used throughout Matador.\n   234â†’ */\n   235â†’export interface Envelope<T = unknown> {\n   236â†’  /** Unique message ID (UUID v4) */\n   237â†’  readonly id: string;\n   238â†’\n   239â†’  /** The event data */\n   240â†’  readonly data: T;\n   241â†’\n   242â†’  /** Routing, processing state, and observability metadata */\n   243â†’  readonly docket: Docket;\n   244â†’}\n   245â†’\n   246â†’/**\n   247â†’ * Helper type to get the envelope type for a subscriber callback.\n   248â†’ * Extracts the data type from a MatadorEvent and wraps it in an Envelope.\n   249â†’ *\n   250â†’ * @example\n   251â†’ * async callback(envelope: EnvelopeOf<MyEvent>) {\n   252â†’ *   console.log(envelope.data.someField); // Type-safe access\n   253â†’ * }\n   254â†’ */\n   255â†’export type EnvelopeOf<T extends MatadorEvent> = Envelope<T['data']>;\n   256â†’```\n   257â†’\n   258â†’### `Docket`\n   259â†’\n   260â†’> A docket is a commercial document accompanying shipped goods, detailing its contents.\n   261â†’\n   262â†’Contains all metadata about an `Envelope`.\n   263â†’\n   264â†’| Property            | Documentation                                                                                                                                                                                                                                          |\n   265â†’| ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n   266â†’| **Routing**         |                                                                                                                                                                                                                                                        |\n   267â†’| `eventKey`          | Event key for routing                                                                                                                                                                                                                                  |\n   268â†’| `eventDescription`  | Human-readable description of the event (for observability/logging)                                                                                                                                                                                    |\n   269â†’| `targetSubscriber`  | Target subscriber name for 1:1 routing                                                                                                                                                                                                                 |\n   270â†’| `originalQueue`     | Original queue before any dead-letter routing                                                                                                                                                                                                          |\n   271â†’| `scheduledFor`      | Scheduled processing time for delayed messages (ISO 8601 string)                                                                                                                                                                                       |\n   272â†’| **Processing State**|                                                                                                                                                                                                                                                        |\n   273â†’| `attempts`          | Attempt counter managed by Matador (1-based). Incremented on each retry. Used when transport doesn't track attempts.                                                                                                                                   |\n   274â†’| `createdAt`         | When the envelope was first created (ISO 8601 string)                                                                                                                                                                                                  |\n   275â†’| `firstError`        | Error message from first failure (for debugging)                                                                                                                                                                                                       |\n   276â†’| `lastError`         | Error message from most recent failure                                                                                                                                                                                                                 |\n   277â†’| **Observability**   |                                                                                                                                                                                                                                                        |\n   278â†’| `importance`        | Importance level for monitoring                                                                                                                                                                                                                        |\n   279â†’| `correlationId`     | Correlation ID for request tracing                                                                                                                                                                                                                     |\n   280â†’| `metadata`          | Custom metadata provided by the application, includes `universalMetadata` |\n   281â†’\n   282â†’### `Fanout`\n   283â†’\n   284â†’The practice of taking a single published event and creating `N` concrete events, where `N` is the number of subscribers mapped to that event in your `MatadorSchema`\n   285â†’\n   286â†’### `Transport`\n   287â†’\n   288â†’A representation of a message broker or event backend. e.g `RabbitMQ`, `BullMQ`, `Temporal`, etc.\n   289â†’Currently, only `RabbitMQ` is supported.\n   290â†’\n   291â†’### `Topology`\n   292â†’\n   293â†’The structure of queues, exchanges, topics, etc that **Matador** will create and manage.\n   294â†’For RabbitMQ, for example, the topology refers to the exchanges, queues, and bindings of those entities.\n   295â†’**Matador** creates and manages topology for you.\n   296â†’\n   297â†’There is a generic `Topology` definition in Matador, which you can use to describe the queues you want in a limited fashion.\n   298â†’\n   299â†’Each `Transport` then translates that generic `Topology` into the concrete queues, exchanges, etc.\n   300â†’\n   301â†’The topology that **Matador** creates looks like this by default.\n   302â†’\n   303â†’![image](./assets/matador-rabbitmq-configuration-simple.drawio.png)\n   304â†’\n   305â†’#### Retry Queue\n   306â†’\n   307â†’When events fail, they are pushed into the retry queue. They will then be re-delivered after their TTL expires.\n   308â†’\n   309â†’#### Unhandled Queue\n   310â†’\n   311â†’In **Matador**, _unhandled_ refers to a message that was consumed by a worker but is not in your `MatadorSchema`.\n   312â†’This can happen during deployments, where your publisher has already been deployed, but your consumer has not, and therefore your consumer doesn't know about the event yet.\n   313â†’Since the most common reason for this (99.99% of the time in our experience) is simply deployment timing, _unhandled_ events are sent to the unhandled dead-letter queue for later inspection and manual reprocessing.\n   314â†’\n   315â†’#### Undeliverable Queue\n   316â†’\n   317â†’Undeliverable is a conventional term for messages that could not be successfully processed.\n   318â†’After a configured amount of retries (default: 3 attempts), a message will be sent to the undeliverable queue and left there for inspection.\n   319â†’By default, this queue is not cleared by **Matador**. You can optionally configure a `maxLength` on the dead-letter queue via the `DeadLetterQueueConfig`.\n   320â†’\n   321â†’### `Codec`\n   322â†’\n   323â†’Handles the _encoding_ and _decoding_ of events that are published and consumed.\n   324â†’By default, `JSONCodec` is used, which serializes and de-serializes events using JSON.\n   325â†’\n   326â†’You can create other `Codec`s if you wish (for example a `MessagePackCodec`).\n   327â†’\n   328â†’When using `RabbitMQ`, `RabbitMQCodec` is used, which still uses `JSONCodec` internally, but uses AMQP headers to store `Docket` information.\n   329â†’\n   330â†’### `Config`\n   331â†’\n   332â†’**Matador** is configured via the `MatadorConfig` interface:\n   333â†’\n   334â†’| Property          | Required | Description                                                                                              |\n   335â†’| ----------------- | -------- | -------------------------------------------------------------------------------------------------------- |\n   336â†’| `transport`       | Yes      | Transport for message delivery (e.g., `RabbitMQTransport`, `LocalTransport`, `MultiTransport`)           |\n   337â†’| `topology`        | Yes      | Topology configuration defining queues, dead-letter, and retry settings                                  |\n   338â†’| `schema`          | Yes      | Event schema mapping event keys to event classes and subscribers                                         |\n   339â†’| `consumeFrom`     | No       | Array of queue names to consume from (empty = producer only mode)                                        |\n   340â†’| `codec`           | No       | Custom codec for serialization (defaults to `JsonCodec`)                                                 |\n   341â†’| `retryPolicy`     | No       | Custom retry policy (defaults to `StandardRetryPolicy` with 3 max attempts)                              |\n   342â†’| `shutdownConfig`  | No       | Shutdown configuration (drain timeout, etc.)                                                             |\n   343â†’| `checkpointStore` | No       | Checkpoint store for resumable subscribers (required for persisting `io()` results across retries)       |\n   344â†’\n   345â†’**Topology** is configured via `TopologyBuilder`:\n   346â†’\n   347â†’| Property       | Default | Description                                              |\n   348â†’| -------------- | ------- | -------------------------------------------------------- |\n   349â†’| `namespace`    | -       | Prefix for all queue names (required)                    |\n   350â†’| `queues`       | -       | Array of queue definitions (at least one required)       |\n   351â†’| `deadLetter`   | enabled | Dead-letter queue configuration (unhandled/undeliverable)|\n   352â†’| `retry`        | enabled | Retry queue configuration (defaultDelayMs: 1000ms, maxDelayMs: 5 minutes) |\n   353â†’\n   354â†’**Queue Definition** options:\n   355â†’\n   356â†’| Property          | Default | Description                                                |\n   357â†’| ----------------- | ------- | ---------------------------------------------------------- |\n   358â†’| `name`            | -       | Queue name (required)                                      |\n   359â†’| `concurrency`     | -       | Number of concurrent consumers for this queue              |\n   360â†’| `consumerTimeout` | -       | Consumer timeout in milliseconds                           |\n   361â†’| `priorities`      | false   | Enable priority support if transport allows                |\n   362â†’| `exact`           | false   | Use queue name exactly without namespace prefix            |\n   363â†’\n   364â†’**Retry Policy** defaults (`StandardRetryPolicy`):\n   365â†’\n   366â†’| Property           | Default  | Description                                              |\n   367â†’| ------------------ | -------- | -------------------------------------------------------- |\n   368â†’| `maxAttempts`      | 3        | Maximum retry attempts before dead-lettering             |\n   369â†’| `baseDelay`        | 1000ms   | Base delay between retries                               |\n   370â†’| `maxDelay`         | 300000ms | Maximum delay (5 minutes)                                |\n   371â†’| `backoffMultiplier`| 2        | Multiplier for exponential backoff                       |\n   372â†’| `maxDeliveries`    | 5        | Max native delivery count before poison detection        |\n   373â†’\n   374â†’### `Hooks`\n   375â†’\n   376â†’Hooks are passed as the second argument to the `Matador` constructor and provide lifecycle callbacks for observability and dynamic configuration.\n   377â†’\n   378â†’**Lifecycle Hooks:**\n   379â†’\n   380â†’| Hook                     | Description                                                                           |\n   381â†’| ------------------------ | ------------------------------------------------------------------------------------- |\n   382â†’| `logger`                 | Logger instance for internal Matador logging (defaults to console)                    |\n   383â†’| `onEnqueueSuccess`       | Called when an event is successfully enqueued                                         |\n   384â†’| `onEnqueueWarning`       | Called when enqueue falls back to a secondary queue                                   |\n   385â†’| `onTransportFallback`    | Called when transport fallback occurs (MultiTransport with fallbackEnabled)           |\n   386â†’| `onEnqueueError`         | Called when enqueue fails completely                                                  |\n   387â†’| `onWorkerWrap`           | Wraps entire worker processing (for APM context like DataDog, NewRelic)               |\n   388â†’| `onWorkerBeforeProcess`  | Called before processing begins                                                       |\n   389â†’| `onWorkerSuccess`        | Called after successful processing                                                    |\n   390â†’| `onWorkerError`          | Called after processing error                                                         |\n   391â†’| `onDecodeError`          | Called when message decoding fails                                                    |\n   392â†’| `onConnectionStateChange`| Called when transport connection state changes                                        |\n   393â†’\n   394â†’**Dynamic Configuration Hooks:**\n   395â†’\n   396â†’| Hook                     | Description                                                                           |\n   397â†’| ------------------------ | ------------------------------------------------------------------------------------- |\n   398â†’| `loadUniversalMetadata`  | Loads metadata to add to all envelopes (e.g., correlationId from AsyncLocalStorage)   |\n   399â†’| `getQueueConcurrency`    | Dynamic queue concurrency lookup                                                      |\n   400â†’| `getRetryDelay`          | Dynamic retry delay lookup                                                            |\n   401â†’| `getAttempts`            | Dynamic max attempts lookup                                                           |\n   402â†’| `getMaxDeliveries`       | Dynamic max deliveries (poison threshold) lookup                                      |\n   403â†’\n   404â†’**Checkpoint Hooks (Resumable Subscribers):**\n   405â†’\n   406â†’| Hook                     | Description                                                                           |\n   407â†’| ------------------------ | ------------------------------------------------------------------------------------- |\n   408â†’| `onCheckpointLoaded`     | Called when a checkpoint is loaded for a retry                                        |\n   409â†’| `onCheckpointHit`        | Called when an `io()` operation uses a cached value                                   |\n   410â†’| `onCheckpointMiss`       | Called when an `io()` operation executes (cache miss)                                 |\n   411â†’| `onCheckpointCleared`    | Called when a checkpoint is cleared (success or dead-letter)                          |\n   412â†’\n   413â†’### `idempotent`\n   414â†’\n   415â†’> In programming, an idempotent operation is one that can be performed multiple times with the same result as if it were done only once.\n   416â†’\n   417â†’In **Matador**, `idempotent` has a very close meaning, but ultimately just means that an event is _allowed_ to be retried automatically by **Matador**.\n   418â†’\n   419â†’### `ResumableSubscriber`\n   420â†’\n   421â†’Matador supports durable / resumable subscribers.\n   422â†’\n   423â†’This allows subscribers that fail to resume where they left off, allowing you to retry subscribers that otherwise would not be idempotent.\n   424â†’\n   425â†’This requires a Redis instance to be configured.\n   426â†’\n   427â†’When using `idempotent: 'resumable'`, you can use the `io` function argument to wrap side-effects, which will be cached when successful.\n   428â†’\n   429â†’On subsequent retries, those successful `io` calls will return the cached value, instead of executing again.\n   430â†’\n   431â†’> TODO: Add example.\n   432â†’\n   433â†’# Why it works this way\n   434â†’\n   435â†’Since **Matador** is opinionated, we should explain the rationale behind our choices.\n   436â†’\n   437â†’### Sending one message will result in a unique message _per subscriber_.\n   438â†’\n   439â†’When you send an event in **Matador**, there is a unique copy of that event sent with different `Docket` details.\n   440â†’\n   441â†’This is automatic, and referred to as _fanout_ within **Matador**.\n   442â†’\n   443â†’We chose this model because while it results in `N` real events per published event, it allows each real event to be retried and managed individually. A single failed subscriber does not affect any others or result in any additional cognitive complexity about the system.\n   444â†’\n   445â†’This however does have the impact of requiring the publisher to know about the subscriber. \n   446â†’This is easy in a monorepo environment, but for remote subscribers, you can use `SubscriberStub`.\n   447â†’\n   448â†’### You are working in a monorepo\n   449â†’\n   450â†’While it is possible to use **Matador** outside of a monorepo environment, it is designed to work in a situation where you can easily share code between your applications.\n   451â†’This is because both the _publisher_ and the _consumer_ need to know about the event _schema_ (e.g. which events map to which subscribers).\n   452â†’\n   453â†’You can either share the code for your `MatadorSchema`, or you can make your workers simply be different instances of the same codebase (with different configuration).\n   454â†’\n   455â†’```ts\n   456â†’// Example: Dynamic configuration based on environment\n   457â†’const matador = new Matador(\n   458â†’  {\n   459â†’    transport,\n   460â†’    topology,\n   461â†’    schema: myMatadorSchema,\n   462â†’    // Only consume in worker mode\n   463â†’    consumeFrom: process.env.WORKER_MODE === 'true' ? ['events'] : [],\n   464â†’  },\n   465â†’  {\n   466â†’    // Dynamic hooks can use runtime config\n   467â†’    getAttempts: async (envelope) => {\n   468â†’      // High-importance events get more retries\n   469â†’      if (envelope.docket.importance === 'must-investigate') {\n   470â†’        return 5;\n   471â†’      }\n   472â†’      return 3;\n   473â†’    },\n   474â†’  }\n   475â†’);\n   476â†’```\n   477â†’\n   478â†’### You want `at-least-once` delivery.\n   479â†’\n   480â†’There are two options for delivery in an event system.\n   481â†’\n   482â†’- `at-least-once`: Every message is guaranteed to be delivered once, but may deliver more times in some edge-cases.\n   483â†’- `at-most-once`: Every message is guaranteed to be delivered at most once, but may not be delivered at all in some edge cases.\n   484â†’\n   485â†’Any system that promises `exactly-once` is lying to you, because there are always timeout scenarios in a distributed system that mean that there may still be a very small possibility of a message being either delivered multiple times (`at-least-once`) or not at all (`at-most-once`).\n   486â†’\n   487â†’The choice essentially comes down to when you `ack` (acknowledge) a message.\n   488â†’\n   489â†’- **Before processing**: `at-most-once`. If the worker crashes after ack but before completing, the message is lost.\n   490â†’- **After processing**: `at-least-once`. If the worker crashes after completing but before ack, the message may be redelivered.\n   491â†’\n   492â†’**Matador** uses `at-least-once` delivery by acknowledging messages only after successful processing.\n   493â†’\n   494â†’# Logging\n   495â†’\n   496â†’**Matador** uses a pluggable logger interface. You can provide your own logger via the `logger` hook:\n   497â†’\n   498â†’```ts\n   499â†’const matador = new Matador(config, {\n   500â†’  logger: {\n   501â†’    debug: (msg, ...args) => myLogger.debug(msg, ...args),\n   502â†’    info: (msg, ...args) => myLogger.info(msg, ...args),\n   503â†’    warn: (msg, ...args) => myLogger.warn(msg, ...args),\n   504â†’    error: (msg, ...args) => myLogger.error(msg, ...args),\n   505â†’  },\n   506â†’});\n   507â†’```\n   508â†’\n   509â†’### Log Messages by Level\n   510â†’\n   511â†’**Debug:**\n   512â†’\n   513â†’| Message                                               | Context                                            |\n   514â†’| ----------------------------------------------------- | -------------------------------------------------- |\n   515â†’| `[Matador] ðŸ”Œ Delayed message exchange plugin detected` | RabbitMQ delayed message plugin is available       |\n   516â†’\n   517â†’**Warn:**\n   518â†’\n   519â†’| Message                                                                   | Context                                                    |\n   520â†’| ------------------------------------------------------------------------- | ---------------------------------------------------------- |\n   521â†’| `[Matador] ðŸŸ¡ RabbitMQ delayed message exchange plugin not available...`  | RabbitMQ plugin not installed, delayed messages disabled   |\n   522â†’| `[Matador] âš ï¸ Shutdown timeout reached with N events still processing`    | Graceful shutdown timed out with pending events            |\n   523â†’| `[Matador] ðŸŸ¡ Hook onWorkerWrap threw an error`                           | The `onWorkerWrap` hook threw an exception                 |\n   524â†’| `[Matador] ðŸŸ¡ Hook loadUniversalMetadata threw an error`                  | The `loadUniversalMetadata` hook threw an exception        |\n   525â†’| `[Matador] ðŸŸ¡ Hook getQueueConcurrency threw an error`                    | The `getQueueConcurrency` hook threw an exception          |\n   526â†’| `[Matador] ðŸŸ¡ Hook getRetryDelay threw an error`                          | The `getRetryDelay` hook threw an exception                |\n   527â†’| `[Matador] ðŸŸ¡ Hook getAttempts threw an error`                            | The `getAttempts` hook threw an exception                  |\n   528â†’| `[Matador] ðŸŸ¡ Hook getMaxDeliveries threw an error`                       | The `getMaxDeliveries` hook threw an exception             |\n   529â†’| `[Matador] ðŸŸ¡ Hook {hookName} threw an error`                             | Any other lifecycle hook threw an exception                |\n   530â†’\n   531â†’**Error:**\n   532â†’\n   533â†’| Message                                               | Context                                                     |\n   534â†’| ----------------------------------------------------- | ----------------------------------------------------------- |\n   535â†’| `[Matador] ðŸ”´ RabbitMQ connection error`              | RabbitMQ connection encountered an error                    |\n   536â†’| `[Matador] ðŸ”´ RabbitMQ publish channel error`         | RabbitMQ publish channel encountered an error               |\n   537â†’| `[Matador] ðŸ”´ Handler error in message processing`    | Subscriber callback threw an unhandled exception            |\n   538â†’| `[Matador] ðŸ”´ Failed to enqueue delayed message`      | LocalTransport failed to enqueue a delayed message          |\n   539â†’\n   540â†’For application-level logging (event processing, success/failure tracking), use the lifecycle hooks (`onWorkerSuccess`, `onWorkerError`, `onEnqueueSuccess`, etc.).\n   541â†’\n   542â†’# Errors\n   543â†’\n   544â†’All errors in **Matador** extend `MatadorError` and include a `description` field explaining the cause and recommended action.\n   545â†’\n   546â†’| Error                             | Description                                                                                |\n   547â†’| --------------------------------- | ------------------------------------------------------------------------------------------ |\n   548â†’| `NotStartedError`                 | Matador has not been started. Call `matador.start()` first.                                |\n   549â†’| `ShutdownInProgressError`         | Matador is shutting down and will not accept new events.                                   |\n   550â†’| `TransportNotConnectedError`      | Transport is not connected to the message broker.                                          |\n   551â†’| `TransportClosedError`            | Transport has been closed (during shutdown).                                               |\n   552â†’| `AllTransportsFailedError`        | All transports in a fallback chain failed.                                                 |\n   553â†’| `TransportSendError`              | Failed to send a message through the transport.                                            |\n   554â†’| `DelayedMessagesNotSupportedError`| Delayed messages requested but transport doesn't support them.                             |\n   555â†’| `EventNotRegisteredError`         | Event type is not registered in the schema.                                                |\n   556â†’| `SubscriberNotRegisteredError`    | Subscriber is not registered for this event.                                               |\n   557â†’| `NoSubscribersExistError`         | Event has no subscribers registered.                                                       |\n   558â†’| `InvalidSchemaError`              | Schema configuration is invalid.                                                           |\n   559â†’| `SubscriberIsStubError`           | A SubscriberStub was registered in a consuming schema.                                     |\n   560â†’| `LocalTransportCannotProcessStubError` | LocalTransport cannot process events for SubscriberStubs.                             |\n   561â†’| `QueueNotFoundError`              | Queue does not exist or has not been created.                                              |\n   562â†’| `InvalidEventError`               | Event is invalid or missing required fields.                                               |\n   563â†’| `MessageMaybePoisonedError`       | Message redelivered too many times (possible poison message).                              |\n   564â†’| `IdempotentMessageCannotRetryError` | Non-idempotent subscriber received a redelivered message.                                |\n   565â†’| `TimeoutError`                    | Operation timed out before completing.                                                     |\n   566â†’\n   567â†’**Retry Control Errors** (thrown by subscribers to control retry behavior):\n   568â†’\n   569â†’| Error                | Description                                                                                    |\n   570â†’| -------------------- | ---------------------------------------------------------------------------------------------- |\n   571â†’| `DoRetry`            | Forces retry regardless of subscriber idempotency setting.                                     |\n   572â†’| `DontRetry`          | Prevents retry regardless of subscriber idempotency setting. Message goes to dead-letter.      |\n   573â†’| `EventAssertionError`| Assertion error that should never be retried. Goes directly to dead-letter queue.              |\n   574â†’\n   575â†’# Other features\n   576â†’\n   577â†’### `universalMetadata`\n   578â†’\n   579â†’It is often the case that you want every event to have a consistent set of metadata.\n   580â†’**Matador** provides a hook `loadUniversalMetadata` which you can use to do this.\n   581â†’\n   582â†’You can combine this with `asyncLocalStorage` to set session based metadata on your events.\n   583â†’\n   584â†’Here is a real world example:\n   585â†’\n   586â†’```ts\n   587â†’loadUniversalMetadata: () => {\n   588â†’  const store = asyncLocalStorage?.getStore()\n   589â†’  return {\n   590â†’    timestamp: new Date(),\n   591â†’    correlationId: store?.correlationId || null,\n   592â†’    userId: store?.userId || null,\n   593â†’  }\n   594â†’},\n   595â†’```\n   596â†’\n   597â†’### Schema plugins\n   598â†’\n   599â†’Sometimes, you want to run a subscriber on every event in your _schema_.\n   600â†’Instead of defining the subscriber mapping for every event, you can use `installPlugins` to add global subscribers:\n   601â†’\n   602â†’```ts\n   603â†’import { installPlugins } from '@meetsmore/matador-v2';\n   604â†’\n   605â†’const baseSchema: MatadorSchema = {\n   606â†’  [UserCreatedEvent.key]: [UserCreatedEvent, [sendWelcomeEmail]],\n   607â†’  [OrderPlacedEvent.key]: [OrderPlacedEvent, [processOrder]],\n   608â†’  [ChatMessageSentEvent.key]: [ChatMessageSentEvent, [notifyRecipient]],\n   609â†’};\n   610â†’\n   611â†’const myMatadorSchema = installPlugins(baseSchema, [\n   612â†’  {\n   613â†’    subscriber: logToBigQuery,\n   614â†’    exclusions: [ChatMessageSentEvent.key], // Don't log chat messages\n   615â†’  }\n   616â†’]);\n   617â†’```\n   618â†’\n   619â†’Each plugin defines a `subscriber` and optional `exclusions` array of event keys to skip.\n   620â†’\n   621â†’### `DoRetry` & `DontRetry`\n   622â†’\n   623â†’Sometimes, your subscribers may want to explicitly control if they should be retried or not.\n   624â†’This is useful in cases where a message is _sometimes_ idempotent, but in certain cases (e.g. error scenarios) it is not.\n   625â†’\n   626â†’```ts\n   627â†’import { DoRetry, DontRetry } from '@meetsmore/matador-v2';\n   628â†’\n   629â†’const processPayment: Subscriber<PaymentRequestedEvent> = {\n   630â†’  name: 'process-payment',\n   631â†’  idempotent: 'no', // Default: don't retry\n   632â†’  callback: async (envelope) => {\n   633â†’    try {\n   634â†’      await paymentGateway.charge(envelope.data.amount);\n   635â†’    } catch (error) {\n   636â†’      if (error.code === 'TEMPORARY_FAILURE') {\n   637â†’        // Gateway is temporarily unavailable, safe to retry\n   638â†’        throw new DoRetry('Payment gateway temporarily unavailable');\n   639â†’      }\n   640â†’      if (error.code === 'CARD_DECLINED') {\n   641â†’        // Permanent failure, don't retry\n   642â†’        throw new DontRetry('Card was declined');\n   643â†’      }\n   644â†’      throw error; // Default behavior based on idempotent setting\n   645â†’    }\n   646â†’  },\n   647â†’};\n   648â†’```\n   649â†’\n   650â†’### `LocalTransport`\n   651â†’\n   652â†’Matador includes a `LocalTransport`, which is an in-memory transport that will simply process events on the same machine.\n   653â†’This allows you to develop locally without having a message broker, then simply switch to using an actual message broker when you deploy.\n   654â†’\n   655â†’### `MultiTransport`\n   656â†’\n   657â†’`MultiTransport` allows you to declare a group of transports, and then switch between them at runtime.\n   658â†’\n   659â†’You can also use configure it with `fallbackEnabled` (default: `true`), and if enqueuing a message fails, it can fallback to another queue system (in declared order).\n   660â†’\n   661â†’You can combine this with `LocalTransport` to make messages that fail to enqueue execute locally, providing resilience against your message broker being unavailable or timing out.\n   662â†’\n   663â†’```ts\n   664â†’import { MultiTransport, RabbitMQTransport, LocalTransport } from '@meetsmore/matador-v2';\n   665â†’\n   666â†’const rabbitTransport = new RabbitMQTransport({ url: 'amqp://localhost' });\n   667â†’const localTransport = new LocalTransport();\n   668â†’\n   669â†’const transport = new MultiTransport(\n   670â†’  {\n   671â†’    transports: [rabbitTransport, localTransport],\n   672â†’    fallbackEnabled: true, // Default: true\n   673â†’  },\n   674â†’  {\n   675â†’    // Optional: dynamically select backend based on feature flags\n   676â†’    getDesiredBackend: async () => {\n   677â†’      if (process.env.SANDBOX === 'true') return 'local';\n   678â†’      const useLocal = await featureFlags.isEnabled('use-local-transport');\n   679â†’      return useLocal ? 'local' : 'rabbitmq';\n   680â†’    },\n   681â†’    // Optional: log when fallback occurs\n   682â†’    onEnqueueFallback: (ctx) => {\n   683â†’      console.warn(`Fallback from ${ctx.failedTransport} to ${ctx.nextTransport}: ${ctx.error.message}`);\n   684â†’    },\n   685â†’  }\n   686â†’);\n   687â†’\n   688â†’const matador = new Matador({\n   689â†’  transport,\n   690â†’  topology,\n   691â†’  schema,\n   692â†’  consumeFrom: ['events'],\n   693â†’});\n   694â†’```\n   695â†’\n   696â†’### `enabled()` hook for `Subscriber`\n   697â†’\n   698â†’Sometimes, you want to enable / disable subscribers at runtime using feature flags.\n   699â†’\n   700â†’Each subscriber accepts an `enabled()` callback, which is invoked before **publishing** an event for that subscriber. If `enabled()` returns `false`, the message is not sent for that subscriber (it's skipped during fanout). If the check fails with an error, the subscriber is treated as enabled.\n   701â†’\n   702â†’```ts\n   703â†’const sendWelcomeEmail: Subscriber<UserCreatedEvent> = {\n   704â†’  name: 'send-welcome-email',\n   705â†’  idempotent: 'yes',\n   706â†’  enabled: async () => {\n   707â†’    // Check feature flag\n   708â†’    return await featureFlags.isEnabled('welcome-email-v2');\n   709â†’  },\n   710â†’  callback: async (envelope) => {\n   711â†’    await emailService.sendWelcome(envelope.data.email);\n   712â†’  },\n   713â†’};\n   714â†’\n   715â†’// Sync enabled check is also supported\n   716â†’const legacySubscriber: Subscriber<UserCreatedEvent> = {\n   717â†’  name: 'legacy-handler',\n   718â†’  enabled: () => process.env.ENABLE_LEGACY === 'true',\n   719â†’  callback: async (envelope) => { /* ... */ },\n   720â†’};\n   721â†’```\n   722â†’\n   723â†’### `importance`\n   724â†’\n   725â†’`importance` is an optional field that allows you to note how critical a subscriber failure is.\n   726â†’This is useful for setting up alerts in your observability platform.\n   727â†’\n   728â†’For example, if an analytics event fails, it is likely unimportant, but if a payment related subscriber fails, it warrants investigation and should trigger an alert.\n   729â†’\n   730â†’Available importance levels:\n   731â†’- `'can-ignore'` - Failures are not critical (e.g., analytics, logging)\n   732â†’- `'should-investigate'` - Failures should be reviewed (default)\n   733â†’- `'must-investigate'` - Failures are critical and require immediate attention (e.g., payments)\n   734â†’\n   735â†’```ts\n   736â†’const trackAnalytics: Subscriber<UserCreatedEvent> = {\n   737â†’  name: 'track-analytics',\n   738â†’  importance: 'can-ignore', // Don't alert on failures\n   739â†’  callback: async (envelope) => {\n   740â†’    await analytics.track('user_created', envelope.data);\n   741â†’  },\n   742â†’};\n   743â†’\n   744â†’const processPayment: Subscriber<PaymentRequestedEvent> = {\n   745â†’  name: 'process-payment',\n   746â†’  importance: 'must-investigate', // Critical - alert immediately on failures\n   747â†’  callback: async (envelope) => {\n   748â†’    await paymentGateway.charge(envelope.data);\n   749â†’  },\n   750â†’};\n   751â†’\n   752â†’// Use in hooks for alerting\n   753â†’const matador = new Matador(config, {\n   754â†’  onWorkerError: (ctx) => {\n   755â†’    if (ctx.subscriber.importance === 'must-investigate') {\n   756â†’      alerting.critical(`Subscriber ${ctx.subscriber.name} failed: ${ctx.error.message}`);\n   757â†’    }\n   758â†’  },\n   759â†’});\n   760â†’```\n   761â†’\n   762â†’### Delayed messages\n   763â†’\n   764â†’> Delayed messages implementation is dependent on the `Transport` used.\n   765â†’\n   766â†’You can optionally delay messages in Matador. This will cause their delivery to be delayed.\n   767â†’\n   768â†’When using `RabbitMQTransport`, this is implemented using the [delayed-message-exchange plugin](https://github.com/rabbitmq/rabbitmq-delayed-message-exchange), and you should ensure it is installed in your RabbitMQ instance first.\n   769â†’\n   770â†’> Note: Distributed event systems do not have precise delivery timings. The consumption of your event will be dependent on your throughput, and you should not depend on delayed messages for accurate timings.\n   771â†’\n   772â†’```ts\n   773â†’// Delay message by 5 minutes\n   774â†’await matador.send(ReminderEvent, { userId: '123', message: 'Hello!' }, {\n   775â†’  delayMs: 5 * 60 * 1000, // 5 minutes\n   776â†’});\n   777â†’\n   778â†’// Delay can also be used with correlationId and metadata\n   779â†’await matador.send(ScheduledNotificationEvent, notificationData, {\n   780â†’  delayMs: 60000, // 1 minute\n   781â†’  correlationId: 'notification-123',\n   782â†’  metadata: { scheduledBy: 'cron-job' },\n   783â†’});\n   784â†’```\n   785â†’\n   786â†’# CLI\n   787â†’\n   788â†’Matador provides a CLI utility for quick local testing of your Matador configuration.\n   789â†’\n   790â†’```bash\n   791â†’# Send an event using config and event files\n   792â†’bunx matador send <config-file> <event-file> [options]\n   793â†’\n   794â†’# Send a test event defined in the config file\n   795â†’bunx matador send-test-event <config-file> [options]\n   796â†’```\n   797â†’\n   798â†’**Options:**\n   799â†’- `--help, -h` - Show help message\n   800â†’- `--dry-run` - Validate config and event without dispatching\n   801â†’- `--timeout` - Timeout in milliseconds for processing (default: 5000)\n   802â†’- `--verbose` - Show verbose output including all hook logs\n   803â†’\n   804â†’**Config file** should export:\n   805â†’- `schema: MatadorSchema` - Map of event keys to [EventClass, Subscribers[]]\n   806â†’- `topology?: Topology` - Optional topology (defaults to simple 'events' queue)\n   807â†’- `hooks?: MatadorHooks` - Optional hooks\n   808â†’- `testEvent?: { eventKey, data, before?, options? }` - Test event for `send-test-event` command\n   809â†’\n   810â†’**Event file** should export:\n   811â†’- `eventKey: string` - The key of the event to dispatch\n   812â†’- `data: unknown` - The event data payload\n   813â†’- `before?: unknown` - Optional 'before' data for change events\n   814â†’- `options?: EventOptions` - Optional dispatch options (correlationId, metadata, delayMs)\n   815â†’\n   816â†’**Examples:**\n   817â†’```bash\n   818â†’bunx matador send ./my-config.ts ./test-event.ts --verbose\n   819â†’bunx matador send-test-event ./my-config.ts\n   820â†’```\n   821â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T15:56:11.062Z"
        },
        {
          "type": "assistant",
          "text": "Let me read the checkpoint implementation files to understand how `io` works and what a proper example would look like:",
          "timestamp": "2025-12-11T15:56:14.875Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/checkpoint/types.ts"
          },
          "timestamp": "2025-12-11T15:56:15.442Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/checkpoint/context.ts"
          },
          "timestamp": "2025-12-11T15:56:15.925Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/types/subscriber.ts"
          },
          "timestamp": "2025-12-11T15:56:16.401Z"
        },
        {
          "type": "user",
          "text": "     1â†’import type { Envelope, SubscriberDefinition } from '../types/index.js';\n     2â†’\n     3â†’/**\n     4â†’ * Type constraint ensuring values can be JSON serialized.\n     5â†’ * Used to enforce type safety for io() return values.\n     6â†’ */\n     7â†’export type JsonSerializable =\n     8â†’  | string\n     9â†’  | number\n    10â†’  | boolean\n    11â†’  | null\n    12â†’  | JsonSerializable[]\n    13â†’  | { [key: string]: JsonSerializable };\n    14â†’\n    15â†’/**\n    16â†’ * Checkpoint data persisted between retries.\n    17â†’ * Contains cached results from completed io() operations.\n    18â†’ */\n    19â†’export interface Checkpoint {\n    20â†’  /** Unique envelope ID this checkpoint belongs to */\n    21â†’  readonly envelopeId: string;\n    22â†’\n    23â†’  /** Subscriber name (for debugging/admin) */\n    24â†’  readonly subscriberName: string;\n    25â†’\n    26â†’  /** Map of io() keys to their cached results */\n    27â†’  readonly completedSteps: Record<string, JsonSerializable>;\n    28â†’}\n    29â†’\n    30â†’/**\n    31â†’ * Interface for checkpoint persistence.\n    32â†’ * Implementations must handle concurrent access safely.\n    33â†’ */\n    34â†’export interface CheckpointStore {\n    35â†’  /**\n    36â†’   * Retrieve checkpoint for an envelope.\n    37â†’   * @param envelopeId - Unique envelope identifier\n    38â†’   * @returns Checkpoint if exists, undefined otherwise\n    39â†’   */\n    40â†’  get(envelopeId: string): Promise<Checkpoint | undefined>;\n    41â†’\n    42â†’  /**\n    43â†’   * Save or update checkpoint.\n    44â†’   * @param envelopeId - Unique envelope identifier\n    45â†’   * @param checkpoint - Checkpoint data to persist\n    46â†’   */\n    47â†’  set(envelopeId: string, checkpoint: Checkpoint): Promise<void>;\n    48â†’\n    49â†’  /**\n    50â†’   * Delete checkpoint (on success or dead-letter).\n    51â†’   * @param envelopeId - Unique envelope identifier\n    52â†’   */\n    53â†’  delete(envelopeId: string): Promise<void>;\n    54â†’\n    55â†’  /**\n    56â†’   * Optional: TTL-based cleanup for orphaned checkpoints.\n    57â†’   * @param olderThan - Delete checkpoints older than this date\n    58â†’   * @returns Number of checkpoints deleted\n    59â†’   */\n    60â†’  cleanup?(olderThan: Date): Promise<number>;\n    61â†’}\n    62â†’\n    63â†’/**\n    64â†’ * Context provided to resumable subscriber callbacks.\n    65â†’ * Contains the io() function for checkpointed operations.\n    66â†’ */\n    67â†’export interface SubscriberContext {\n    68â†’  /**\n    69â†’   * Wraps a side-effectful operation for caching/replay.\n    70â†’   * On first execution: runs the lambda and caches the result.\n    71â†’   * On retry: returns cached result without re-executing.\n    72â†’   *\n    73â†’   * @param key - Unique identifier for this operation within this subscriber.\n    74â†’   *              Must be stable across retries. Use descriptive names like\n    75â†’   *              'fetch-user', 'send-email', 'charge-payment'.\n    76â†’   * @param fn - The side-effectful operation to execute\n    77â†’   * @returns The result of fn (or cached result on retry)\n    78â†’   * @throws DuplicateIoKeyError if key was already used in this execution\n    79â†’   */\n    80â†’  io<T extends JsonSerializable>(\n    81â†’    key: string,\n    82â†’    fn: () => Promise<T> | T,\n    83â†’  ): Promise<T>;\n    84â†’\n    85â†’  /**\n    86â†’   * Execute multiple io() operations in parallel.\n    87â†’   * Each operation requires its own unique key.\n    88â†’   *\n    89â†’   * @param ops - Array of [key, fn] tuples to execute in parallel\n    90â†’   * @returns Array of results in the same order as input\n    91â†’   */\n    92â†’  all<\n    93â†’    T extends readonly [\n    94â†’      string,\n    95â†’      () => Promise<JsonSerializable> | JsonSerializable,\n    96â†’    ][],\n    97â†’  >(\n    98â†’    ops: T,\n    99â†’  ): Promise<{\n   100â†’    [K in keyof T]: T[K] extends [string, () => Promise<infer R> | infer R]\n   101â†’      ? R\n   102â†’      : never;\n   103â†’  }>;\n   104â†’\n   105â†’  /** Current attempt number (1-based) */\n   106â†’  readonly attempt: number;\n   107â†’\n   108â†’  /** Whether this is a retry (attempt > 1) */\n   109â†’  readonly isRetry: boolean;\n   110â†’}\n   111â†’\n   112â†’/**\n   113â†’ * Context for checkpoint loaded hook.\n   114â†’ */\n   115â†’export interface CheckpointLoadedContext {\n   116â†’  readonly envelope: Envelope;\n   117â†’  readonly subscriber: SubscriberDefinition;\n   118â†’  readonly checkpoint: Checkpoint;\n   119â†’  readonly cachedSteps: number;\n   120â†’}\n   121â†’\n   122â†’/**\n   123â†’ * Context for checkpoint hit hook (cache used).\n   124â†’ */\n   125â†’export interface CheckpointHitContext {\n   126â†’  readonly envelope: Envelope;\n   127â†’  readonly subscriber: SubscriberDefinition;\n   128â†’  readonly stepKey: string;\n   129â†’}\n   130â†’\n   131â†’/**\n   132â†’ * Context for checkpoint miss hook (operation executed).\n   133â†’ */\n   134â†’export interface CheckpointMissContext {\n   135â†’  readonly envelope: Envelope;\n   136â†’  readonly subscriber: SubscriberDefinition;\n   137â†’  readonly stepKey: string;\n   138â†’}\n   139â†’\n   140â†’/**\n   141â†’ * Context for checkpoint cleared hook.\n   142â†’ */\n   143â†’export interface CheckpointClearedContext {\n   144â†’  readonly envelope: Envelope;\n   145â†’  readonly subscriber: SubscriberDefinition;\n   146â†’  readonly reason: 'success' | 'dead-letter';\n   147â†’}\n   148â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T15:56:16.487Z"
        },
        {
          "type": "user",
          "text": "     1â†’import type { Envelope, SubscriberDefinition } from '../types/index.js';\n     2â†’import { DuplicateIoKeyError } from './errors.js';\n     3â†’import type {\n     4â†’  Checkpoint,\n     5â†’  CheckpointHitContext,\n     6â†’  CheckpointMissContext,\n     7â†’  CheckpointStore,\n     8â†’  JsonSerializable,\n     9â†’  SubscriberContext,\n    10â†’} from './types.js';\n    11â†’\n    12â†’/**\n    13â†’ * Hooks for observability during context operations.\n    14â†’ */\n    15â†’export interface ResumableContextHooks {\n    16â†’  onCheckpointHit?(context: CheckpointHitContext): void | Promise<void>;\n    17â†’  onCheckpointMiss?(context: CheckpointMissContext): void | Promise<void>;\n    18â†’}\n    19â†’\n    20â†’/**\n    21â†’ * Configuration for creating a ResumableContext.\n    22â†’ */\n    23â†’export interface ResumableContextConfig {\n    24â†’  readonly store: CheckpointStore;\n    25â†’  readonly envelope: Envelope;\n    26â†’  readonly subscriber: SubscriberDefinition;\n    27â†’  readonly existingCheckpoint?: Checkpoint | undefined;\n    28â†’  readonly hooks?: ResumableContextHooks | undefined;\n    29â†’}\n    30â†’\n    31â†’/**\n    32â†’ * Implementation of SubscriberContext that provides io() caching.\n    33â†’ *\n    34â†’ * On first execution, io() calls execute their lambdas and cache results.\n    35â†’ * On retry (when existingCheckpoint is provided), cached results are returned\n    36â†’ * without re-executing the lambda.\n    37â†’ */\n    38â†’export class ResumableContext implements SubscriberContext {\n    39â†’  private checkpoint: Checkpoint;\n    40â†’  private readonly usedKeys = new Set<string>();\n    41â†’  private readonly store: CheckpointStore;\n    42â†’  private readonly envelope: Envelope;\n    43â†’  private readonly subscriber: SubscriberDefinition;\n    44â†’  private readonly hooks: ResumableContextHooks | undefined;\n    45â†’\n    46â†’  constructor(config: ResumableContextConfig) {\n    47â†’    this.store = config.store;\n    48â†’    this.envelope = config.envelope;\n    49â†’    this.subscriber = config.subscriber;\n    50â†’    this.hooks = config.hooks;\n    51â†’\n    52â†’    this.checkpoint = config.existingCheckpoint ?? {\n    53â†’      envelopeId: config.envelope.id,\n    54â†’      subscriberName: config.subscriber.name,\n    55â†’      completedSteps: {},\n    56â†’    };\n    57â†’  }\n    58â†’\n    59â†’  get attempt(): number {\n    60â†’    return this.envelope.docket.attempts;\n    61â†’  }\n    62â†’\n    63â†’  get isRetry(): boolean {\n    64â†’    return this.attempt > 1;\n    65â†’  }\n    66â†’\n    67â†’  async io<T extends JsonSerializable>(\n    68â†’    key: string,\n    69â†’    fn: () => Promise<T> | T,\n    70â†’  ): Promise<T> {\n    71â†’    // Validate key uniqueness within this execution\n    72â†’    if (this.usedKeys.has(key)) {\n    73â†’      throw new DuplicateIoKeyError(key, this.subscriber.name);\n    74â†’    }\n    75â†’    this.usedKeys.add(key);\n    76â†’\n    77â†’    // Check cache first\n    78â†’    if (key in this.checkpoint.completedSteps) {\n    79â†’      await this.hooks?.onCheckpointHit?.({\n    80â†’        envelope: this.envelope,\n    81â†’        subscriber: this.subscriber,\n    82â†’        stepKey: key,\n    83â†’      });\n    84â†’      return this.checkpoint.completedSteps[key] as T;\n    85â†’    }\n    86â†’\n    87â†’    // Notify cache miss\n    88â†’    await this.hooks?.onCheckpointMiss?.({\n    89â†’      envelope: this.envelope,\n    90â†’      subscriber: this.subscriber,\n    91â†’      stepKey: key,\n    92â†’    });\n    93â†’\n    94â†’    // Execute the function - errors propagate, no caching on failure\n    95â†’    const result = await fn();\n    96â†’\n    97â†’    // Cache the result\n    98â†’    this.checkpoint = {\n    99â†’      ...this.checkpoint,\n   100â†’      completedSteps: {\n   101â†’        ...this.checkpoint.completedSteps,\n   102â†’        [key]: result,\n   103â†’      },\n   104â†’    };\n   105â†’\n   106â†’    // Persist checkpoint immediately (incremental persistence)\n   107â†’    await this.store.set(this.envelope.id, this.checkpoint);\n   108â†’\n   109â†’    return result;\n   110â†’  }\n   111â†’\n   112â†’  async all<\n   113â†’    T extends readonly [\n   114â†’      string,\n   115â†’      () => Promise<JsonSerializable> | JsonSerializable,\n   116â†’    ][],\n   117â†’  >(\n   118â†’    ops: T,\n   119â†’  ): Promise<{\n   120â†’    [K in keyof T]: T[K] extends [string, () => Promise<infer R> | infer R]\n   121â†’      ? R\n   122â†’      : never;\n   123â†’  }> {\n   124â†’    // First, check for duplicates within this all() call\n   125â†’    const keysInThisCall = new Set<string>();\n   126â†’    for (const [key] of ops) {\n   127â†’      if (keysInThisCall.has(key)) {\n   128â†’        throw new DuplicateIoKeyError(key, this.subscriber.name);\n   129â†’      }\n   130â†’      keysInThisCall.add(key);\n   131â†’    }\n   132â†’\n   133â†’    // Then validate against previously used keys\n   134â†’    for (const [key] of ops) {\n   135â†’      if (this.usedKeys.has(key)) {\n   136â†’        throw new DuplicateIoKeyError(key, this.subscriber.name);\n   137â†’      }\n   138â†’    }\n   139â†’\n   140â†’    // Mark all keys as used\n   141â†’    for (const [key] of ops) {\n   142â†’      this.usedKeys.add(key);\n   143â†’    }\n   144â†’\n   145â†’    // Execute all operations in parallel\n   146â†’    const results = await Promise.all(\n   147â†’      ops.map(async ([key, fn]) => {\n   148â†’        // Check cache first\n   149â†’        if (key in this.checkpoint.completedSteps) {\n   150â†’          await this.hooks?.onCheckpointHit?.({\n   151â†’            envelope: this.envelope,\n   152â†’            subscriber: this.subscriber,\n   153â†’            stepKey: key,\n   154â†’          });\n   155â†’          return this.checkpoint.completedSteps[key];\n   156â†’        }\n   157â†’\n   158â†’        // Notify cache miss\n   159â†’        await this.hooks?.onCheckpointMiss?.({\n   160â†’          envelope: this.envelope,\n   161â†’          subscriber: this.subscriber,\n   162â†’          stepKey: key,\n   163â†’        });\n   164â†’\n   165â†’        // Execute - errors propagate\n   166â†’        const result = await fn();\n   167â†’\n   168â†’        // Cache individually (in local state, will persist after Promise.all)\n   169â†’        this.checkpoint = {\n   170â†’          ...this.checkpoint,\n   171â†’          completedSteps: {\n   172â†’            ...this.checkpoint.completedSteps,\n   173â†’            [key]: result,\n   174â†’          },\n   175â†’        };\n   176â†’\n   177â†’        return result;\n   178â†’      }),\n   179â†’    );\n   180â†’\n   181â†’    // Persist after all parallel operations complete\n   182â†’    await this.store.set(this.envelope.id, this.checkpoint);\n   183â†’\n   184â†’    return results as {\n   185â†’      [K in keyof T]: T[K] extends [string, () => Promise<infer R> | infer R]\n   186â†’        ? R\n   187â†’        : never;\n   188â†’    };\n   189â†’  }\n   190â†’\n   191â†’  /**\n   192â†’   * Clears the checkpoint from storage.\n   193â†’   * Called after successful completion or dead-letter.\n   194â†’   */\n   195â†’  async clear(): Promise<void> {\n   196â†’    await this.store.delete(this.envelope.id);\n   197â†’  }\n   198â†’\n   199â†’  /**\n   200â†’   * Gets the current checkpoint state.\n   201â†’   * Useful for debugging and testing.\n   202â†’   */\n   203â†’  getCheckpoint(): Checkpoint {\n   204â†’    return this.checkpoint;\n   205â†’  }\n   206â†’\n   207â†’  /**\n   208â†’   * Gets the number of cached steps.\n   209â†’   */\n   210â†’  get cachedStepCount(): number {\n   211â†’    return Object.keys(this.checkpoint.completedSteps).length;\n   212â†’  }\n   213â†’}\n   214â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T15:56:16.487Z"
        },
        {
          "type": "user",
          "text": "     1â†’import type { SubscriberContext } from '../checkpoint/index.js';\n     2â†’import type { Idempotency, Importance } from './common.js';\n     3â†’import type { Envelope } from './envelope.js';\n     4â†’import type { MatadorEvent } from './event.js';\n     5â†’\n     6â†’/**\n     7â†’ * Helper type to get the envelope type for a subscriber callback.\n     8â†’ * Extracts the data type from a MatadorEvent and wraps it in an Envelope.\n     9â†’ *\n    10â†’ * @example\n    11â†’ * async callback(envelope: EnvelopeOf<MyEvent>) {\n    12â†’ *   console.log(envelope.data.someField); // Type-safe access\n    13â†’ * }\n    14â†’ */\n    15â†’export type EnvelopeOf<T extends MatadorEvent> = Envelope<T['data']>;\n    16â†’\n    17â†’/**\n    18â†’ * Callback function executed when an event is received (standard subscribers).\n    19â†’ * Receives the full envelope containing id, data, and docket.\n    20â†’ */\n    21â†’export type StandardCallback<T = unknown> = (\n    22â†’  envelope: Envelope<T>,\n    23â†’) => Promise<void> | void;\n    24â†’\n    25â†’/**\n    26â†’ * Callback function for resumable subscribers.\n    27â†’ * Receives the envelope and a SubscriberContext with io() for checkpointed operations.\n    28â†’ */\n    29â†’export type ResumableCallback<T = unknown> = (\n    30â†’  envelope: Envelope<T>,\n    31â†’  context: SubscriberContext,\n    32â†’) => Promise<void> | void;\n    33â†’\n    34â†’/**\n    35â†’ * Callback function executed when an event is received.\n    36â†’ * @deprecated Use StandardCallback or ResumableCallback instead.\n    37â†’ */\n    38â†’export type SubscriberCallback<T = unknown> = StandardCallback<T>;\n    39â†’\n    40â†’/**\n    41â†’ * Base configuration options shared by all subscriber types.\n    42â†’ */\n    43â†’export interface BaseSubscriberOptions {\n    44â†’  /** Route this subscriber's events to a specific queue */\n    45â†’  readonly targetQueue?: string | undefined;\n    46â†’\n    47â†’  /** Importance level for monitoring and alerting */\n    48â†’  readonly importance?: Importance | undefined;\n    49â†’\n    50â†’  /** Feature flag function to conditionally enable/disable the subscriber */\n    51â†’  readonly enabled?: (() => boolean | Promise<boolean>) | undefined;\n    52â†’}\n    53â†’\n    54â†’/**\n    55â†’ * Options for standard (non-resumable) subscribers.\n    56â†’ */\n    57â†’export interface StandardSubscriberOptions extends BaseSubscriberOptions {\n    58â†’  /** Idempotency declaration for retry handling (non-resumable) */\n    59â†’  readonly idempotent?: 'yes' | 'no' | 'unknown' | undefined;\n    60â†’}\n    61â†’\n    62â†’/**\n    63â†’ * Options for resumable subscribers that use io() for checkpointed operations.\n    64â†’ */\n    65â†’export interface ResumableSubscriberOptions extends BaseSubscriberOptions {\n    66â†’  /** Must be 'resumable' to enable checkpoint-based idempotency */\n    67â†’  readonly idempotent: 'resumable';\n    68â†’}\n    69â†’\n    70â†’/**\n    71â†’ * Configuration options for a subscriber.\n    72â†’ * Discriminated union based on idempotent value.\n    73â†’ */\n    74â†’export type SubscriberOptions =\n    75â†’  | StandardSubscriberOptions\n    76â†’  | ResumableSubscriberOptions;\n    77â†’\n    78â†’/**\n    79â†’ * Standard subscriber definition with standard callback.\n    80â†’ */\n    81â†’export interface StandardSubscriber<T extends MatadorEvent>\n    82â†’  extends StandardSubscriberOptions {\n    83â†’  /** Human-readable name for the subscriber */\n    84â†’  readonly name: string;\n    85â†’\n    86â†’  /** Callback function to execute when event is received */\n    87â†’  readonly callback: StandardCallback<T['data']>;\n    88â†’}\n    89â†’\n    90â†’/**\n    91â†’ * Resumable subscriber definition with resumable callback.\n    92â†’ */\n    93â†’export interface ResumableSubscriber<T extends MatadorEvent>\n    94â†’  extends ResumableSubscriberOptions {\n    95â†’  /** Human-readable name for the subscriber */\n    96â†’  readonly name: string;\n    97â†’\n    98â†’  /** Callback function with SubscriberContext for checkpointed operations */\n    99â†’  readonly callback: ResumableCallback<T['data']>;\n   100â†’}\n   101â†’\n   102â†’/**\n   103â†’ * Full subscriber definition with callback (either standard or resumable).\n   104â†’ */\n   105â†’export type Subscriber<T extends MatadorEvent> =\n   106â†’  | StandardSubscriber<T>\n   107â†’  | ResumableSubscriber<T>;\n   108â†’\n   109â†’/**\n   110â†’ * Subscriber stub for multi-codebase scenarios where subscriber implementation\n   111â†’ * is in a remote service. Declares the subscriber contract without providing\n   112â†’ * the callback.\n   113â†’ */\n   114â†’export interface SubscriberStub extends StandardSubscriberOptions {\n   115â†’  /** Human-readable name for the subscriber */\n   116â†’  readonly name: string;\n   117â†’\n   118â†’  /** Indicates this is a stub without implementation */\n   119â†’  readonly isStub: true;\n   120â†’}\n   121â†’\n   122â†’/**\n   123â†’ * Union type for any subscriber definition (full or stub).\n   124â†’ * This is the type-erased version for use in collections and schema.\n   125â†’ * Uses `any` because Subscriber<T> is contravariant in T (callback parameter),\n   126â†’ * making it impossible to assign Subscriber<SpecificEvent> to Subscriber<MatadorEvent<unknown>>.\n   127â†’ */\n   128â†’// biome-ignore lint/suspicious/noExplicitAny: Required for variance compatibility in heterogeneous collections\n   129â†’export type AnySubscriber = Subscriber<MatadorEvent<any>> | SubscriberStub;\n   130â†’\n   131â†’/**\n   132â†’ * Type guard to check if a subscriber is a stub.\n   133â†’ */\n   134â†’export function isSubscriberStub(\n   135â†’  subscriber: AnySubscriber,\n   136â†’): subscriber is SubscriberStub {\n   137â†’  return 'isStub' in subscriber && subscriber.isStub === true;\n   138â†’}\n   139â†’\n   140â†’/**\n   141â†’ * Type guard to check if a subscriber has a callback implementation.\n   142â†’ */\n   143â†’export function isSubscriber(\n   144â†’  subscriber: AnySubscriber,\n   145â†’  // biome-ignore lint/suspicious/noExplicitAny: Required for variance compatibility\n   146â†’): subscriber is Subscriber<MatadorEvent<any>> {\n   147â†’  return 'callback' in subscriber && typeof subscriber.callback === 'function';\n   148â†’}\n   149â†’\n   150â†’/**\n   151â†’ * Type guard to check if a subscriber is resumable.\n   152â†’ */\n   153â†’export function isResumableSubscriber(\n   154â†’  subscriber: AnySubscriber,\n   155â†’  // biome-ignore lint/suspicious/noExplicitAny: Required for variance compatibility\n   156â†’): subscriber is ResumableSubscriber<MatadorEvent<any>> {\n   157â†’  return isSubscriber(subscriber) && subscriber.idempotent === 'resumable';\n   158â†’}\n   159â†’\n   160â†’/**\n   161â†’ * Type guard to check if a subscriber is a standard (non-resumable) subscriber.\n   162â†’ */\n   163â†’export function isStandardSubscriber(\n   164â†’  subscriber: AnySubscriber,\n   165â†’  // biome-ignore lint/suspicious/noExplicitAny: Required for variance compatibility\n   166â†’): subscriber is StandardSubscriber<MatadorEvent<any>> {\n   167â†’  return isSubscriber(subscriber) && subscriber.idempotent !== 'resumable';\n   168â†’}\n   169â†’\n   170â†’/**\n   171â†’ * Input options for createSubscriber with standard callback.\n   172â†’ */\n   173â†’export interface CreateStandardSubscriberInput<T extends MatadorEvent> {\n   174â†’  readonly name: string;\n   175â†’  readonly callback: StandardCallback<T['data']>;\n   176â†’  readonly idempotent?: 'yes' | 'no' | 'unknown' | undefined;\n   177â†’  readonly importance?: Importance | undefined;\n   178â†’  readonly targetQueue?: string | undefined;\n   179â†’  readonly enabled?: (() => boolean | Promise<boolean>) | undefined;\n   180â†’}\n   181â†’\n   182â†’/**\n   183â†’ * Input options for createSubscriber with resumable callback.\n   184â†’ */\n   185â†’export interface CreateResumableSubscriberInput<T extends MatadorEvent> {\n   186â†’  readonly name: string;\n   187â†’  readonly callback: ResumableCallback<T['data']>;\n   188â†’  readonly idempotent: 'resumable';\n   189â†’  readonly importance?: Importance | undefined;\n   190â†’  readonly targetQueue?: string | undefined;\n   191â†’  readonly enabled?: (() => boolean | Promise<boolean>) | undefined;\n   192â†’}\n   193â†’\n   194â†’/**\n   195â†’ * Input options for createSubscriber (discriminated union).\n   196â†’ */\n   197â†’export type CreateSubscriberInput<T extends MatadorEvent> =\n   198â†’  | CreateStandardSubscriberInput<T>\n   199â†’  | CreateResumableSubscriberInput<T>;\n   200â†’\n   201â†’/**\n   202â†’ * Creates a subscriber definition.\n   203â†’ *\n   204â†’ * @example Standard subscriber (new API)\n   205â†’ * ```typescript\n   206â†’ * const subscriber = createSubscriber<MyEvent>({\n   207â†’ *   name: 'my-subscriber',\n   208â†’ *   callback: async (envelope) => {\n   209â†’ *     console.log(envelope.data);\n   210â†’ *   },\n   211â†’ * });\n   212â†’ * ```\n   213â†’ *\n   214â†’ * @example Standard subscriber (legacy API)\n   215â†’ * ```typescript\n   216â†’ * const subscriber = createSubscriber<MyEvent>(\n   217â†’ *   'my-subscriber',\n   218â†’ *   async (envelope) => console.log(envelope.data),\n   219â†’ *   { idempotent: 'yes' },\n   220â†’ * );\n   221â†’ * ```\n   222â†’ *\n   223â†’ * @example Resumable subscriber with io()\n   224â†’ * ```typescript\n   225â†’ * const subscriber = createSubscriber<MyEvent>({\n   226â†’ *   name: 'my-resumable-subscriber',\n   227â†’ *   idempotent: 'resumable',\n   228â†’ *   callback: async (envelope, { io }) => {\n   229â†’ *     await io('step-1', () => doSomething());\n   230â†’ *   },\n   231â†’ * });\n   232â†’ * ```\n   233â†’ */\n   234â†’export function createSubscriber<T extends MatadorEvent>(\n   235â†’  input: CreateSubscriberInput<T>,\n   236â†’): Subscriber<T>;\n   237â†’\n   238â†’/**\n   239â†’ * @deprecated Use object-based API instead: createSubscriber({ name, callback, ...options })\n   240â†’ */\n   241â†’export function createSubscriber<T extends MatadorEvent>(\n   242â†’  name: string,\n   243â†’  callback: StandardCallback<T['data']>,\n   244â†’  options?: StandardSubscriberOptions,\n   245â†’): StandardSubscriber<T>;\n   246â†’\n   247â†’export function createSubscriber<T extends MatadorEvent>(\n   248â†’  inputOrName: CreateSubscriberInput<T> | string,\n   249â†’  callback?: StandardCallback<T['data']>,\n   250â†’  options?: StandardSubscriberOptions,\n   251â†’): Subscriber<T> {\n   252â†’  // Legacy API: createSubscriber(name, callback, options)\n   253â†’  if (typeof inputOrName === 'string') {\n   254â†’    const opts = options ?? {};\n   255â†’    return {\n   256â†’      name: inputOrName,\n   257â†’      callback: callback!,\n   258â†’      idempotent: opts.idempotent ?? 'unknown',\n   259â†’      importance: opts.importance ?? 'should-investigate',\n   260â†’      ...(opts.targetQueue !== undefined && {\n   261â†’        targetQueue: opts.targetQueue,\n   262â†’      }),\n   263â†’      ...(opts.enabled !== undefined && { enabled: opts.enabled }),\n   264â†’    } as StandardSubscriber<T>;\n   265â†’  }\n   266â†’\n   267â†’  // New API: createSubscriber({ name, callback, ... })\n   268â†’  const input = inputOrName;\n   269â†’  const base = {\n   270â†’    name: input.name,\n   271â†’    callback: input.callback,\n   272â†’    importance: input.importance ?? 'should-investigate',\n   273â†’    ...(input.targetQueue !== undefined && {\n   274â†’      targetQueue: input.targetQueue,\n   275â†’    }),\n   276â†’    ...(input.enabled !== undefined && { enabled: input.enabled }),\n   277â†’  };\n   278â†’\n   279â†’  if (input.idempotent === 'resumable') {\n   280â†’    return {\n   281â†’      ...base,\n   282â†’      idempotent: 'resumable',\n   283â†’      callback: input.callback,\n   284â†’    } as ResumableSubscriber<T>;\n   285â†’  }\n   286â†’\n   287â†’  return {\n   288â†’    ...base,\n   289â†’    idempotent: input.idempotent ?? 'unknown',\n   290â†’    callback: input.callback,\n   291â†’  } as StandardSubscriber<T>;\n   292â†’}\n   293â†’\n   294â†’/**\n   295â†’ * Creates a subscriber stub for remote implementations.\n   296â†’ */\n   297â†’export function createSubscriberStub(\n   298â†’  name: string,\n   299â†’  options: StandardSubscriberOptions = {},\n   300â†’): SubscriberStub {\n   301â†’  return {\n   302â†’    name,\n   303â†’    isStub: true,\n   304â†’    idempotent: options.idempotent ?? 'unknown',\n   305â†’    importance: options.importance ?? 'should-investigate',\n   306â†’    ...(options.targetQueue !== undefined && {\n   307â†’      targetQueue: options.targetQueue,\n   308â†’    }),\n   309â†’    ...(options.enabled !== undefined && { enabled: options.enabled }),\n   310â†’  };\n   311â†’}\n   312â†’\n   313â†’/**\n   314â†’ * Definition interface used by the pipeline (excludes event class reference).\n   315â†’ */\n   316â†’export interface SubscriberDefinition {\n   317â†’  readonly name: string;\n   318â†’  readonly idempotent: Idempotency;\n   319â†’  readonly importance: Importance;\n   320â†’  readonly targetQueue?: string | undefined;\n   321â†’}\n   322â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T15:56:16.488Z"
        },
        {
          "type": "assistant",
          "text": "Now let me also check the plan document and the memory store to better understand the Redis checkpoint store:",
          "timestamp": "2025-12-11T15:56:21.348Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/docs/plans/resumable-subscribers.md"
          },
          "timestamp": "2025-12-11T15:56:22.165Z"
        },
        {
          "type": "tool_use",
          "name": "Glob",
          "input": {
            "pattern": "**/checkpoint/stores/*.ts"
          },
          "timestamp": "2025-12-11T15:56:22.516Z"
        },
        {
          "type": "user",
          "text": "/home/z/Desktop/work/matador/packages/matador/src/checkpoint/stores/memory.ts\n/home/z/Desktop/work/matador/packages/matador/src/checkpoint/stores/noop.ts\n/home/z/Desktop/work/matador/packages/matador/src/checkpoint/stores/stores.test.ts",
          "timestamp": "2025-12-11T15:56:22.752Z"
        },
        {
          "type": "user",
          "text": "     1â†’# Resumable Subscribers Implementation Plan\n     2â†’\n     3â†’## Problem Statement\n     4â†’\n     5â†’When a subscriber fails partway through execution (e.g., after calling an external API but before completing), retrying the message re-executes all operations from the beginning. This can cause:\n     6â†’\n     7â†’- Duplicate side effects (double charges, duplicate emails, etc.)\n     8â†’- Wasted compute on operations that already succeeded\n     9â†’- Complex manual idempotency handling in every subscriber\n    10â†’\n    11â†’## Proposed Solution\n    12â†’\n    13â†’Provide subscribers with an `io` function that:\n    14â†’1. Wraps side-effectful operations in a cacheable lambda\n    15â†’2. Caches successful results keyed by an explicit developer-provided key\n    16â†’3. On retry, returns cached values instead of re-executing\n    17â†’\n    18â†’This pattern is inspired by workflow engines like Temporal/Cadence, adapted for Matador's event-driven model.\n    19â†’\n    20â†’## API Design\n    21â†’\n    22â†’### Idempotency Integration\n    23â†’\n    24â†’A resumable subscriber is inherently idempotent because the `io()` caching mechanism prevents duplicate side effects on retry. We extend the existing `Idempotency` type:\n    25â†’\n    26â†’```typescript\n    27â†’// Current\n    28â†’type Idempotency = 'yes' | 'no' | 'unknown';\n    29â†’\n    30â†’// Proposed\n    31â†’type Idempotency = 'yes' | 'no' | 'unknown' | 'resumable';\n    32â†’```\n    33â†’\n    34â†’**Semantics:**\n    35â†’\n    36â†’| Value       | Meaning                                                                 | Retry Behavior                          |\n    37â†’|-------------|-------------------------------------------------------------------------|----------------------------------------|\n    38â†’| `'yes'`     | Subscriber is manually idempotent (safe to retry)                       | Retries allowed                        |\n    39â†’| `'no'`      | Subscriber is NOT idempotent (unsafe to retry)                          | Dead-letter on redelivery              |\n    40â†’| `'unknown'` | Idempotency not determined                                              | Retries allowed (default)              |\n    41â†’| `'resumable'` | Subscriber uses `io()` for checkpointed idempotency                   | Retries allowed, checkpoint loaded     |\n    42â†’\n    43â†’**Why `'resumable'` is distinct from `'yes'`:**\n    44â†’\n    45â†’- `'yes'` means the subscriber code is inherently idempotent (e.g., upserts, idempotency keys)\n    46â†’- `'resumable'` means idempotency is achieved through the checkpoint system\n    47â†’- This distinction enables:\n    48â†’  - Validation: Matador can warn if `idempotent: 'resumable'` but no `checkpointStore` configured\n    49â†’  - Observability: Differentiate between native idempotency and checkpoint-based idempotency in metrics\n    50â†’  - Future optimization: Skip checkpoint loading for `'yes'` subscribers\n    51â†’\n    52â†’### Compile-Time Enforcement via Discriminated Union\n    53â†’\n    54â†’We use a discriminated union on the subscriber options to enforce at compile time that:\n    55â†’- `idempotent: 'resumable'` **requires** a callback with `SubscriberContext`\n    56â†’- Other idempotency values **cannot** have a callback with `SubscriberContext`\n    57â†’\n    58â†’```typescript\n    59â†’/**\n    60â†’ * Context provided to resumable subscriber callbacks.\n    61â†’ */\n    62â†’interface SubscriberContext {\n    63â†’  /**\n    64â†’   * Wraps a side-effectful operation for caching/replay.\n    65â†’   * On first execution: runs the lambda and caches the result.\n    66â†’   * On retry: returns cached result without re-executing.\n    67â†’   *\n    68â†’   * @param key - Unique identifier for this operation within this subscriber.\n    69â†’   *              Must be stable across retries. Use descriptive names like\n    70â†’   *              'fetch-user', 'send-email', 'charge-payment'.\n    71â†’   * @param fn - The side-effectful operation to execute\n    72â†’   * @returns The result of fn (or cached result on retry)\n    73â†’   */\n    74â†’  io<T extends JsonSerializable>(key: string, fn: () => Promise<T> | T): Promise<T>;\n    75â†’\n    76â†’  /**\n    77â†’   * Execute multiple io() operations in parallel.\n    78â†’   * Each operation requires its own unique key.\n    79â†’   *\n    80â†’   * @param ops - Array of [key, fn] tuples to execute in parallel\n    81â†’   * @returns Array of results in the same order as input\n    82â†’   */\n    83â†’  all<T extends readonly [string, () => Promise<JsonSerializable> | JsonSerializable][]>(\n    84â†’    ops: T\n    85â†’  ): Promise<{ [K in keyof T]: T[K] extends [string, () => Promise<infer R> | infer R] ? R : never }>;\n    86â†’\n    87â†’  /** Current attempt number (1-based) */\n    88â†’  attempt: number;\n    89â†’\n    90â†’  /** Whether this is a retry (attempt > 1) */\n    91â†’  isRetry: boolean;\n    92â†’}\n    93â†’\n    94â†’/**\n    95â†’ * Type constraint ensuring values can be JSON serialized.\n    96â†’ */\n    97â†’type JsonSerializable =\n    98â†’  | string\n    99â†’  | number\n   100â†’  | boolean\n   101â†’  | null\n   102â†’  | JsonSerializable[]\n   103â†’  | { [key: string]: JsonSerializable };\n   104â†’\n   105â†’/**\n   106â†’ * Callback for standard (non-resumable) subscribers.\n   107â†’ */\n   108â†’type StandardCallback<T> = (envelope: Envelope<T>) => Promise<void> | void;\n   109â†’\n   110â†’/**\n   111â†’ * Callback for resumable subscribers - receives SubscriberContext with io().\n   112â†’ */\n   113â†’type ResumableCallback<T> = (\n   114â†’  envelope: Envelope<T>,\n   115â†’  context: SubscriberContext\n   116â†’) => Promise<void> | void;\n   117â†’\n   118â†’/**\n   119â†’ * Discriminated union ensuring idempotent: 'resumable' pairs with ResumableCallback.\n   120â†’ */\n   121â†’type SubscriberOptions<T extends MatadorEvent> =\n   122â†’  | {\n   123â†’      readonly name: string;\n   124â†’      readonly idempotent?: 'yes' | 'no' | 'unknown';  // Optional, defaults to 'unknown'\n   125â†’      readonly callback: StandardCallback<T['data']>;\n   126â†’      readonly importance?: Importance;\n   127â†’      readonly targetQueue?: string;\n   128â†’      readonly enabled?: () => boolean | Promise<boolean>;\n   129â†’    }\n   130â†’  | {\n   131â†’      readonly name: string;\n   132â†’      readonly idempotent: 'resumable';  // Required, must be 'resumable'\n   133â†’      readonly callback: ResumableCallback<T['data']>;\n   134â†’      readonly importance?: Importance;\n   135â†’      readonly targetQueue?: string;\n   136â†’      readonly enabled?: () => boolean | Promise<boolean>;\n   137â†’    };\n   138â†’\n   139â†’/**\n   140â†’ * Single createSubscriber function handles both cases.\n   141â†’ */\n   142â†’function createSubscriber<T extends MatadorEvent>(\n   143â†’  options: SubscriberOptions<T>\n   144â†’): Subscriber<T>;\n   145â†’```\n   146â†’\n   147â†’### Compile-Time Examples\n   148â†’\n   149â†’```typescript\n   150â†’// âœ… GOOD: Standard subscriber without context\n   151â†’createSubscriber<MyEvent>({\n   152â†’  name: 'standard',\n   153â†’  idempotent: 'yes',\n   154â†’  callback: async (envelope) => {\n   155â†’    // No io() available - correct!\n   156â†’  }\n   157â†’});\n   158â†’\n   159â†’// âœ… GOOD: Resumable subscriber with context\n   160â†’createSubscriber<MyEvent>({\n   161â†’  name: 'resumable',\n   162â†’  idempotent: 'resumable',\n   163â†’  callback: async (envelope, { io }) => {\n   164â†’    await io('do-something', () => doSomething());\n   165â†’  }\n   166â†’});\n   167â†’\n   168â†’// âŒ COMPILE ERROR: 'resumable' requires context parameter\n   169â†’createSubscriber<MyEvent>({\n   170â†’  name: 'broken',\n   171â†’  idempotent: 'resumable',\n   172â†’  callback: async (envelope) => {  // Error: missing context parameter\n   173â†’    // ...\n   174â†’  }\n   175â†’});\n   176â†’\n   177â†’// âŒ COMPILE ERROR: Non-resumable cannot have context parameter\n   178â†’createSubscriber<MyEvent>({\n   179â†’  name: 'broken',\n   180â†’  idempotent: 'yes',\n   181â†’  callback: async (envelope, { io }) => {  // Error: unexpected context parameter\n   182â†’    // ...\n   183â†’  }\n   184â†’});\n   185â†’\n   186â†’// âŒ COMPILE ERROR: Cannot use io() without 'resumable'\n   187â†’createSubscriber<MyEvent>({\n   188â†’  name: 'broken',\n   189â†’  // idempotent defaults to 'unknown'\n   190â†’  callback: async (envelope, context) => {  // Error: context not available\n   191â†’    await context.io('key', () => doSomething());\n   192â†’  }\n   193â†’});\n   194â†’```\n   195â†’\n   196â†’This ensures that **you cannot use `io()` without `idempotent: 'resumable'`** - the type system enforces it.\n   197â†’\n   198â†’### Usage Example\n   199â†’\n   200â†’```typescript\n   201â†’const sendWelcomeEmail = createSubscriber<UserCreatedEvent>({\n   202â†’  name: 'send-welcome-email',\n   203â†’  idempotent: 'resumable',  // Idempotency via checkpoint system\n   204â†’\n   205â†’  async callback(envelope, { io, all }) {\n   206â†’    const { userId, email } = envelope.data;\n   207â†’\n   208â†’    // Fetch user preferences (cached on retry)\n   209â†’    const prefs = await io('fetch-prefs', async () => {\n   210â†’      return await userService.getPreferences(userId);\n   211â†’    });\n   212â†’\n   213â†’    // Generate email content (cached on retry)\n   214â†’    const emailContent = await io('generate-email', async () => {\n   215â†’      return await templateService.render('welcome', { prefs });\n   216â†’    });\n   217â†’\n   218â†’    // Send email (cached on retry)\n   219â†’    const sendResult = await io('send-email', async () => {\n   220â†’      return await emailService.send(email, emailContent);\n   221â†’    });\n   222â†’\n   223â†’    // Record analytics (cached on retry)\n   224â†’    await io('record-analytics', async () => {\n   225â†’      await analytics.track('welcome_email_sent', { userId, messageId: sendResult.id });\n   226â†’    });\n   227â†’  }\n   228â†’});\n   229â†’```\n   230â†’\n   231â†’### Parallel Execution Example\n   232â†’\n   233â†’```typescript\n   234â†’const enrichUserData = createSubscriber<UserCreatedEvent>({\n   235â†’  name: 'enrich-user-data',\n   236â†’  idempotent: 'resumable',\n   237â†’\n   238â†’  async callback(envelope, { io, all }) {\n   239â†’    const { userId } = envelope.data;\n   240â†’\n   241â†’    // Fetch multiple data sources in parallel (each with unique key)\n   242â†’    const [profile, preferences, history] = await all([\n   243â†’      ['fetch-profile', async () => await profileService.get(userId)],\n   244â†’      ['fetch-prefs', async () => await prefsService.get(userId)],\n   245â†’      ['fetch-history', async () => await historyService.get(userId)],\n   246â†’    ]);\n   247â†’\n   248â†’    // Use enriched data\n   249â†’    await io('process-enrichment', async () => {\n   250â†’      await enrichmentService.process({ profile, preferences, history });\n   251â†’    });\n   252â†’  }\n   253â†’});\n   254â†’```\n   255â†’\n   256â†’If the subscriber crashes after 'generate-email' but before 'send-email':\n   257â†’- On retry, 'fetch-prefs' and 'generate-email' return cached values instantly\n   258â†’- 'send-email' executes fresh (no cache entry exists)\n   259â†’\n   260â†’## Explicit Keys\n   261â†’\n   262â†’Each `io()` call requires an explicit key that uniquely identifies the operation within the subscriber. This design choice provides important safety guarantees.\n   263â†’\n   264â†’### Why Explicit Keys?\n   265â†’\n   266â†’Explicit keys make resumable subscribers **resilient to code changes**:\n   267â†’\n   268â†’```typescript\n   269â†’// Version 1 (first attempt):\n   270â†’await io('fetch-user', () => fetchUser());\n   271â†’await io('send-email', () => sendEmail());\n   272â†’// crash here\n   273â†’\n   274â†’// Version 2 deployed (new io inserted), retry:\n   275â†’await io('fetch-user', () => fetchUser());     // cache HIT âœ“\n   276â†’await io('log-audit', () => logAudit());       // cache MISS, executes (new key)\n   277â†’await io('send-email', () => sendEmail());     // cache HIT âœ“ (same key!)\n   278â†’```\n   279â†’\n   280â†’With auto-generated keys (call order), inserting a new `io()` would shift all subsequent keys and cause cache misalignment. Explicit keys avoid this entirely.\n   281â†’\n   282â†’### Key Requirements\n   283â†’\n   284â†’1. **Unique within subscriber** - No two `io()` calls can have the same key\n   285â†’2. **Stable across retries** - The key for an operation must not change\n   286â†’3. **Descriptive** - Use meaningful names for debugging: `'fetch-user'`, `'send-email'`, `'charge-payment'`\n   287â†’\n   288â†’### Runtime Validation\n   289â†’\n   290â†’Duplicate keys are detected at runtime and throw an error:\n   291â†’\n   292â†’```typescript\n   293â†’await io('fetch-user', () => fetchUser());\n   294â†’await io('fetch-user', () => fetchPrefs());  // Error: Duplicate io key 'fetch-user'\n   295â†’```\n   296â†’\n   297â†’### Flexibility with Explicit Keys\n   298â†’\n   299â†’Explicit keys allow patterns that auto-generated keys cannot support:\n   300â†’\n   301â†’```typescript\n   302â†’// âœ… Conditional io() calls - safe!\n   303â†’if (envelope.data.sendEmail) {\n   304â†’  await io('send-email', () => sendEmail());\n   305â†’}\n   306â†’\n   307â†’// âœ… Dynamic loops - safe with unique keys!\n   308â†’for (const item of envelope.data.items) {\n   309â†’  await io(`process-item-${item.id}`, () => processItem(item));\n   310â†’}\n   311â†’\n   312â†’// âœ… Reordering code - safe!\n   313â†’// Moving io() calls around doesn't break existing checkpoints\n   314â†’```\n   315â†’\n   316â†’## Architecture\n   317â†’\n   318â†’### Components\n   319â†’\n   320â†’```\n   321â†’â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n   322â†’â”‚                         Matador Core                            â”‚\n   323â†’â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n   324â†’â”‚                                                                 â”‚\n   325â†’â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚\n   326â†’â”‚  â”‚ ProcessingPipelineâ”‚ â”€â”€â†’ â”‚ ResumableContext                 â”‚  â”‚\n   327â†’â”‚  â”‚                 â”‚      â”‚                                  â”‚  â”‚\n   328â†’â”‚  â”‚ - process()     â”‚      â”‚ - io(key, fn): Promise<T>        â”‚  â”‚\n   329â†’â”‚  â”‚ - executeCallbackâ”‚      â”‚ - all(ops): Promise<T[]>         â”‚  â”‚\n   330â†’â”‚  â”‚                 â”‚      â”‚ - loadCheckpoint()               â”‚  â”‚\n   331â†’â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚ - saveCheckpoint()               â”‚  â”‚\n   332â†’â”‚           â”‚               â”‚ - clearCheckpoint()              â”‚  â”‚\n   333â†’â”‚           â”‚               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚\n   334â†’â”‚           â”‚                              â”‚                      â”‚\n   335â†’â”‚           â”‚                              â–¼                      â”‚\n   336â†’â”‚           â”‚               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚\n   337â†’â”‚           â”‚               â”‚ CheckpointStore (Interface)      â”‚  â”‚\n   338â†’â”‚           â”‚               â”‚                                  â”‚  â”‚\n   339â†’â”‚           â”‚               â”‚ - get(envelopeId): Checkpoint    â”‚  â”‚\n   340â†’â”‚           â”‚               â”‚ - set(envelopeId, checkpoint)    â”‚  â”‚\n   341â†’â”‚           â”‚               â”‚ - delete(envelopeId)             â”‚  â”‚\n   342â†’â”‚           â”‚               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚\n   343â†’â”‚           â”‚                              â”‚                      â”‚\n   344â†’â”‚           â”‚               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚\n   345â†’â”‚           â”‚               â–¼                             â–¼       â”‚\n   346â†’â”‚           â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚\n   347â†’â”‚           â”‚         â”‚ Memory   â”‚                 â”‚ Redis     â”‚  â”‚\n   348â†’â”‚           â”‚         â”‚ Store    â”‚                 â”‚ Store     â”‚  â”‚\n   349â†’â”‚           â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚\n   350â†’â”‚           â”‚                                                     â”‚\n   351â†’â”‚           â–¼                                                     â”‚\n   352â†’â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚\n   353â†’â”‚  â”‚ Subscriber Callback                                         â”‚â”‚\n   354â†’â”‚  â”‚                                                             â”‚â”‚\n   355â†’â”‚  â”‚  callback(envelope, { io, all, attempt, isRetry })          â”‚â”‚\n   356â†’â”‚  â”‚                                                             â”‚â”‚\n   357â†’â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚\n   358â†’â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n   359â†’```\n   360â†’\n   361â†’### Checkpoint Data Structure\n   362â†’\n   363â†’```typescript\n   364â†’interface Checkpoint {\n   365â†’  envelopeId: string;\n   366â†’  subscriberName: string;\n   367â†’  completedSteps: Record<string, JsonSerializable>;  // key -> cached value\n   368â†’}\n   369â†’```\n   370â†’\n   371â†’The structure is intentionally minimal:\n   372â†’- `envelopeId` - identifies which message this checkpoint belongs to\n   373â†’- `subscriberName` - identifies which subscriber (for debugging/admin)\n   374â†’- `completedSteps` - map of step keys to their cached results\n   375â†’\n   376â†’### CheckpointStore Interface\n   377â†’\n   378â†’```typescript\n   379â†’interface CheckpointStore {\n   380â†’  /**\n   381â†’   * Retrieve checkpoint for an envelope\n   382â†’   */\n   383â†’  get(envelopeId: string): Promise<Checkpoint | undefined>;\n   384â†’\n   385â†’  /**\n   386â†’   * Save/update checkpoint\n   387â†’   */\n   388â†’  set(envelopeId: string, checkpoint: Checkpoint): Promise<void>;\n   389â†’\n   390â†’  /**\n   391â†’   * Delete checkpoint (on success or dead-letter)\n   392â†’   */\n   393â†’  delete(envelopeId: string): Promise<void>;\n   394â†’\n   395â†’  /**\n   396â†’   * Optional: TTL-based cleanup for orphaned checkpoints\n   397â†’   */\n   398â†’  cleanup?(olderThan: Date): Promise<number>;\n   399â†’}\n   400â†’```\n   401â†’\n   402â†’### Implementations\n   403â†’\n   404â†’#### 1. MemoryCheckpointStore (Default, for testing)\n   405â†’\n   406â†’```typescript\n   407â†’class MemoryCheckpointStore implements CheckpointStore {\n   408â†’  private checkpoints = new Map<string, Checkpoint>();\n   409â†’\n   410â†’  async get(envelopeId: string): Promise<Checkpoint | undefined> {\n   411â†’    return this.checkpoints.get(envelopeId);\n   412â†’  }\n   413â†’\n   414â†’  async set(envelopeId: string, checkpoint: Checkpoint): Promise<void> {\n   415â†’    this.checkpoints.set(envelopeId, checkpoint);\n   416â†’  }\n   417â†’\n   418â†’  async delete(envelopeId: string): Promise<void> {\n   419â†’    this.checkpoints.delete(envelopeId);\n   420â†’  }\n   421â†’}\n   422â†’```\n   423â†’\n   424â†’#### 2. RedisCheckpointStore (Production)\n   425â†’\n   426â†’```typescript\n   427â†’class RedisCheckpointStore implements CheckpointStore {\n   428â†’  constructor(private redis: Redis, private options: {\n   429â†’    prefix?: string;        // Key prefix, default: 'matador:checkpoint:'\n   430â†’    ttlSeconds?: number;    // TTL for cleanup, default: 86400 (24h)\n   431â†’  }) {}\n   432â†’\n   433â†’  async get(envelopeId: string): Promise<Checkpoint | undefined> {\n   434â†’    const data = await this.redis.get(this.key(envelopeId));\n   435â†’    return data ? JSON.parse(data) : undefined;\n   436â†’  }\n   437â†’\n   438â†’  async set(envelopeId: string, checkpoint: Checkpoint): Promise<void> {\n   439â†’    await this.redis.set(\n   440â†’      this.key(envelopeId),\n   441â†’      JSON.stringify(checkpoint),\n   442â†’      'EX', this.options.ttlSeconds\n   443â†’    );\n   444â†’  }\n   445â†’\n   446â†’  async delete(envelopeId: string): Promise<void> {\n   447â†’    await this.redis.del(this.key(envelopeId));\n   448â†’  }\n   449â†’\n   450â†’  private key(envelopeId: string): string {\n   451â†’    return `${this.options.prefix}${envelopeId}`;\n   452â†’  }\n   453â†’}\n   454â†’```\n   455â†’\n   456â†’## Implementation Details\n   457â†’\n   458â†’### ResumableContext Class\n   459â†’\n   460â†’```typescript\n   461â†’class ResumableContext implements SubscriberContext {\n   462â†’  private checkpoint: Checkpoint;\n   463â†’  private usedKeys = new Set<string>();\n   464â†’\n   465â†’  constructor(\n   466â†’    private store: CheckpointStore,\n   467â†’    private envelope: Envelope,\n   468â†’    private subscriberName: string,\n   469â†’    existingCheckpoint?: Checkpoint\n   470â†’  ) {\n   471â†’    this.checkpoint = existingCheckpoint ?? {\n   472â†’      envelopeId: envelope.id,\n   473â†’      subscriberName,\n   474â†’      completedSteps: {},\n   475â†’    };\n   476â†’  }\n   477â†’\n   478â†’  get attempt(): number {\n   479â†’    return this.envelope.docket.attempts;\n   480â†’  }\n   481â†’\n   482â†’  get isRetry(): boolean {\n   483â†’    return this.attempt > 1;\n   484â†’  }\n   485â†’\n   486â†’  async io<T extends JsonSerializable>(key: string, fn: () => Promise<T> | T): Promise<T> {\n   487â†’    // Validate key uniqueness within this execution\n   488â†’    if (this.usedKeys.has(key)) {\n   489â†’      throw new DuplicateIoKeyError(key, this.subscriberName);\n   490â†’    }\n   491â†’    this.usedKeys.add(key);\n   492â†’\n   493â†’    // Check cache first\n   494â†’    if (key in this.checkpoint.completedSteps) {\n   495â†’      return this.checkpoint.completedSteps[key] as T;\n   496â†’    }\n   497â†’\n   498â†’    // Execute the function - errors propagate, no caching on failure\n   499â†’    const result = await fn();\n   500â†’\n   501â†’    // Cache the result\n   502â†’    this.checkpoint.completedSteps[key] = result;\n   503â†’\n   504â†’    // Persist checkpoint immediately (incremental persistence)\n   505â†’    await this.store.set(this.envelope.id, this.checkpoint);\n   506â†’\n   507â†’    return result;\n   508â†’  }\n   509â†’\n   510â†’  async all<T extends readonly [string, () => Promise<JsonSerializable> | JsonSerializable][]>(\n   511â†’    ops: T\n   512â†’  ): Promise<{ [K in keyof T]: T[K] extends [string, () => Promise<infer R> | infer R] ? R : never }> {\n   513â†’    // Validate all keys are unique\n   514â†’    for (const [key] of ops) {\n   515â†’      if (this.usedKeys.has(key)) {\n   516â†’        throw new DuplicateIoKeyError(key, this.subscriberName);\n   517â†’      }\n   518â†’      this.usedKeys.add(key);\n   519â†’    }\n   520â†’\n   521â†’    const results = await Promise.all(\n   522â†’      ops.map(async ([key, fn]) => {\n   523â†’        // Check cache first\n   524â†’        if (key in this.checkpoint.completedSteps) {\n   525â†’          return this.checkpoint.completedSteps[key];\n   526â†’        }\n   527â†’\n   528â†’        // Execute - errors propagate\n   529â†’        const result = await fn();\n   530â†’\n   531â†’        // Cache individually\n   532â†’        this.checkpoint.completedSteps[key] = result;\n   533â†’\n   534â†’        return result;\n   535â†’      })\n   536â†’    );\n   537â†’\n   538â†’    // Persist after all parallel operations complete\n   539â†’    await this.store.set(this.envelope.id, this.checkpoint);\n   540â†’\n   541â†’    return results as { [K in keyof T]: T[K] extends [string, () => Promise<infer R> | infer R] ? R : never };\n   542â†’  }\n   543â†’\n   544â†’  async clear(): Promise<void> {\n   545â†’    await this.store.delete(this.envelope.id);\n   546â†’  }\n   547â†’}\n   548â†’```\n   549â†’\n   550â†’### Pipeline Integration\n   551â†’\n   552â†’Modify `ProcessingPipeline.executeCallback()` to create and manage the context:\n   553â†’\n   554â†’```typescript\n   555â†’// In pipeline.ts - executeCallback method\n   556â†’\n   557â†’private async executeCallback(\n   558â†’  envelope: Envelope,\n   559â†’  subscriber: Subscriber,\n   560â†’  receipt: MessageReceipt\n   561â†’): Promise<ProcessResult> {\n   562â†’  const startTime = Date.now();\n   563â†’\n   564â†’  try {\n   565â†’    // Load existing checkpoint if available\n   566â†’    const existingCheckpoint = this.checkpointStore\n   567â†’      ? await this.checkpointStore.get(envelope.id)\n   568â†’      : undefined;\n   569â†’\n   570â†’    // Create resumable context\n   571â†’    const context = new ResumableContext(\n   572â†’      this.checkpointStore ?? new NoOpCheckpointStore(),\n   573â†’      envelope,\n   574â†’      subscriber.name,\n   575â†’      existingCheckpoint\n   576â†’    );\n   577â†’\n   578â†’    // Execute with context\n   579â†’    await subscriber.callback(envelope, context);\n   580â†’\n   581â†’    // Success - clean up checkpoint\n   582â†’    await context.clear();\n   583â†’\n   584â†’    return {\n   585â†’      success: true,\n   586â†’      envelope,\n   587â†’      subscriber: toSubscriberDefinition(subscriber),\n   588â†’      durationMs: Date.now() - startTime,\n   589â†’    };\n   590â†’  } catch (error) {\n   591â†’    // Checkpoint persists for retry\n   592â†’    // (already saved incrementally in io() calls)\n   593â†’    return {\n   594â†’      success: false,\n   595â†’      envelope,\n   596â†’      subscriber: toSubscriberDefinition(subscriber),\n   597â†’      error: error as Error,\n   598â†’      durationMs: Date.now() - startTime,\n   599â†’    };\n   600â†’  }\n   601â†’}\n   602â†’```\n   603â†’\n   604â†’### Configuration\n   605â†’\n   606â†’```typescript\n   607â†’interface MatadorConfig {\n   608â†’  // ... existing config ...\n   609â†’\n   610â†’  /**\n   611â†’   * Checkpoint store for resumable subscribers.\n   612â†’   * If not provided, resumable context will be available but\n   613â†’   * checkpoints won't persist across retries.\n   614â†’   */\n   615â†’  checkpointStore?: CheckpointStore;\n   616â†’}\n   617â†’```\n   618â†’\n   619â†’### Retry Policy Integration\n   620â†’\n   621â†’The `StandardRetryPolicy` is updated to handle `'resumable'` idempotency:\n   622â†’\n   623â†’```typescript\n   624â†’// In standard-policy.ts - shouldRetry method\n   625â†’\n   626â†’// 6. Non-idempotent subscriber on redelivery\n   627â†’// 'resumable' is treated as idempotent (like 'yes') for retry purposes\n   628â†’if (receipt.redelivered && subscriber.idempotent === 'no') {\n   629â†’  const idempotentError = new IdempotentMessageCannotRetryError(\n   630â†’    envelope.id,\n   631â†’    subscriber.name,\n   632â†’  );\n   633â†’  return {\n   634â†’    action: 'dead-letter',\n   635â†’    queue: 'undeliverable',\n   636â†’    reason: idempotentError.message,\n   637â†’  };\n   638â†’}\n   639â†’\n   640â†’// 7. Default: retry with backoff\n   641â†’// For 'resumable' subscribers, checkpoint will be loaded on retry\n   642â†’return {\n   643â†’  action: 'retry',\n   644â†’  delay: this.getDelay(context),\n   645â†’};\n   646â†’```\n   647â†’\n   648â†’**Key behavior:**\n   649â†’- `idempotent: 'resumable'` is treated the same as `'yes'` for retry decisions\n   650â†’- The difference is in the pipeline: `'resumable'` triggers checkpoint loading\n   651â†’- This means `'resumable'` subscribers are always safe to retry\n   652â†’\n   653â†’### Schema Validation\n   654â†’\n   655â†’The schema registry validates `'resumable'` subscribers:\n   656â†’\n   657â†’```typescript\n   658â†’// In registry.ts - validate method\n   659â†’\n   660â†’function validateResumableSubscribers(\n   661â†’  schema: SchemaRegistry,\n   662â†’  checkpointStore: CheckpointStore | undefined\n   663â†’): ValidationError[] {\n   664â†’  const errors: ValidationError[] = [];\n   665â†’\n   666â†’  for (const [eventKey, subscribers] of schema.entries()) {\n   667â†’    for (const subscriber of subscribers) {\n   668â†’      if (subscriber.idempotent === 'resumable' && !checkpointStore) {\n   669â†’        errors.push({\n   670â†’          path: `${eventKey}.${subscriber.name}`,\n   671â†’          message: `Subscriber \"${subscriber.name}\" is marked as 'resumable' but no checkpointStore is configured. ` +\n   672â†’                   `Checkpoints will not persist across retries.`,\n   673â†’        });\n   674â†’      }\n   675â†’    }\n   676â†’  }\n   677â†’\n   678â†’  return errors;\n   679â†’}\n   680â†’```\n   681â†’\n   682â†’This validation produces a **warning** (not an error) allowing development/testing without Redis.\n   683â†’\n   684â†’## Key Design Decisions\n   685â†’\n   686â†’### 1. Explicit Keys\n   687â†’\n   688â†’**Decision: Developer-provided keys for each `io()` call**\n   689â†’\n   690â†’Rationale:\n   691â†’- **Resilient to code changes** - Inserting, removing, or reordering `io()` calls doesn't break existing checkpoints\n   692â†’- **Meaningful debugging** - Keys like `'fetch-user'` are more informative than `'step-0'`\n   693â†’- **Flexible patterns** - Supports conditional `io()`, dynamic loops, and code refactoring\n   694â†’- **No versioning needed** - No need for subscriber version fields or code hashing\n   695â†’\n   696â†’Trade-off:\n   697â†’- Developer must provide unique keys (small cognitive overhead)\n   698â†’- Runtime validation needed to detect duplicate keys\n   699â†’\n   700â†’### 2. Incremental Checkpoint Persistence\n   701â†’\n   702â†’**Decision: Save checkpoint after each `io()` call**\n   703â†’\n   704â†’Rationale:\n   705â†’- Ensures no work is lost if crash happens between `io()` calls\n   706â†’- Slightly more I/O but much safer\n   707â†’- For `all()`, save once after all parallel operations complete\n   708â†’\n   709â†’### 3. Checkpoint Cleanup Strategy\n   710â†’\n   711â†’**Decision: Clean on success, retain on failure with TTL**\n   712â†’\n   713â†’- On subscriber success: Delete checkpoint immediately\n   714â†’- On failure/retry: Checkpoint persists for next attempt\n   715â†’- On dead-letter: Delete checkpoint (terminal state)\n   716â†’- TTL on store: Cleanup orphaned checkpoints (24h default)\n   717â†’\n   718â†’### 4. Error Handling in io()\n   719â†’\n   720â†’**Decision: Errors propagate, no caching of failures**\n   721â†’\n   722â†’```typescript\n   723â†’async io<T extends JsonSerializable>(key: string, fn: () => Promise<T> | T): Promise<T> {\n   724â†’  // Check cache\n   725â†’  if (key in this.checkpoint.completedSteps) {\n   726â†’    return this.checkpoint.completedSteps[key] as T;\n   727â†’  }\n   728â†’\n   729â†’  // Execute - if this throws, it propagates up\n   730â†’  // The checkpoint is NOT updated on failure\n   731â†’  const result = await fn();\n   732â†’\n   733â†’  // Only cache on success\n   734â†’  this.checkpoint.completedSteps[key] = result;\n   735â†’  await this.store.set(...);\n   736â†’\n   737â†’  return result;\n   738â†’}\n   739â†’```\n   740â†’\n   741â†’### 5. Type-Safe Serialization\n   742â†’\n   743â†’**Decision: Enforce JSON-serializable types at compile time**\n   744â†’\n   745â†’```typescript\n   746â†’type JsonSerializable =\n   747â†’  | string\n   748â†’  | number\n   749â†’  | boolean\n   750â†’  | null\n   751â†’  | JsonSerializable[]\n   752â†’  | { [key: string]: JsonSerializable };\n   753â†’\n   754â†’// This will fail type checking:\n   755â†’await io('key', () => new Date());           // Error: Date is not JsonSerializable\n   756â†’await io('key', () => () => {});             // Error: Function is not JsonSerializable\n   757â†’await io('key', () => new Map());            // Error: Map is not JsonSerializable\n   758â†’\n   759â†’// This is fine:\n   760â†’await io('key', () => ({ createdAt: new Date().toISOString() }));  // OK\n   761â†’await io('key', () => [1, 2, 3]);                                   // OK\n   762â†’await io('key', () => null);                                        // OK\n   763â†’```\n   764â†’\n   765â†’### 6. Backward Compatibility\n   766â†’\n   767â†’**Decision: Context parameter is optional, existing subscribers work unchanged**\n   768â†’\n   769â†’```typescript\n   770â†’// New signature supports both:\n   771â†’type SubscriberCallback<T> = (\n   772â†’  envelope: Envelope<T>,\n   773â†’  context?: SubscriberContext  // Optional for backward compat\n   774â†’) => Promise<void> | void;\n   775â†’\n   776â†’// Old subscribers continue to work\n   777â†’callback: async (envelope) => { ... }\n   778â†’\n   779â†’// New subscribers can use context\n   780â†’callback: async (envelope, { io }) => { ... }\n   781â†’```\n   782â†’\n   783â†’## Hooks Integration\n   784â†’\n   785â†’New hooks for observability:\n   786â†’\n   787â†’```typescript\n   788â†’interface MatadorHooks {\n   789â†’  // ... existing hooks ...\n   790â†’\n   791â†’  /**\n   792â†’   * Called when a checkpoint is loaded for a retry\n   793â†’   */\n   794â†’  onCheckpointLoaded?(context: {\n   795â†’    envelope: Envelope;\n   796â†’    subscriber: SubscriberDefinition;\n   797â†’    checkpoint: Checkpoint;\n   798â†’    cachedSteps: number;\n   799â†’  }): void | Promise<void>;\n   800â†’\n   801â†’  /**\n   802â†’   * Called when an io() operation uses cached value\n   803â†’   */\n   804â†’  onCheckpointHit?(context: {\n   805â†’    envelope: Envelope;\n   806â†’    subscriber: SubscriberDefinition;\n   807â†’    stepKey: string;\n   808â†’  }): void | Promise<void>;\n   809â†’\n   810â†’  /**\n   811â†’   * Called when an io() operation executes (cache miss)\n   812â†’   */\n   813â†’  onCheckpointMiss?(context: {\n   814â†’    envelope: Envelope;\n   815â†’    subscriber: SubscriberDefinition;\n   816â†’    stepKey: string;\n   817â†’  }): void | Promise<void>;\n   818â†’\n   819â†’  /**\n   820â†’   * Called when checkpoint is cleared (success or dead-letter)\n   821â†’   */\n   822â†’  onCheckpointCleared?(context: {\n   823â†’    envelope: Envelope;\n   824â†’    subscriber: SubscriberDefinition;\n   825â†’    reason: 'success' | 'dead-letter';\n   826â†’  }): void | Promise<void>;\n   827â†’}\n   828â†’```\n   829â†’\n   830â†’## File Structure\n   831â†’\n   832â†’```\n   833â†’packages/matador/src/\n   834â†’â”œâ”€â”€ checkpoint/\n   835â†’â”‚   â”œâ”€â”€ index.ts                    # Public exports\n   836â†’â”‚   â”œâ”€â”€ types.ts                    # Checkpoint, CheckpointStore, JsonSerializable\n   837â†’â”‚   â”œâ”€â”€ context.ts                  # ResumableContext implementation\n   838â†’â”‚   â”œâ”€â”€ stores/\n   839â†’â”‚   â”‚   â”œâ”€â”€ memory.ts               # MemoryCheckpointStore\n   840â†’â”‚   â”‚   â””â”€â”€ noop.ts                 # NoOpCheckpointStore (default)\n   841â†’â”‚   â””â”€â”€ errors.ts                   # CheckpointError, etc.\n   842â†’â”œâ”€â”€ types/\n   843â†’â”‚   â”œâ”€â”€ common.ts                   # Add 'resumable' to Idempotency type\n   844â†’â”‚   â””â”€â”€ subscriber.ts               # Update SubscriberCallback signature\n   845â†’â”œâ”€â”€ pipeline/\n   846â†’â”‚   â””â”€â”€ pipeline.ts                 # Integrate ResumableContext\n   847â†’â”œâ”€â”€ schema/\n   848â†’â”‚   â””â”€â”€ registry.ts                 # Add resumable validation warning\n   849â†’â””â”€â”€ hooks/\n   850â†’    â””â”€â”€ types.ts                    # Add checkpoint hooks\n   851â†’```\n   852â†’\n   853â†’## Migration Guide\n   854â†’\n   855â†’### For Existing Subscribers (No Changes Required)\n   856â†’\n   857â†’Existing subscribers continue to work. The context parameter is optional:\n   858â†’\n   859â†’```typescript\n   860â†’// This still works\n   861â†’const mySubscriber = createSubscriber<MyEvent>({\n   862â†’  name: 'my-subscriber',\n   863â†’  callback: async (envelope) => {\n   864â†’    // existing code unchanged\n   865â†’  }\n   866â†’});\n   867â†’```\n   868â†’\n   869â†’### For New Resumable Subscribers\n   870â†’\n   871â†’1. Set `idempotent: 'resumable'` on the subscriber\n   872â†’2. Add context parameter to callback\n   873â†’3. Wrap side-effectful operations in `io()` with unique keys\n   874â†’4. Use descriptive keys that identify the operation\n   875â†’\n   876â†’```typescript\n   877â†’const myResumableSubscriber = createSubscriber<MyEvent>({\n   878â†’  name: 'my-resumable-subscriber',\n   879â†’  idempotent: 'resumable',  // Required for checkpoint-based idempotency\n   880â†’  callback: async (envelope, { io, all }) => {\n   881â†’    // Sequential operations with explicit keys\n   882â†’    const step1 = await io('do-something', () => doSomething());\n   883â†’    const step2 = await io('do-something-else', () => doSomethingElse(step1));\n   884â†’\n   885â†’    // Parallel operations with explicit keys\n   886â†’    const [a, b, c] = await all([\n   887â†’      ['fetch-a', () => fetchA()],\n   888â†’      ['fetch-b', () => fetchB()],\n   889â†’      ['fetch-c', () => fetchC()],\n   890â†’    ]);\n   891â†’\n   892â†’    await io('finalize', () => finalize(step2, a, b, c));\n   893â†’  }\n   894â†’});\n   895â†’```\n   896â†’\n   897â†’### For Production Deployments\n   898â†’\n   899â†’Configure a persistent checkpoint store:\n   900â†’\n   901â†’```typescript\n   902â†’import { RedisCheckpointStore } from 'matador/checkpoint';\n   903â†’import Redis from 'ioredis';\n   904â†’\n   905â†’const matador = new Matador({\n   906â†’  // ... other config ...\n   907â†’  checkpointStore: new RedisCheckpointStore(new Redis(), {\n   908â†’    prefix: 'myapp:checkpoint:',\n   909â†’    ttlSeconds: 86400, // 24 hours\n   910â†’  }),\n   911â†’});\n   912â†’```\n   913â†’\n   914â†’## Testing Strategy\n   915â†’\n   916â†’### Unit Tests\n   917â†’\n   918â†’1. **ResumableContext**\n   919â†’   - `io()` caches results with explicit keys\n   920â†’   - `io()` returns cached value when key exists in checkpoint\n   921â†’   - `io()` throws on duplicate key within same execution\n   922â†’   - `all()` executes in parallel and caches all results\n   923â†’   - Error in `io()` propagates without caching\n   924â†’   - `clear()` removes checkpoint\n   925â†’\n   926â†’2. **CheckpointStores**\n   927â†’   - CRUD operations for each implementation\n   928â†’   - TTL/cleanup behavior\n   929â†’   - Concurrent access handling\n   930â†’\n   931â†’3. **Pipeline Integration**\n   932â†’   - Context is passed to subscriber\n   933â†’   - Checkpoint loaded on retry\n   934â†’   - Checkpoint cleared on success\n   935â†’   - Checkpoint retained on failure\n   936â†’\n   937â†’4. **Type Safety**\n   938â†’   - Non-JsonSerializable types rejected at compile time\n   939â†’   - JsonSerializable types accepted\n   940â†’   - Discriminated union enforces `idempotent: 'resumable'` â†” `ResumableCallback` pairing\n   941â†’   - Standard callbacks cannot have context parameter\n   942â†’   - Resumable callbacks must have context parameter\n   943â†’\n   944â†’### Integration Tests\n   945â†’\n   946â†’1. **End-to-end retry with checkpoints**\n   947â†’   - Subscriber fails after 2 io() calls\n   948â†’   - Retry executes, first 2 io() calls return cached\n   949â†’   - Third io() call executes fresh\n   950â†’   - Success clears checkpoint\n   951â†’\n   952â†’2. **Parallel operations with all()**\n   953â†’   - Some operations in all() succeed, some fail\n   954â†’   - Retry replays successful ones from cache\n   955â†’\n   956â†’3. **Checkpoint store reliability**\n   957â†’   - Redis connection loss handling\n   958â†’   - Checkpoint corruption recovery\n   959â†’\n   960â†’### Example Test Case\n   961â†’\n   962â†’```typescript\n   963â†’describe('Resumable Subscribers', () => {\n   964â†’  it('should replay cached io() results on retry', async () => {\n   965â†’    const executionLog: string[] = [];\n   966â†’    let shouldFail = true;\n   967â†’\n   968â†’    const subscriber = createSubscriber<TestEvent>({\n   969â†’      name: 'test-resumable',\n   970â†’      idempotent: 'resumable',\n   971â†’      callback: async (envelope, { io }) => {\n   972â†’        await io('step-0', () => {\n   973â†’          executionLog.push('step-0');\n   974â†’          return 'result-0';\n   975â†’        });\n   976â†’\n   977â†’        await io('step-1', () => {\n   978â†’          executionLog.push('step-1');\n   979â†’          return 'result-1';\n   980â†’        });\n   981â†’\n   982â†’        if (shouldFail) {\n   983â†’          shouldFail = false;\n   984â†’          throw new Error('Simulated failure');\n   985â†’        }\n   986â†’\n   987â†’        await io('step-2', () => {\n   988â†’          executionLog.push('step-2');\n   989â†’          return 'result-2';\n   990â†’        });\n   991â†’      }\n   992â†’    });\n   993â†’\n   994â†’    // First attempt - fails after step-1\n   995â†’    await processMessage(envelope, subscriber);\n   996â†’    expect(executionLog).toEqual(['step-0', 'step-1']);\n   997â†’\n   998â†’    // Retry - step-0 and step-1 use cache, step-2 executes\n   999â†’    executionLog.length = 0;\n  1000â†’    await processMessage(envelope, subscriber);\n  1001â†’    expect(executionLog).toEqual(['step-2']); // Only step-2 executed!\n  1002â†’  });\n  1003â†’\n  1004â†’  it('should handle parallel operations with all()', async () => {\n  1005â†’    const executionLog: string[] = [];\n  1006â†’\n  1007â†’    const subscriber = createSubscriber<TestEvent>({\n  1008â†’      name: 'test-parallel',\n  1009â†’      idempotent: 'resumable',\n  1010â†’      callback: async (envelope, { io, all }) => {\n  1011â†’        const [a, b, c] = await all([\n  1012â†’          ['fetch-a', () => { executionLog.push('a'); return 'result-a'; }],\n  1013â†’          ['fetch-b', () => { executionLog.push('b'); return 'result-b'; }],\n  1014â†’          ['fetch-c', () => { executionLog.push('c'); return 'result-c'; }],\n  1015â†’        ]);\n  1016â†’\n  1017â†’        expect(a).toBe('result-a');\n  1018â†’        expect(b).toBe('result-b');\n  1019â†’        expect(c).toBe('result-c');\n  1020â†’      }\n  1021â†’    });\n  1022â†’\n  1023â†’    await processMessage(envelope, subscriber);\n  1024â†’    expect(executionLog).toContain('a');\n  1025â†’    expect(executionLog).toContain('b');\n  1026â†’    expect(executionLog).toContain('c');\n  1027â†’  });\n  1028â†’\n  1029â†’  it('should throw on duplicate keys', async () => {\n  1030â†’    const subscriber = createSubscriber<TestEvent>({\n  1031â†’      name: 'test-duplicate-key',\n  1032â†’      idempotent: 'resumable',\n  1033â†’      callback: async (envelope, { io }) => {\n  1034â†’        await io('same-key', () => 'first');\n  1035â†’        await io('same-key', () => 'second');  // Should throw!\n  1036â†’      }\n  1037â†’    });\n  1038â†’\n  1039â†’    await expect(processMessage(envelope, subscriber))\n  1040â†’      .rejects.toThrow(DuplicateIoKeyError);\n  1041â†’  });\n  1042â†’});\n  1043â†’```\n  1044â†’\n  1045â†’## Future Enhancements\n  1046â†’\n  1047â†’### 1. Checkpoint inspection API\n  1048â†’\n  1049â†’```typescript\n  1050â†’// For debugging/admin tools\n  1051â†’const checkpoint = await matador.getCheckpoint(envelopeId);\n  1052â†’console.log(checkpoint.completedSteps);\n  1053â†’```\n  1054â†’\n  1055â†’### 2. Checkpoint metrics\n  1056â†’\n  1057â†’- Track checkpoint hit/miss ratios\n  1058â†’- Monitor checkpoint sizes\n  1059â†’- Alert on high checkpoint counts (indicating frequent failures)\n  1060â†’\n  1061â†’## Implementation Order\n  1062â†’\n  1063â†’1. **Phase 1: Core Types and Interfaces**\n  1064â†’   - [ ] Add `'resumable'` to `Idempotency` type in `types/common.ts`\n  1065â†’   - [ ] Define `Checkpoint`, `CheckpointStore`, `JsonSerializable` types\n  1066â†’   - [ ] Define `SubscriberContext` interface with `io()` and `all()`\n  1067â†’   - [ ] Define `StandardCallback<T>` and `ResumableCallback<T>` types\n  1068â†’   - [ ] Update `SubscriberOptions<T>` to discriminated union\n  1069â†’   - [ ] Update `createSubscriber` to accept the discriminated union\n  1070â†’\n  1071â†’2. **Phase 2: Checkpoint Stores**\n  1072â†’   - [ ] Implement `NoOpCheckpointStore` (default)\n  1073â†’   - [ ] Implement `MemoryCheckpointStore`\n  1074â†’   - [ ] Write unit tests for stores\n  1075â†’\n  1076â†’3. **Phase 3: ResumableContext**\n  1077â†’   - [ ] Implement `ResumableContext` class\n  1078â†’   - [ ] Implement `io(key, fn)` with explicit keys\n  1079â†’   - [ ] Implement duplicate key detection\n  1080â†’   - [ ] Implement `all(ops)` for parallel operations\n  1081â†’   - [ ] Add `DuplicateIoKeyError` to errors\n  1082â†’   - [ ] Write unit tests for context\n  1083â†’\n  1084â†’4. **Phase 4: Pipeline Integration**\n  1085â†’   - [ ] Add `checkpointStore` to `MatadorConfig`\n  1086â†’   - [ ] Modify `ProcessingPipeline` to create/manage context\n  1087â†’   - [ ] Only load checkpoints for `idempotent: 'resumable'` subscribers\n  1088â†’   - [ ] Pass context to subscriber callbacks\n  1089â†’   - [ ] Clear checkpoint on success/dead-letter\n  1090â†’\n  1091â†’5. **Phase 5: Schema Validation**\n  1092â†’   - [ ] Add validation warning for `'resumable'` without `checkpointStore`\n  1093â†’   - [ ] Update schema validation tests\n  1094â†’\n  1095â†’6. **Phase 6: Hooks**\n  1096â†’   - [ ] Add checkpoint-related hooks to `MatadorHooks`\n  1097â†’   - [ ] Integrate hooks into context operations\n  1098â†’\n  1099â†’7. **Phase 7: Integration Tests**\n  1100â†’   - [ ] End-to-end retry with checkpoints\n  1101â†’   - [ ] Parallel operations with all()\n  1102â†’   - [ ] Dead-letter checkpoint cleanup\n  1103â†’   - [ ] Test `'resumable'` idempotency behavior\n  1104â†’\n  1105â†’8. **Phase 8: Redis Store**\n  1106â†’   - [ ] Implement `RedisCheckpointStore`\n  1107â†’   - [ ] Write integration tests with Redis\n  1108â†’\n  1109â†’9. **Phase 9: Documentation**\n  1110â†’   - [ ] API documentation\n  1111â†’   - [ ] Migration guide\n  1112â†’   - [ ] Examples\n  1113â†’   - [ ] Document explicit key requirements\n  1114â†’   - [ ] Document `idempotent: 'resumable'` semantics\n  1115â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T15:56:22.939Z"
        },
        {
          "type": "assistant",
          "text": "Now I have all the context I need. Let me create a comprehensive example for the `ResumableSubscriber` section. I'll replace the `> TODO: Add example.` line with a realistic example that shows the `io` function in action:",
          "timestamp": "2025-12-11T15:56:28.459Z"
        },
        {
          "type": "tool_use",
          "name": "Edit",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/README.md",
            "new_string": "On subsequent retries, those successful `io` calls will return the cached value, instead of executing again.\n\n```ts\nimport { MemoryCheckpointStore } from '@meetsmore/matador';\n\n// Configure Matador with a checkpoint store\nconst matador = new Matador({\n  transport,\n  topology,\n  schema,\n  consumeFrom: ['events'],\n  checkpointStore: new MemoryCheckpointStore(), // Use RedisCheckpointStore in production\n});\n\n// Define a resumable subscriber\nconst processOrder: Subscriber<OrderPlacedEvent> = {\n  name: 'process-order',\n  idempotent: 'resumable',  // Enables the io() function\n  callback: async (envelope, { io }) => {\n    const { orderId, userId, amount } = envelope.data;\n\n    // Step 1: Reserve inventory (cached on retry)\n    const reservation = await io('reserve-inventory', async () => {\n      return await inventoryService.reserve(orderId);\n    });\n\n    // Step 2: Charge payment (cached on retry)\n    const payment = await io('charge-payment', async () => {\n      return await paymentService.charge(userId, amount);\n    });\n\n    // Step 3: Send confirmation email (cached on retry)\n    await io('send-confirmation', async () => {\n      await emailService.send(userId, {\n        subject: 'Order Confirmed',\n        reservationId: reservation.id,\n        transactionId: payment.transactionId,\n      });\n    });\n  },\n};\n```\n\nIf the subscriber crashes after charging the payment but before sending the email:\n- On retry, `reserve-inventory` returns the cached reservation (no duplicate reservation)\n- On retry, `charge-payment` returns the cached payment (no double charge)\n- `send-confirmation` executes fresh (no cache entry exists)\n\nYou can also use `all()` to execute multiple `io()` operations in parallel:\n\n```ts\nconst enrichUserData: Subscriber<UserCreatedEvent> = {\n  name: 'enrich-user-data',\n  idempotent: 'resumable',\n  callback: async (envelope, { io, all }) => {\n    const { userId } = envelope.data;\n\n    // Fetch multiple data sources in parallel (each with a unique key)\n    const [profile, preferences, history] = await all([\n      ['fetch-profile', async () => await profileService.get(userId)],\n      ['fetch-preferences', async () => await prefsService.get(userId)],\n      ['fetch-history', async () => await historyService.get(userId)],\n    ]);\n\n    // Use the enriched data\n    await io('save-enrichment', async () => {\n      await enrichmentService.save({ userId, profile, preferences, history });\n    });\n  },\n};\n```\n\nEach `io()` key must be unique within the subscriber and stable across retries. Use descriptive names like `'fetch-user'`, `'send-email'`, or `'charge-payment'`.",
            "old_string": "On subsequent retries, those successful `io` calls will return the cached value, instead of executing again.\n\n> TODO: Add example."
          },
          "timestamp": "2025-12-11T15:56:41.412Z"
        }
      ],
      "total_additions": 204,
      "total_deletions": 9,
      "accepted_lines": 199,
      "overriden_lines": 1
    }
  }
}
