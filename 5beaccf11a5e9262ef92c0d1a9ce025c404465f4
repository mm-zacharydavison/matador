README.md
  306f72aab8c915d9 94-98,100-101,103-111,115,272,277-278,291-331,335-370,400-421,432,434-435,437,441,443-485,489-518,545,548-564,567-571,573-574,582-604,619-650,656,658-669,671-677,686-716,728-740,744,747,750-754,756-765,767,769
---
{
  "schema_version": "authorship/3.0.0",
  "git_ai_version": "1.0.22",
  "base_commit_sha": "5beaccf11a5e9262ef92c0d1a9ce025c404465f4",
  "prompts": {
    "306f72aab8c915d9": {
      "agent_id": {
        "tool": "claude",
        "id": "f9ae095f-f0fa-4ec4-b669-3d6bd5ba0a68",
        "model": "claude-opus-4-5-20251101"
      },
      "human_author": "Zachary Davison <zachary.davison@meetsmore.com>",
      "messages": [
        {
          "type": "user",
          "text": "README.md has many '> TODO' notes. \n\ncheck each, and fix them in the README accordingly.",
          "timestamp": "2025-12-11T15:37:25.489Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/README.md"
          },
          "timestamp": "2025-12-11T15:37:28.752Z"
        },
        {
          "type": "user",
          "text": "     1→# Matador\n     2→\n     3→![image](./assets/logo-small.png)\n     4→\n     5→An opinionated, batteries-included framework for using event transports (e.g. `RabbitMQ`) with a lot of useful conventions built in.\n     6→\n     7→# Vision\n     8→\n     9→Matador aims to provide a ready-to-use framework for dispatching messages and moving work off your API servers onto workers.\n    10→It is an _opinionated_ library that may-or-may not suit your expectations about how to work with queues.\n    11→\n    12→You can use it to very quickly set up a framework for your events, with battle-tested conventions, edge-case coverage, and observability baked in.\n    13→\n    14→It works best under the following conditions.\n    15→\n    16→- You want the queue topology to be created and managed for you.\n    17→- You are working in a monorepo, where you can easily share code.\n    18→- You want a 1:N fanout strategy, where each _subscriber_ receives a unique copy of each event.\n    19→- You want `at-least-once` delivery semantics.\n    20→\n    21→These conditions are explained later.\n    22→\n    23→# History\n    24→\n    25→Matador has been used at [MeetsMore Inc](https://meetsmore.com/) for over 2 years to publish, consume, and observe 1,000,000+ successful events per day.\n    26→\n    27→This version of Matador is Matador V2, and was re-written from the ground up using our learnings over that 2 year period.\n    28→\n    29→# Features\n    30→\n    31→- Conventional types for `Event` and `Subscriber`\n    32→- Map an event to a list of subscribers that will consume it.\n    33→- Each subscriber receives a unique copy of each event that can be individually retried and re-queued.\n    34→- Automatically create and manage your queue topology.\n    35→- Automatic reconnection when connection drops.\n    36→- Async hooks for changing behaviour at runtime.\n    37→- Async lifecycle hooks for plugging into your observability platform.\n    38→- Required fields enforcing good, observable documentation practices.\n    39→- `idempotency` declaration for subscribers, allowing you to indicate if events can be retried safely or not.\n    40→- `metadata` separated from event payloads, to clearly separate data used for logic, and data that is just used for debugging.\n    41→- Gracefully wait for pending enqueues and subscribers to complete work before shutting down.\n    42→- Fallback to a different message broker if enqueuing fails.\n    43→- Local broker for executing code locally (useful for fallback).\n    44→- Retry control flow errors (`DoRetry` and `DontRetry`), so subscribers can manually dictate retry logic.\n    45→- Clear, documented, actionable errors for all error cases.\n    46→- Poisoned message detection.\n    47→\n    48→# Getting Started\n    49→\n    50→### Define a MatadorEvent\n    51→\n    52→```ts\n    53→export class UserLoggedInEvent extends MatadorEvent {\n    54→  static readonly key = 'user.logged-in';                   // The unique event name (used to route events).\n    55→  static readonly description = 'Fired when a user logs.';  // A description of when the event is triggered.\n    56→\n    57→  constructor(\n    58→    public data: {                                          // The data payload used by business logic.\n    59→      userId: string;\n    60→      username: string;\n    61→    },\n    62→    public metadata: {                                      // Additional data helpful for logging or debugging.\n    63→      loginMethod: 'email' | 'social'\n    64→    }\n    65→  ) {\n    66→    super();\n    67→  }\n    68→}\n    69→```\n    70→\n    71→### Define a Subscriber\n    72→\n    73→```ts\n    74→const detectLoginFraud: Subscriber<UserLoggedInEvent> = {\n    75→  name: 'detect-login-fraud',                                           // Unique subscriber name.\n    76→  description: 'Send an email if unusual login behaviour is detected.'  // A description of what the subscriber does.\n    77→  idempotent: 'no'                                                      // Dictates if the operation can be safely retried.\n    78→  targetQueue: 'compliance-jobs-worker'                                 // The queue this subscriber consumes from.\n    79→  callback: async (event: EnvelopeOf<UserLoggedIn>) => { /** process event */ }\n    80→}\n    81→```\n    82→\n    83→### Define a Schema\n    84→\n    85→```ts\n    86→const myMatadorSchema = MatadorSchema = {\n    87→  [UserLoggedIn.key]: [UserLoggedIn, bind([ detectLoginFraud, logEventToBigQuery ])]\n    88→}\n    89→```\n    90→\n    91→### Instantiate Matador and send events\n    92→\n    93→```ts\n    94→const matador = new Matador({ schema: myMatadorSchema })\n    95→```\n    96→\n    97→> TODO: Make sure all required arguments for `new Matador` are included in this example.\n    98→\n    99→```ts\n   100→await matador.send(UserLoggedIn, { data: { userId: '123' }, metadata: { loginMethod: 'email' } })\n   101→```\n   102→\n   103→> TODO: Check this example syntax is correct.\n   104→\n   105→# Concepts\n   106→\n   107→### `MatadorEvent`\n   108→\n   109→A definition of an event. You extend `MatadorEvent` in order to create the _template_ for your event.\n   110→\n   111→### `Subscriber`\n   112→\n   113→A subscriber defines the logic that will execute when an event is consumed.\n   114→It also defines details about the event that are used to _fanout_ the event.\n   115→\n   116→```ts\n   117→/**\n   118→ * Standard subscriber definition with standard callback.\n   119→ */\n   120→export interface StandardSubscriber<T extends MatadorEvent> {\n   121→  /** Human-readable name for the subscriber */\n   122→  readonly name: string;\n   123→\n   124→  /** A description of what the event does. */\n   125→  readonly description: string\n   126→\n   127→  /** Idempotency declaration for retry handling (non-resumable) */\n   128→  readonly idempotent?: 'yes' | 'no' | 'unknown' | undefined;\n   129→\n   130→  /** Route this subscriber's events to a specific queue */\n   131→  readonly targetQueue?: string | undefined;\n   132→\n   133→  /** Importance level for monitoring and alerting */\n   134→  readonly importance?: Importance | undefined;\n   135→\n   136→  /** Feature flag function to conditionally enable/disable the subscriber */\n   137→  readonly enabled?: (() => boolean | Promise<boolean>) | undefined;\n   138→\n   139→  /** Callback function to execute when event is received */\n   140→  readonly callback: StandardCallback<T['data']>;\n   141→}\n   142→```\n   143→\n   144→If you want to reference a subscriber which is defined in another codebase, you can use `SubscriberStub`:\n   145→\n   146→```ts\n   147→/**\n   148→ * Subscriber stub for multi-codebase scenarios where subscriber implementation\n   149→ * is in a remote service. Declares the subscriber contract without providing\n   150→ * the callback.\n   151→ */\n   152→export interface SubscriberStub extends StandardSubscriberOptions {\n   153→  /** Human-readable name for the subscriber */\n   154→  readonly name: string;\n   155→\n   156→  /** Indicates this is a stub without implementation */\n   157→  readonly isStub: true;\n   158→}\n   159→```\n   160→\n   161→### `Schema`\n   162→\n   163→Defines the mapping of `Events` to `Subscribers`.\n   164→```ts\n   165→const myMatadorSchema = MatadorSchema = {\n   166→  // user.logged-in -> UserLoggedInEvent (class) -> subscribers\n   167→  [UserLoggedInEvent.key]: [UserLoggedInEvent, bind([ detectLoginFraud, logEventToBigQuery ])]\n   168→}\n   169→```\n   170→\n   171→### `Envelope`\n   172→\n   173→Combines both your event data + metadata with a `Docket`.\n   174→Subscribers receive an `EnvelopeOf<MyEvent>`, which is an envelope with a `data` and `metadata` field typed according to your `MatadorEvent` subclass.\n   175→\n   176→```ts\n   177→/**\n   178→ * Message envelope containing the event data and routing/observability metadata.\n   179→ * This is the transport-agnostic message format used throughout Matador.\n   180→ */\n   181→export interface Envelope<T = unknown> {\n   182→  /** Unique message ID (UUID v4) */\n   183→  readonly id: string;\n   184→\n   185→  /** The event data */\n   186→  readonly data: T;\n   187→\n   188→  /** Routing, processing state, and observability metadata */\n   189→  readonly docket: Docket;\n   190→}\n   191→\n   192→/**\n   193→ * Helper type to get the envelope type for a subscriber callback.\n   194→ * Extracts the data type from a MatadorEvent and wraps it in an Envelope.\n   195→ *\n   196→ * @example\n   197→ * async callback(envelope: EnvelopeOf<MyEvent>) {\n   198→ *   console.log(envelope.data.someField); // Type-safe access\n   199→ * }\n   200→ */\n   201→export type EnvelopeOf<T extends MatadorEvent> = Envelope<T['data']>;\n   202→```\n   203→\n   204→### `Docket`\n   205→\n   206→> A docket is a commercial document accompanying shipped goods, detailing its contents.\n   207→\n   208→Contains all metadata about an `Envelope`.\n   209→\n   210→| Property            | Documentation                                                                                                                                                                                                                                          |\n   211→| ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n   212→| **Routing**         |                                                                                                                                                                                                                                                        |\n   213→| `eventKey`          | Event key for routing                                                                                                                                                                                                                                  |\n   214→| `eventDescription`  | Human-readable description of the event (for observability/logging)                                                                                                                                                                                    |\n   215→| `targetSubscriber`  | Target subscriber name for 1:1 routing                                                                                                                                                                                                                 |\n   216→| `originalQueue`     | Original queue before any dead-letter routing                                                                                                                                                                                                          |\n   217→| `scheduledFor`      | Scheduled processing time for delayed messages (ISO 8601 string)                                                                                                                                                                                       |\n   218→| **Processing State**|                                                                                                                                                                                                                                                        |\n   219→| `attempts`          | Attempt counter managed by Matador (1-based). Incremented on each retry. Used when transport doesn't track attempts.                                                                                                                                   |\n   220→| `createdAt`         | When the envelope was first created (ISO 8601 string)                                                                                                                                                                                                  |\n   221→| `firstError`        | Error message from first failure (for debugging)                                                                                                                                                                                                       |\n   222→| `lastError`         | Error message from most recent failure                                                                                                                                                                                                                 |\n   223→| **Observability**   |                                                                                                                                                                                                                                                        |\n   224→| `importance`        | Importance level for monitoring                                                                                                                                                                                                                        |\n   225→| `correlationId`     | Correlation ID for request tracing                                                                                                                                                                                                                     |\n   226→| `metadata`          | Custom metadata provided by the application, includes `universalMetadata` |\n   227→\n   228→### `Fanout`\n   229→\n   230→The practice of taking a single published event and creating `N` concrete events, where `N` is the number of subscribers mapped to that event in your `MatadorSchema`\n   231→\n   232→### `Transport`\n   233→\n   234→A representation of a message broker or event backend. e.g `RabbitMQ`, `BullMQ`, `Temporal`, etc.\n   235→Currently, only `RabbitMQ` is supported.\n   236→\n   237→### `Topology`\n   238→\n   239→The structure of queues, exchanges, topics, etc that **Matador** will create and manage.\n   240→For RabbitMQ, for example, the topology refers to the exchanges, queues, and bindings of those entities.\n   241→**Matador** creates and manages topology for you.\n   242→\n   243→There is a generic `Topology` definition in Matador, which you can use to describe the queues you want in a limited fashion.\n   244→\n   245→Each `Transport` then translates that generic `Topology` into the concrete queues, exchanges, etc.\n   246→\n   247→The topology that **Matador** creates looks like this by default.\n   248→\n   249→![image](./assets/matador-rabbitmq-configuration-simple.drawio.png)\n   250→\n   251→#### Retry Queue\n   252→\n   253→When events fail, they are pushed into the retry queue. They will then be re-delivered after their TTL expires.\n   254→\n   255→#### Unhandled Queue\n   256→\n   257→In **Matador**, _unhandled_ refers to a message that was consumed by a worker but is not in your `MatadorSchema`.\n   258→This can happen during deployments, where your publisher has already been deployed, but your consumer has not, and therefore your consumer doesn't know about the event yet.\n   259→Since the most common reason for this (99.99% of the time in our experience) is simply deployment timing, _unhandled_ events will be requeued after a TTL. \n   260→\n   261→> TODO: Specify the TTL.\n   262→\n   263→#### Undeliverable Queue\n   264→\n   265→Undeliverable is a conventional term for messages that could not be successfully processed.\n   266→After a configured amount of retries, a message will be sent to the undeliverable queue and left there for inspection.\n   267→By default, this queue is not cleared by **Matador**, although there is a default size limit.\n   268→\n   269→> TODO: Specify the default size limit.\n   270→\n   271→### `Codec`\n   272→\n   273→Handles the _encoding_ and _decoding_ of events that are published and consumed.\n   274→By default, `JSONCodec` is used, which serializes and de-serializes events using JSON.\n   275→\n   276→You can create other `Codec`s if you wish (for example a `MessagePackCodec`).\n   277→\n   278→When using `RabbitMQ`, `RabbitMQCodec` is used, which still uses `JSONCodec` internally, but uses AMQP headers to store `Docket` information.\n   279→\n   280→### `Config`\n   281→\n   282→> TODO: List all config options and description of each.\n   283→\n   284→### `Hooks`\n   285→\n   286→> TODO: List all hooks and description of each.\n   287→\n   288→### `idempotent`\n   289→\n   290→> In programming, an idempotent operation is one that can be performed multiple times with the same result as if it were done only once.\n   291→\n   292→In **Matador**, `idempotent` has a very close meaning, but ultimately just means that an event is _allowed_ to be retried automatically by **Matador**.\n   293→\n   294→# Why it works this way\n   295→\n   296→Since **Matador** is opinionated, we should explain the rationale behind our choices.\n   297→\n   298→### Sending one message will result in a unique message _per subscriber_.\n   299→\n   300→When you send an event in **Matador**, there is a unique copy of that event sent with different `Docket` details.\n   301→\n   302→This is automatic, and referred to as _fanout_ within **Matador**.\n   303→\n   304→We chose this model because while it results in `N` real events per published event, it allows each real event to be retried and managed individually. A single failed subscriber does not affect any others or result in any additional cognitive complexity about the system.\n   305→\n   306→This however does have the impact of requiring the publisher to know about the subscriber. \n   307→This is easy in a monorepo environment, but for remote subscribers, you can use `SubscriberStub`.\n   308→\n   309→### You are working in a monorepo\n   310→\n   311→While it is possible to use **Matador** outside of a monorepo environment, it is designed to work in a situation where you can easily share code between your applications.\n   312→This is because both the _publisher_ and the _consumer_ need to know about the event _schema_ (e.g. which events map to which subscribers).\n   313→\n   314→You can either share the code for your `MatadorSchema`, or you can make your workers simply be different instances of the same codebase (with different configuration).\n   315→\n   316→> TODO: Include example of Matador config that is dynamic (e.g. from marketing-pf)\n   317→\n   318→### You want `at-least-once` delivery.\n   319→\n   320→There are two options for delivery in an event system.\n   321→\n   322→- `at-least-once`: Every message is guaranteed to be delivered once, but may deliver more times in some edge-cases.\n   323→- `at-most-once`: Every message is guaranteed to be delivered at most once, but may not be delivered at all in some edge cases.\n   324→\n   325→Any system that promises `exactly-once` is lying to you, because there are always timeout scenarios in a distributed system that mean that there may still be a very small possibility of a message being either delivered multiple times (`at-least-once`) or not at all (`at-most-once`).\n   326→\n   327→The choice essential comes down to when you `ack` a message.\n   328→\n   329→- Before processing: `at-most-once`.\n   330→- After processing: `at least-once`.\n   331→\n   332→> TODO: Are these statements correct?\n   333→\n   334→# Logging\n   335→\n   336→> TODO: List all possible logs emitted by Matador.\n   337→\n   338→# Errors\n   339→\n   340→> TODO: List all possible errors emitted by Matador (and description of each)\n   341→\n   342→# Other features\n   343→\n   344→### `universalMetadata`\n   345→\n   346→It is often the case that you want every event to have a consistent set of metadata.\n   347→**Matador** provides a hook `loadUniversalMetadata` which you can use to do this.\n   348→\n   349→You can combine this with `asyncLocalStorage` to set session based metadata on your events.\n   350→\n   351→Here is a real world example:\n   352→\n   353→```ts\n   354→loadUniversalMetadata: () => {\n   355→  const store = asyncLocalStorage?.getStore()\n   356→  return {\n   357→    timestamp: new Date(),\n   358→    correlationId: store?.correlationId || null,\n   359→    userId: store?.userId || null,\n   360→  }\n   361→},\n   362→```\n   363→\n   364→### Schema plugins\n   365→\n   366→Sometimes, you want to run a subscriber on every event in your _schema_.\n   367→Instead of defining the subscriber mapping for every event, you can use _schema plugins_ to do this:\n   368→\n   369→```ts\n   370→const myMatadorSchema = MatadorSchema = installPlugins({\n   371→  [UserLoggedInEvent.key]: [UserLoggedInEvent, bind([ detectLoginFraud ])],\n   372→  [UserLoggedOutEvent.key]: [UserLoggedOutEvent, bind([])],\n   373→  [ChatMessageSent.key]: [ChatMessageSent, bind([ notifyUser ])]\n   374→},\n   375→  [\n   376→    {\n   377→      subscriber: uploadEventToBigQuery,\n   378→      exclusions: [\n   379→        ChatMessageSent.key,\n   380→      ],\n   381→    },\n   382→  ])\n   383→```\n   384→\n   385→> TODO: Ensure this is actually possible in Matador V2 and add the functionality if not.\n   386→\n   387→### `DoRetry` & `DontRetry`\n   388→\n   389→Sometimes, your subscribers may want to explicitly control if they should be retried or not.\n   390→This is useful in cases where a message is _sometimes_ idempotent, but in certain cases (e.g. error scenarios) it is not.\n   391→\n   392→> TODO: Add an example here.\n   393→\n   394→### `LocalTransport`\n   395→\n   396→Matador includes a `LocalTransport`, which is an in-memory transport that will simply process events on the same machine.\n   397→This allows you to develop locally without having a message broker, then simply switch to using an actual message broker when you deploy.\n   398→\n   399→### `MultiTransport`\n   400→\n   401→`MultiTransport` allows you to declare a group of transports, and then switch between them at runtime.\n   402→\n   403→You can also use configure it with `fallbackEnabled` (default: `true`), and if enqueuing a message fails, it can fallback to another queue system (in declared order).\n   404→\n   405→You can combine this with `LocalTransport` to make messages that fail to enqueue execute locally, providing resilience against your message broker being unavailable or timing out.\n   406→\n   407→> TODO: Add example with RabbitMQTransport + LocalTransport\n   408→\n   409→### `enabled()` hook for `Subscriber`\n   410→\n   411→Sometimes, you want to enable / disable subscribers at runtime using feature flags.\n   412→\n   413→Each subscriber accepts and `enabled()` callback, which will be invoked before publishing or consuming an event.\n   414→\n   415→> TODO: Is this true? or does it only disable publishing?\n   416→> TODO: Add examples\n   417→\n   418→### `importance`\n   419→\n   420→`importance` is an optional field that allows you to note how critical a subscriber failure is.\n   421→This is useful for setting up alerts in your observability platform.\n   422→\n   423→For example, if an analytics event fails, it is likely unimportant, but if a payment related subscriber fails, it warrants investigation and should trigger an alert.\n   424→\n   425→> TODO: Add example.\n   426→\n   427→### Delayed messages\n   428→\n   429→> Delayed messages implementation is dependent on the `Transport` used.\n   430→\n   431→You can optionally delay messages in Matador. This will cause their delivery to be delayed.\n   432→\n   433→When using `RabbitMQTransport`, this is implemented using the [delayed-message-exchange plugin](https://github.com/rabbitmq/rabbitmq-delayed-message-exchange), and you should ensure it is installed in your RabbitMQ instance first.\n   434→\n   435→> Note: Distributed event systems do not have precise delivery timings. The consumption of your event will be dependent on your throughput, and you should not depend on delayed messages for accurate timings.\n   436→\n   437→> TODO: Add example.\n   438→\n   439→# CLI\n   440→\n   441→> TODO: Verify this is the right command.\n   442→\n   443→Matador provides a `cli` utility for quick local testing of your Matador configuration.\n   444→\n   445→```bash\n   446→bunx matador cli <path-to-config-file> <path-to-event-file>\n   447→```\n   448→\n   449→You can send a quick test event using.\n   450→\n   451→```bash\n   452→bunx matador cli send-test-event\n   453→```\n   454→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T15:37:28.876Z"
        },
        {
          "type": "assistant",
          "text": "I found the README.md file with multiple `> TODO` notes. Let me analyze the codebase to find the correct information to address each TODO.",
          "timestamp": "2025-12-11T15:37:32.795Z"
        },
        {
          "type": "tool_use",
          "name": "TodoWrite",
          "input": {
            "todos": [
              {
                "activeForm": "Fixing Matador constructor example",
                "content": "Fix TODO: Matador constructor required arguments example",
                "status": "in_progress"
              },
              {
                "activeForm": "Checking send example syntax",
                "content": "Fix TODO: Check send example syntax",
                "status": "pending"
              },
              {
                "activeForm": "Specifying unhandled queue TTL",
                "content": "Fix TODO: Specify unhandled queue TTL",
                "status": "pending"
              },
              {
                "activeForm": "Specifying undeliverable queue size limit",
                "content": "Fix TODO: Specify undeliverable queue default size limit",
                "status": "pending"
              },
              {
                "activeForm": "Listing config options",
                "content": "Fix TODO: List all config options",
                "status": "pending"
              },
              {
                "activeForm": "Listing hooks",
                "content": "Fix TODO: List all hooks",
                "status": "pending"
              },
              {
                "activeForm": "Including dynamic config example",
                "content": "Fix TODO: Include dynamic Matador config example",
                "status": "pending"
              },
              {
                "activeForm": "Verifying delivery statements",
                "content": "Fix TODO: Verify at-least-once/at-most-once statements",
                "status": "pending"
              },
              {
                "activeForm": "Listing logs",
                "content": "Fix TODO: List all possible logs",
                "status": "pending"
              },
              {
                "activeForm": "Listing errors",
                "content": "Fix TODO: List all possible errors",
                "status": "pending"
              },
              {
                "activeForm": "Ensuring schema plugins work",
                "content": "Fix TODO: Ensure schema plugins work and add example",
                "status": "pending"
              },
              {
                "activeForm": "Adding DoRetry/DontRetry example",
                "content": "Fix TODO: Add DoRetry/DontRetry example",
                "status": "pending"
              },
              {
                "activeForm": "Adding MultiTransport example",
                "content": "Fix TODO: Add MultiTransport example",
                "status": "pending"
              },
              {
                "activeForm": "Verifying enabled() hook behavior",
                "content": "Fix TODO: Verify enabled() hook behavior and add examples",
                "status": "pending"
              },
              {
                "activeForm": "Adding importance example",
                "content": "Fix TODO: Add importance example",
                "status": "pending"
              },
              {
                "activeForm": "Adding delayed messages example",
                "content": "Fix TODO: Add delayed messages example",
                "status": "pending"
              },
              {
                "activeForm": "Verifying CLI command",
                "content": "Fix TODO: Verify CLI command",
                "status": "pending"
              }
            ]
          },
          "timestamp": "2025-12-11T15:37:38.954Z"
        },
        {
          "type": "user",
          "text": "Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable",
          "timestamp": "2025-12-11T15:37:39.033Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/core/matador.ts"
          },
          "timestamp": "2025-12-11T15:37:43.273Z"
        },
        {
          "type": "tool_use",
          "name": "Glob",
          "input": {
            "path": "/home/z/Desktop/work/matador/packages/matador/src",
            "pattern": "**/types/*.ts"
          },
          "timestamp": "2025-12-11T15:37:43.990Z"
        },
        {
          "type": "tool_use",
          "name": "Glob",
          "input": {
            "path": "/home/z/Desktop/work/matador/packages/matador/src",
            "pattern": "**/hooks/*.ts"
          },
          "timestamp": "2025-12-11T15:37:44.580Z"
        },
        {
          "type": "tool_use",
          "name": "Glob",
          "input": {
            "path": "/home/z/Desktop/work/matador/packages/matador/src",
            "pattern": "**/errors/*.ts"
          },
          "timestamp": "2025-12-11T15:37:45.276Z"
        },
        {
          "type": "user",
          "text": "     1→import type { CheckpointStore } from '../checkpoint/index.js';\n     2→import type { Codec } from '../codec/index.js';\n     3→import { JsonCodec } from '../codec/index.js';\n     4→import {\n     5→  InvalidSchemaError,\n     6→  NotStartedError,\n     7→  ShutdownInProgressError,\n     8→} from '../errors/index.js';\n     9→import type { MatadorHooks } from '../hooks/index.js';\n    10→import { SafeHooks } from '../hooks/index.js';\n    11→import { ProcessingPipeline } from '../pipeline/index.js';\n    12→import type { RetryPolicy } from '../retry/index.js';\n    13→import { StandardRetryPolicy } from '../retry/index.js';\n    14→import type { MatadorSchema } from '../schema/index.js';\n    15→import { SchemaRegistry, isSchemaEntryTuple } from '../schema/index.js';\n    16→import type { Topology } from '../topology/index.js';\n    17→import { getQualifiedQueueName } from '../topology/index.js';\n    18→import type { Subscription, Transport } from '../transport/index.js';\n    19→import type {\n    20→  AnySubscriber,\n    21→  Event,\n    22→  EventClass,\n    23→  EventOptions,\n    24→} from '../types/index.js';\n    25→import type { SendResult } from './fanout.js';\n    26→import { FanoutEngine } from './fanout.js';\n    27→import type { HandlersState, ShutdownConfig } from './shutdown.js';\n    28→import { ShutdownManager } from './shutdown.js';\n    29→\n    30→/**\n    31→ * Configuration for Matador.\n    32→ */\n    33→export interface MatadorConfig {\n    34→  /** Transport for message delivery */\n    35→  readonly transport: Transport;\n    36→\n    37→  /** Topology configuration */\n    38→  readonly topology: Topology;\n    39→\n    40→  /** Event schema mapping event keys to event classes and subscribers */\n    41→  readonly schema: MatadorSchema;\n    42→\n    43→  /** Queues to consume from (empty = no consumption) */\n    44→  readonly consumeFrom?: readonly string[] | undefined;\n    45→\n    46→  /** Custom codec (defaults to JSON) */\n    47→  readonly codec?: Codec | undefined;\n    48→\n    49→  /** Custom retry policy */\n    50→  readonly retryPolicy?: RetryPolicy | undefined;\n    51→\n    52→  /** Shutdown configuration */\n    53→  readonly shutdownConfig?: Partial<ShutdownConfig> | undefined;\n    54→\n    55→  /**\n    56→   * Checkpoint store for resumable subscribers.\n    57→   * Required for persisting io() results across retries.\n    58→   * If not provided, resumable subscribers will work but checkpoints\n    59→   * won't persist across retries.\n    60→   */\n    61→  readonly checkpointStore?: CheckpointStore | undefined;\n    62→}\n    63→\n    64→/**\n    65→ * Matador - Transport-agnostic event processing library.\n    66→ *\n    67→ * Main orchestrator that wires together:\n    68→ * - Transport: Message delivery\n    69→ * - Schema: Event-subscriber registry\n    70→ * - Pipeline: Message processing\n    71→ * - Fanout: Event sending\n    72→ * - Shutdown: Graceful termination\n    73→ */\n    74→export class Matador {\n    75→  private readonly transport: Transport;\n    76→  private readonly topology: Topology;\n    77→  private readonly schema;\n    78→  private readonly codec: Codec;\n    79→  private readonly retryPolicy: RetryPolicy;\n    80→  private readonly hooks;\n    81→  private readonly pipeline;\n    82→  private readonly fanout;\n    83→  private readonly shutdownManager;\n    84→  private readonly consumeFrom: readonly string[];\n    85→  private readonly subscriptions: Subscription[] = [];\n    86→  private started = false;\n    87→\n    88→  /**\n    89→   * Creates a new Matador instance.\n    90→   *\n    91→   * @param config - Static configuration (transport, topology, schema, etc.)\n    92→   * @param hooks - Lifecycle hooks for logging, monitoring, and dynamic configuration.\n    93→   *                Passed separately to support NestJS dependency injection.\n    94→   */\n    95→  constructor(config: MatadorConfig, hooks?: MatadorHooks) {\n    96→    this.transport = config.transport;\n    97→    this.topology = config.topology;\n    98→    this.consumeFrom = config.consumeFrom ?? [];\n    99→\n   100→    // Initialize components\n   101→    this.schema = new SchemaRegistry();\n   102→    this.codec = config.codec ?? new JsonCodec();\n   103→    this.retryPolicy = config.retryPolicy ?? new StandardRetryPolicy();\n   104→    this.hooks = new SafeHooks(hooks);\n   105→\n   106→    // Register schema from config\n   107→    this.registerSchema(config.schema);\n   108→\n   109→    // Create pipeline\n   110→    this.pipeline = new ProcessingPipeline({\n   111→      transport: this.transport,\n   112→      schema: this.schema,\n   113→      codec: this.codec,\n   114→      retryPolicy: this.retryPolicy,\n   115→      hooks: this.hooks,\n   116→      checkpointStore: config.checkpointStore,\n   117→    });\n   118→\n   119→    // Create fanout engine\n   120→    const defaultQueue = this.topology.queues[0]?.name ?? 'default';\n   121→    this.fanout = new FanoutEngine({\n   122→      transport: this.transport,\n   123→      schema: this.schema,\n   124→      hooks: this.hooks,\n   125→      namespace: this.topology.namespace,\n   126→      defaultQueue,\n   127→    });\n   128→\n   129→    // Create shutdown manager\n   130→    this.shutdownManager = new ShutdownManager(\n   131→      () => this.fanout.eventsBeingEnqueuedCount,\n   132→      () => this.stopReceiving(),\n   133→      () => this.transport.disconnect(),\n   134→      config.shutdownConfig,\n   135→    );\n   136→  }\n   137→\n   138→  /**\n   139→   * Registers an event class with its subscribers.\n   140→   */\n   141→  register<T>(\n   142→    eventClass: EventClass<T>,\n   143→    subscribers: readonly AnySubscriber[],\n   144→  ): this {\n   145→    this.schema.register(eventClass, subscribers);\n   146→    return this;\n   147→  }\n   148→\n   149→  /**\n   150→   * Registers events from a schema object.\n   151→   * Supports both object format and tuple format entries.\n   152→   *\n   153→   * @example\n   154→   * ```typescript\n   155→   * // Tuple format\n   156→   * matador.registerSchema({\n   157→   *   [UserCreatedEvent.key]: [UserCreatedEvent, [emailSubscriber]],\n   158→   *   [OrderPlacedEvent.key]: [OrderPlacedEvent, [invoiceSubscriber]],\n   159→   * });\n   160→   *\n   161→   * // Object format\n   162→   * matador.registerSchema({\n   163→   *   [UserCreatedEvent.key]: { eventClass: UserCreatedEvent, subscribers: [emailSubscriber] },\n   164→   * });\n   165→   * ```\n   166→   */\n   167→  registerSchema(schema: MatadorSchema): this {\n   168→    for (const entry of Object.values(schema)) {\n   169→      if (isSchemaEntryTuple(entry)) {\n   170→        // Tuple format: [EventClass, Subscriber[]]\n   171→        const [eventClass, subscribers] = entry;\n   172→        this.schema.register(eventClass, subscribers);\n   173→      } else {\n   174→        // Object format: { eventClass, subscribers }\n   175→        this.schema.register(entry.eventClass, entry.subscribers);\n   176→      }\n   177→    }\n   178→    return this;\n   179→  }\n   180→\n   181→  /**\n   182→   * Starts Matador - connects transport and begins consuming.\n   183→   * This method is idempotent - calling it multiple times is safe.\n   184→   */\n   185→  async start(): Promise<void> {\n   186→    // Idempotent: if already started, just return\n   187→    if (this.started) {\n   188→      return;\n   189→    }\n   190→\n   191→    // Validate schema\n   192→    const validation = this.schema.validate();\n   193→    if (!validation.valid) {\n   194→      const errors = validation.issues.filter((i) => i.severity === 'error');\n   195→      throw new InvalidSchemaError(\n   196→        'Schema validation failed',\n   197→        errors.map((e) => e.message).join(', '),\n   198→      );\n   199→    }\n   200→\n   201→    // Connect transport\n   202→    await this.transport.connect();\n   203→\n   204→    // Apply topology\n   205→    await this.transport.applyTopology(this.topology);\n   206→\n   207→    // Subscribe to queues\n   208→    for (const queueName of this.consumeFrom) {\n   209→      const qualifiedName = getQualifiedQueueName(\n   210→        this.topology.namespace,\n   211→        queueName,\n   212→      );\n   213→      const queueDef = this.topology.queues.find((q) => q.name === queueName);\n   214→\n   215→      const subscription = await this.transport.subscribe(\n   216→        qualifiedName,\n   217→        async (envelope, receipt) => {\n   218→          this.shutdownManager.incrementProcessing();\n   219→          try {\n   220→            const rawMessage = this.codec.encode(envelope);\n   221→            await this.pipeline.process(rawMessage, receipt);\n   222→          } finally {\n   223→            this.shutdownManager.decrementProcessing();\n   224→          }\n   225→        },\n   226→        queueDef?.concurrency !== undefined\n   227→          ? { concurrency: queueDef.concurrency }\n   228→          : undefined,\n   229→      );\n   230→\n   231→      this.subscriptions.push(subscription);\n   232→    }\n   233→\n   234→    this.started = true;\n   235→  }\n   236→\n   237→  /**\n   238→   * Sends an event to all registered subscribers.\n   239→   *\n   240→   * @example\n   241→   * ```typescript\n   242→   * // Pass the event class and data directly\n   243→   * await matador.send(UserCreatedEvent, { userId: '123' });\n   244→   *\n   245→   * // Or pass an event instance\n   246→   * const event = new UserCreatedEvent({ userId: '123' });\n   247→   * await matador.send(event);\n   248→   * ```\n   249→   */\n   250→  async send<T>(\n   251→    eventClass: EventClass<T>,\n   252→    data: T,\n   253→    options?: EventOptions,\n   254→  ): Promise<SendResult>;\n   255→  async send<T>(event: Event<T>, options?: EventOptions): Promise<SendResult>;\n   256→  async send<T>(\n   257→    eventOrClass: Event<T> | EventClass<T>,\n   258→    dataOrOptions?: T | EventOptions,\n   259→    maybeOptions?: EventOptions,\n   260→  ): Promise<SendResult> {\n   261→    if (!this.started) {\n   262→      throw new NotStartedError('send');\n   263→    }\n   264→\n   265→    if (!this.shutdownManager.isEnqueueAllowed) {\n   266→      throw new ShutdownInProgressError();\n   267→    }\n   268→\n   269→    // Determine if first arg is an event instance or event class\n   270→    const isEventClass =\n   271→      typeof eventOrClass === 'function' && 'key' in eventOrClass;\n   272→\n   273→    if (isEventClass) {\n   274→      // Called as: send(EventClass, data, options?)\n   275→      const eventClass = eventOrClass as EventClass<T>;\n   276→      const data = dataOrOptions as T;\n   277→      const options = maybeOptions;\n   278→      const event = new eventClass(data);\n   279→      return this.fanout.send(eventClass, event, options);\n   280→    } else {\n   281→      // Called as: send(event, options?)\n   282→      const event = eventOrClass as Event<T>;\n   283→      const options = dataOrOptions as EventOptions | undefined;\n   284→      const eventClass = event.constructor as EventClass<T>;\n   285→      return this.fanout.send(eventClass, event, options);\n   286→    }\n   287→  }\n   288→\n   289→  /**\n   290→   * Gets current handler state.\n   291→   */\n   292→  getHandlersState(): HandlersState {\n   293→    return this.shutdownManager.getHandlersState();\n   294→  }\n   295→\n   296→  /**\n   297→   * Checks if Matador is idle (no processing or enqueuing).\n   298→   */\n   299→  isIdle(): boolean {\n   300→    return this.shutdownManager.getHandlersState().isIdle;\n   301→  }\n   302→\n   303→  /**\n   304→   * Waits for all handlers to become idle.\n   305→   */\n   306→  async waitForIdle(timeoutMs = 30000): Promise<boolean> {\n   307→    const deadline = Date.now() + timeoutMs;\n   308→\n   309→    while (!this.isIdle()) {\n   310→      if (Date.now() > deadline) {\n   311→        return false;\n   312→      }\n   313→      await new Promise((resolve) => setTimeout(resolve, 100));\n   314→    }\n   315→\n   316→    return true;\n   317→  }\n   318→\n   319→  /**\n   320→   * Gracefully shuts down Matador.\n   321→   */\n   322→  async shutdown(): Promise<void> {\n   323→    if (!this.started) {\n   324→      return;\n   325→    }\n   326→\n   327→    await this.shutdownManager.shutdown();\n   328→    this.started = false;\n   329→  }\n   330→\n   331→  /**\n   332→   * Checks if transport is connected.\n   333→   */\n   334→  isConnected(): boolean {\n   335→    return this.transport.isConnected();\n   336→  }\n   337→\n   338→  private async stopReceiving(): Promise<void> {\n   339→    for (const subscription of this.subscriptions) {\n   340→      await subscription.unsubscribe();\n   341→    }\n   342→    this.subscriptions.length = 0;\n   343→  }\n   344→}\n   345→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T15:37:45.509Z"
        },
        {
          "type": "user",
          "text": "/home/z/Desktop/work/matador/packages/matador/src/errors/has-description.ts\n/home/z/Desktop/work/matador/packages/matador/src/errors/retry-errors.ts\n/home/z/Desktop/work/matador/packages/matador/src/errors/matador-errors.ts\n/home/z/Desktop/work/matador/packages/matador/src/errors/index.ts",
          "timestamp": "2025-12-11T15:37:45.533Z"
        },
        {
          "type": "user",
          "text": "/home/z/Desktop/work/matador/packages/matador/src/types/event.ts\n/home/z/Desktop/work/matador/packages/matador/src/types/event.test.ts\n/home/z/Desktop/work/matador/packages/matador/src/types/common.ts\n/home/z/Desktop/work/matador/packages/matador/src/types/index.ts\n/home/z/Desktop/work/matador/packages/matador/src/types/envelope.ts\n/home/z/Desktop/work/matador/packages/matador/src/types/subscriber.ts",
          "timestamp": "2025-12-11T15:37:45.540Z"
        },
        {
          "type": "user",
          "text": "/home/z/Desktop/work/matador/packages/matador/src/hooks/index.ts\n/home/z/Desktop/work/matador/packages/matador/src/hooks/types.ts\n/home/z/Desktop/work/matador/packages/matador/src/hooks/safe-hooks.ts",
          "timestamp": "2025-12-11T15:37:45.537Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/hooks/types.ts"
          },
          "timestamp": "2025-12-11T15:37:49.386Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/errors/matador-errors.ts"
          },
          "timestamp": "2025-12-11T15:37:49.792Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/errors/retry-errors.ts"
          },
          "timestamp": "2025-12-11T15:37:50.252Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/topology/index.ts"
          },
          "timestamp": "2025-12-11T15:37:50.895Z"
        },
        {
          "type": "user",
          "text": "     1→import type {\n     2→  CheckpointClearedContext,\n     3→  CheckpointHitContext,\n     4→  CheckpointLoadedContext,\n     5→  CheckpointMissContext,\n     6→} from '../checkpoint/index.js';\n     7→import type { RetryDecision } from '../retry/index.js';\n     8→import type { ConnectionState, Transport } from '../transport/index.js';\n     9→import type { Envelope, SubscriberDefinition } from '../types/index.js';\n    10→\n    11→/**\n    12→ * Logger interface for Matador internal logging.\n    13→ */\n    14→export interface Logger {\n    15→  debug(message: string, ...args: unknown[]): void;\n    16→  info(message: string, ...args: unknown[]): void;\n    17→  warn(message: string, ...args: unknown[]): void;\n    18→  error(message: string, ...args: unknown[]): void;\n    19→}\n    20→\n    21→/**\n    22→ * Default logger that uses console.\n    23→ */\n    24→export const consoleLogger: Logger = {\n    25→  debug: (message, ...args) => console.debug(message, ...args),\n    26→  info: (message, ...args) => console.info(message, ...args),\n    27→  warn: (message, ...args) => console.warn(message, ...args),\n    28→  error: (message, ...args) => console.error(message, ...args),\n    29→};\n    30→\n    31→/**\n    32→ * Context for enqueue success hook.\n    33→ */\n    34→export interface EnqueueSuccessContext {\n    35→  readonly envelope: Envelope;\n    36→  readonly queue: string;\n    37→  /** The transport that was used (e.g., 'local', 'rabbitmq') */\n    38→  readonly transport: string;\n    39→}\n    40→\n    41→/**\n    42→ * Context for enqueue warning hook (fallback used).\n    43→ */\n    44→export interface EnqueueWarningContext {\n    45→  readonly envelope: Envelope;\n    46→  readonly originalQueue: string;\n    47→  readonly fallbackQueue: string;\n    48→  readonly error: Error;\n    49→}\n    50→\n    51→/**\n    52→ * Context for transport fallback hook.\n    53→ */\n    54→export interface TransportFallbackContext {\n    55→  /** The envelope that was being sent */\n    56→  readonly envelope: Envelope;\n    57→  /** The queue the message was being sent to */\n    58→  readonly queue: string;\n    59→  /** The transport that failed */\n    60→  readonly failedTransport: Transport['name'];\n    61→  /** The transport that will be tried next */\n    62→  readonly nextTransport: Transport['name'];\n    63→  /** The error from the failed transport */\n    64→  readonly error: Error;\n    65→}\n    66→\n    67→/**\n    68→ * Context for enqueue error hook.\n    69→ */\n    70→export interface EnqueueErrorContext {\n    71→  readonly envelope: Envelope;\n    72→  readonly error: Error;\n    73→  /** The transport that failed (e.g., 'local', 'rabbitmq') */\n    74→  readonly transport: string;\n    75→}\n    76→\n    77→/**\n    78→ * Context for decode error hook.\n    79→ */\n    80→export interface DecodeErrorContext {\n    81→  readonly error: Error;\n    82→  readonly rawMessage: Uint8Array;\n    83→  readonly sourceQueue: string;\n    84→  /** The transport that received the message (e.g., 'local', 'rabbitmq') */\n    85→  readonly transport: string;\n    86→}\n    87→\n    88→/**\n    89→ * Context for worker success hook.\n    90→ */\n    91→export interface WorkerSuccessContext {\n    92→  readonly envelope: Envelope;\n    93→  readonly subscriber: SubscriberDefinition;\n    94→  readonly result: unknown;\n    95→  readonly durationMs: number;\n    96→  /** The transport that received the message (e.g., 'local', 'rabbitmq') */\n    97→  readonly transport: string;\n    98→}\n    99→\n   100→/**\n   101→ * Context for worker error hook.\n   102→ */\n   103→export interface WorkerErrorContext {\n   104→  readonly envelope: Envelope;\n   105→  readonly subscriber: SubscriberDefinition;\n   106→  readonly error: Error;\n   107→  readonly durationMs: number;\n   108→  readonly decision: RetryDecision;\n   109→  /** The transport that received the message (e.g., 'local', 'rabbitmq') */\n   110→  readonly transport: string;\n   111→}\n   112→\n   113→/**\n   114→ * Execution function passed to onWorkerWrap for APM wrapping.\n   115→ */\n   116→export type WorkerExecuteFn = () => Promise<void>;\n   117→\n   118→/**\n   119→ * All available hooks for Matador.\n   120→ */\n   121→export interface MatadorHooks {\n   122→  /**\n   123→   * Logger for internal Matador logging.\n   124→   * Defaults to console logger if not provided.\n   125→   */\n   126→  logger?: Logger;\n   127→\n   128→  /**\n   129→   * Called when an event is successfully enqueued.\n   130→   */\n   131→  onEnqueueSuccess?(context: EnqueueSuccessContext): void | Promise<void>;\n   132→\n   133→  /**\n   134→   * Called when enqueue falls back to a secondary queue.\n   135→   */\n   136→  onEnqueueWarning?(context: EnqueueWarningContext): void | Promise<void>;\n   137→\n   138→  /**\n   139→   * Called when transport fallback occurs during send.\n   140→   * Only fires when using MultiTransport with fallbackEnabled=true.\n   141→   */\n   142→  onTransportFallback?(context: TransportFallbackContext): void | Promise<void>;\n   143→\n   144→  /**\n   145→   * Called when enqueue fails completely.\n   146→   */\n   147→  onEnqueueError?(context: EnqueueErrorContext): void | Promise<void>;\n   148→\n   149→  /**\n   150→   * Wraps entire worker processing (for APM context).\n   151→   * Must call execute() to run the actual processing.\n   152→   */\n   153→  onWorkerWrap?(\n   154→    envelope: Envelope,\n   155→    subscriber: SubscriberDefinition,\n   156→    execute: WorkerExecuteFn,\n   157→  ): Promise<void>;\n   158→\n   159→  /**\n   160→   * Called before processing begins.\n   161→   */\n   162→  onWorkerBeforeProcess?(\n   163→    envelope: Envelope,\n   164→    subscriber: SubscriberDefinition,\n   165→  ): void | Promise<void>;\n   166→\n   167→  /**\n   168→   * Called after successful processing.\n   169→   */\n   170→  onWorkerSuccess?(context: WorkerSuccessContext): void | Promise<void>;\n   171→\n   172→  /**\n   173→   * Called after processing error.\n   174→   */\n   175→  onWorkerError?(context: WorkerErrorContext): void | Promise<void>;\n   176→\n   177→  /**\n   178→   * Called when message decoding fails.\n   179→   */\n   180→  onDecodeError?(context: DecodeErrorContext): void | Promise<void>;\n   181→\n   182→  /**\n   183→   * Called when transport connection state changes.\n   184→   */\n   185→  onConnectionStateChange?(state: ConnectionState): void | Promise<void>;\n   186→\n   187→  /**\n   188→   * Loads universal metadata to add to all envelopes.\n   189→   */\n   190→  loadUniversalMetadata?():\n   191→    | Record<string, unknown>\n   192→    | Promise<Record<string, unknown>>;\n   193→\n   194→  /**\n   195→   * Dynamic queue concurrency lookup.\n   196→   */\n   197→  getQueueConcurrency?(\n   198→    queueName: string,\n   199→  ): number | undefined | Promise<number | undefined>;\n   200→\n   201→  /**\n   202→   * Dynamic retry delay lookup.\n   203→   */\n   204→  getRetryDelay?(\n   205→    envelope: Envelope,\n   206→    attemptNumber: number,\n   207→  ): number | undefined | Promise<number | undefined>;\n   208→\n   209→  /**\n   210→   * Dynamic max attempts lookup.\n   211→   */\n   212→  getAttempts?(\n   213→    envelope: Envelope,\n   214→  ): number | undefined | Promise<number | undefined>;\n   215→\n   216→  /**\n   217→   * Dynamic max deliveries (poison threshold) lookup.\n   218→   */\n   219→  getMaxDeliveries?(\n   220→    envelope: Envelope,\n   221→  ): number | undefined | Promise<number | undefined>;\n   222→\n   223→  // === Checkpoint Hooks (Resumable Subscribers) ===\n   224→\n   225→  /**\n   226→   * Called when a checkpoint is loaded for a retry.\n   227→   * Only fires for resumable subscribers on retry attempts.\n   228→   */\n   229→  onCheckpointLoaded?(context: CheckpointLoadedContext): void | Promise<void>;\n   230→\n   231→  /**\n   232→   * Called when an io() operation uses a cached value (checkpoint hit).\n   233→   * Useful for observability and metrics.\n   234→   */\n   235→  onCheckpointHit?(context: CheckpointHitContext): void | Promise<void>;\n   236→\n   237→  /**\n   238→   * Called when an io() operation executes (cache miss).\n   239→   * Useful for observability and metrics.\n   240→   */\n   241→  onCheckpointMiss?(context: CheckpointMissContext): void | Promise<void>;\n   242→\n   243→  /**\n   244→   * Called when a checkpoint is cleared.\n   245→   * Fires on successful completion or when moving to dead-letter queue.\n   246→   */\n   247→  onCheckpointCleared?(context: CheckpointClearedContext): void | Promise<void>;\n   248→}\n   249→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T15:37:51.117Z"
        },
        {
          "type": "user",
          "text": "     1→/**\n     2→ * Base class for all Matador errors.\n     3→ * All errors have a unique name that appears in monitoring tools (e.g., DataDog)\n     4→ * and a description explaining the error and actions to resolve it.\n     5→ *\n     6→ * The `name` property is automatically set to the class name for proper\n     7→ * identification in error monitoring and logging systems.\n     8→ */\n     9→export abstract class MatadorError extends Error {\n    10→  /**\n    11→   * Error class name (e.g., \"NotStartedError\", \"TransportNotConnectedError\").\n    12→   * This is preserved during serialization for error monitoring tools.\n    13→   */\n    14→  declare readonly name: string;\n    15→\n    16→  /**\n    17→   * Human-readable description explaining what went wrong and\n    18→   * what ACTION the user should take to resolve the issue.\n    19→   */\n    20→  abstract readonly description: string;\n    21→\n    22→  constructor(message: string) {\n    23→    super(message);\n    24→    this.name = this.constructor.name;\n    25→    // Ensure name is preserved when serialized\n    26→    Object.defineProperty(this, 'name', {\n    27→      value: this.constructor.name,\n    28→      enumerable: true,\n    29→      configurable: false,\n    30→      writable: false,\n    31→    });\n    32→  }\n    33→\n    34→  /**\n    35→   * Returns a serializable representation for logging/monitoring.\n    36→   */\n    37→  toJSON(): Record<string, unknown> {\n    38→    return {\n    39→      name: this.name,\n    40→      message: this.message,\n    41→      description: this.description,\n    42→      stack: this.stack,\n    43→    };\n    44→  }\n    45→}\n    46→\n    47→// ============================================================================\n    48→// Lifecycle Errors\n    49→// ============================================================================\n    50→\n    51→/**\n    52→ * Thrown when attempting to use Matador before calling start().\n    53→ */\n    54→export class NotStartedError extends MatadorError {\n    55→  readonly description =\n    56→    'Matador has not been started. ' +\n    57→    'ACTION: Call matador.start() before dispatching events or performing other operations. ' +\n    58→    'Ensure start() completes successfully before using other methods.';\n    59→\n    60→  constructor(operation = 'operation') {\n    61→    super(\n    62→      `Cannot perform ${operation}: Matador has not been started. Call start() first.`,\n    63→    );\n    64→  }\n    65→}\n    66→\n    67→/**\n    68→ * Thrown when attempting to dispatch events during shutdown.\n    69→ */\n    70→export class ShutdownInProgressError extends MatadorError {\n    71→  readonly description =\n    72→    'Matador is shutting down and will not accept new events. ' +\n    73→    'ACTION: Do not dispatch events after calling shutdown(). ' +\n    74→    'If you need to send events, do so before initiating shutdown. ' +\n    75→    'Consider implementing a pre-shutdown event flush if needed.';\n    76→\n    77→  constructor() {\n    78→    super('Cannot dispatch events: Matador is shutting down.');\n    79→  }\n    80→}\n    81→\n    82→// ============================================================================\n    83→// Transport Errors\n    84→// ============================================================================\n    85→\n    86→/**\n    87→ * Thrown when a transport operation is attempted but the transport is not connected.\n    88→ */\n    89→export class TransportNotConnectedError extends MatadorError {\n    90→  readonly description =\n    91→    'The transport is not connected to the message broker. ' +\n    92→    'ACTION: Ensure the transport is connected by calling transport.connect() or matador.start(). ' +\n    93→    'Check that the broker (e.g., RabbitMQ) is running and accessible. ' +\n    94→    'Verify connection settings (URL, credentials, network access).';\n    95→\n    96→  constructor(\n    97→    public readonly transportName: string,\n    98→    operation = 'operation',\n    99→  ) {\n   100→    super(\n   101→      `Cannot perform ${operation}: Transport \"${transportName}\" is not connected. ` +\n   102→        `Ensure connect() was called and the broker is accessible.`,\n   103→    );\n   104→  }\n   105→}\n   106→\n   107→/**\n   108→ * Thrown when the transport has been closed (during shutdown).\n   109→ */\n   110→export class TransportClosedError extends MatadorError {\n   111→  readonly description =\n   112→    'The transport has been closed and will not accept new operations. ' +\n   113→    'ACTION: This typically occurs during application shutdown. ' +\n   114→    'If unexpected, check for early shutdown triggers. ' +\n   115→    'Events sent after transport closure will be lost.';\n   116→\n   117→  constructor(public readonly transportName: string) {\n   118→    super(\n   119→      `Transport \"${transportName}\" has been closed and will not accept new operations.`,\n   120→    );\n   121→  }\n   122→}\n   123→\n   124→/**\n   125→ * Thrown when all transports in a fallback chain fail.\n   126→ */\n   127→export class AllTransportsFailedError extends MatadorError {\n   128→  readonly description =\n   129→    'All transports failed to send the message. ' +\n   130→    'ACTION: Check the health of all configured transports (primary and fallbacks). ' +\n   131→    'Review the errors array for specific failure reasons. ' +\n   132→    'Ensure at least one transport is properly configured and reachable. ' +\n   133→    'Consider adding a LocalTransport as a last-resort fallback.';\n   134→\n   135→  constructor(\n   136→    public readonly queue: string,\n   137→    public readonly errors: readonly Error[],\n   138→  ) {\n   139→    super(\n   140→      `All transports failed to send message to queue \"${queue}\". ` +\n   141→        `Errors: ${errors.map((e) => e.message).join('; ')}`,\n   142→    );\n   143→  }\n   144→}\n   145→\n   146→/**\n   147→ * Thrown when sending a message to the transport fails.\n   148→ */\n   149→export class TransportSendError extends MatadorError {\n   150→  readonly description =\n   151→    'Failed to send a message through the transport. ' +\n   152→    'ACTION: Check the underlying error for details. Common causes: ' +\n   153→    '(1) Transport disconnected during send, ' +\n   154→    '(2) Network issues between application and broker, ' +\n   155→    '(3) Broker rejected the message (size, permissions, queue limits). ' +\n   156→    'The message was NOT delivered and should be retried or logged.';\n   157→\n   158→  constructor(\n   159→    public readonly queue: string,\n   160→    public readonly cause: Error,\n   161→  ) {\n   162→    super(`Failed to send message to queue \"${queue}\": ${cause.message}`);\n   163→  }\n   164→\n   165→  override toJSON(): Record<string, unknown> {\n   166→    return {\n   167→      ...super.toJSON(),\n   168→      queue: this.queue,\n   169→      cause: {\n   170→        name: this.cause.name,\n   171→        message: this.cause.message,\n   172→      },\n   173→    };\n   174→  }\n   175→}\n   176→\n   177→/**\n   178→ * Thrown when delayed messages are requested but the plugin is not available.\n   179→ */\n   180→export class DelayedMessagesNotSupportedError extends MatadorError {\n   181→  readonly description =\n   182→    'Delayed messages were requested but the transport does not support them. ' +\n   183→    'ACTION: For RabbitMQ, install the rabbitmq_delayed_message_exchange plugin. ' +\n   184→    'Run: rabbitmq-plugins enable rabbitmq_delayed_message_exchange ' +\n   185→    'Then restart RabbitMQ and reconnect. ' +\n   186→    'Alternatively, remove delayMs from your event options if delays are not required.';\n   187→\n   188→  constructor(public readonly transportName: string) {\n   189→    super(\n   190→      `Delayed messages require the RabbitMQ delayed message exchange plugin. ` +\n   191→        `Install rabbitmq_delayed_message_exchange or remove delayMs from event options.`,\n   192→    );\n   193→  }\n   194→}\n   195→\n   196→// ============================================================================\n   197→// Schema & Configuration Errors\n   198→// ============================================================================\n   199→\n   200→/**\n   201→ * Thrown when an event is not registered in the schema.\n   202→ */\n   203→export class EventNotRegisteredError extends MatadorError {\n   204→  readonly description =\n   205→    'The event type is not registered in the schema. ' +\n   206→    'ACTION: Register the event using matador.register(EventClass, subscribers) before dispatching. ' +\n   207→    'If this occurs during message consumption, it may indicate schema drift between services. ' +\n   208→    'Ensure all services have matching schema registrations for shared events.';\n   209→\n   210→  constructor(public readonly eventKey: string) {\n   211→    super(\n   212→      `Event \"${eventKey}\" is not registered in schema. ` +\n   213→        `Register it using matador.register(EventClass, subscribers).`,\n   214→    );\n   215→  }\n   216→}\n   217→\n   218→/**\n   219→ * Thrown when a subscriber is not found for an event.\n   220→ */\n   221→export class SubscriberNotRegisteredError extends MatadorError {\n   222→  readonly description =\n   223→    'The subscriber is not registered for this event in the schema. ' +\n   224→    'ACTION: Ensure the subscriber is included in the registration for this event. ' +\n   225→    'This may occur if: (1) The subscriber was removed from the schema but messages still exist, ' +\n   226→    '(2) Schema drift between producer and consumer services, ' +\n   227→    '(3) A deployment is in progress with different schema versions. ' +\n   228→    'Check the dead-letter queue for affected messages.';\n   229→\n   230→  constructor(\n   231→    public readonly subscriberName: string,\n   232→    public readonly eventKey?: string,\n   233→  ) {\n   234→    super(\n   235→      `Subscriber \"${subscriberName}\" is not registered` +\n   236→        (eventKey ? ` for event \"${eventKey}\"` : '') +\n   237→        '. Check schema registration.',\n   238→    );\n   239→  }\n   240→}\n   241→\n   242→/**\n   243→ * Thrown when no subscribers exist for an event during fanout.\n   244→ */\n   245→export class NoSubscribersExistError extends MatadorError {\n   246→  readonly description =\n   247→    'The event has no subscribers registered. ' +\n   248→    'ACTION: Register at least one subscriber for this event type. ' +\n   249→    'If subscribers were intentionally removed, consider also removing the event dispatch. ' +\n   250→    'Events without subscribers are not useful and may indicate configuration issues.';\n   251→\n   252→  constructor(public readonly eventKey: string) {\n   253→    super(\n   254→      `No subscribers registered for event \"${eventKey}\". ` +\n   255→        `Add subscribers using matador.register(EventClass, [subscriber1, subscriber2]).`,\n   256→    );\n   257→  }\n   258→}\n   259→\n   260→/**\n   261→ * Thrown when the schema configuration is invalid.\n   262→ */\n   263→export class InvalidSchemaError extends MatadorError {\n   264→  readonly description =\n   265→    'The schema configuration is invalid. ' +\n   266→    'ACTION: Review the schema registration for issues. Common problems: ' +\n   267→    '(1) Duplicate subscriber names for the same event, ' +\n   268→    '(2) Missing required fields on event class (key, description), ' +\n   269→    '(3) Invalid alias configuration. ' +\n   270→    'Check the cause property for specific details.';\n   271→\n   272→  constructor(\n   273→    message: string,\n   274→    public readonly cause?: string,\n   275→  ) {\n   276→    super(`Invalid schema: ${message}` + (cause ? `. Cause: ${cause}` : ''));\n   277→  }\n   278→}\n   279→\n   280→/**\n   281→ * Thrown when a subscriber is a stub but is being processed locally.\n   282→ */\n   283→export class SubscriberIsStubError extends MatadorError {\n   284→  readonly description =\n   285→    'A SubscriberStub was registered in a consuming schema. ' +\n   286→    'ACTION: SubscriberStubs should only be used in producer schemas to declare ' +\n   287→    'that a subscriber exists in another service. ' +\n   288→    'In the consumer service, provide a full Subscriber with a callback function. ' +\n   289→    'Remove the stub from the consumer schema and add the actual implementation.';\n   290→\n   291→  constructor(public readonly subscriberName: string) {\n   292→    super(\n   293→      `Subscriber \"${subscriberName}\" is a stub and cannot be processed locally. ` +\n   294→        `Replace with a full Subscriber implementation in the consumer schema.`,\n   295→    );\n   296→  }\n   297→}\n   298→\n   299→/**\n   300→ * Thrown when a LocalTransport tries to process a stub subscriber.\n   301→ */\n   302→export class LocalTransportCannotProcessStubError extends MatadorError {\n   303→  readonly description =\n   304→    'The LocalTransport cannot process events for SubscriberStubs. ' +\n   305→    'ACTION: SubscriberStubs represent remote implementations that only RabbitMQ can route. ' +\n   306→    'If using LocalTransport for testing, provide mock implementations instead of stubs. ' +\n   307→    'For production fallback scenarios, be aware that stub-targeted events will be dropped.';\n   308→\n   309→  constructor(public readonly subscriberName: string) {\n   310→    super(\n   311→      `LocalTransport cannot process stub subscriber \"${subscriberName}\". ` +\n   312→        `Stub subscribers require a distributed transport like RabbitMQ.`,\n   313→    );\n   314→  }\n   315→}\n   316→\n   317→// ============================================================================\n   318→// Queue Errors\n   319→// ============================================================================\n   320→\n   321→/**\n   322→ * Thrown when a queue is not found or not created.\n   323→ */\n   324→export class QueueNotFoundError extends MatadorError {\n   325→  readonly description =\n   326→    'The specified queue does not exist or has not been created. ' +\n   327→    'ACTION: Ensure the queue is defined in the topology configuration. ' +\n   328→    'Call transport.applyTopology() or matador.start() to create queues. ' +\n   329→    'Check that the queue name matches the topology definition.';\n   330→\n   331→  constructor(public readonly queueName: string) {\n   332→    super(\n   333→      `Queue \"${queueName}\" not found. ` +\n   334→        `Ensure it is defined in topology and applyTopology() was called.`,\n   335→    );\n   336→  }\n   337→}\n   338→\n   339→// ============================================================================\n   340→// Event Validation Errors\n   341→// ============================================================================\n   342→\n   343→/**\n   344→ * Thrown when an event is invalid or malformed.\n   345→ */\n   346→export class InvalidEventError extends MatadorError {\n   347→  readonly description =\n   348→    'The event is invalid or missing required fields. ' +\n   349→    'ACTION: Ensure the event has all required properties. ' +\n   350→    'Common issues: missing targetSubscriber during processing, ' +\n   351→    'null/undefined data when the event type requires data, ' +\n   352→    'malformed event structure from codec decode failure.';\n   353→\n   354→  constructor(\n   355→    message: string,\n   356→    public readonly cause?: string,\n   357→  ) {\n   358→    super(`Invalid event: ${message}` + (cause ? `. Cause: ${cause}` : ''));\n   359→  }\n   360→}\n   361→\n   362→// ============================================================================\n   363→// Message Processing Errors\n   364→// ============================================================================\n   365→\n   366→/**\n   367→ * Thrown when a message has been redelivered too many times (poison message).\n   368→ */\n   369→export class MessageMaybePoisonedError extends MatadorError {\n   370→  readonly description =\n   371→    'A message was redelivered multiple times without successful processing. ' +\n   372→    'This usually indicates the message causes a crash or timeout during processing. ' +\n   373→    'ACTION: (1) Check application logs for errors/crashes during message processing, ' +\n   374→    '(2) Inspect the message in the dead-letter queue for malformed data, ' +\n   375→    '(3) Review the subscriber code for bugs that cause crashes, ' +\n   376→    '(4) Consider increasing processing timeout if the operation is legitimately slow. ' +\n   377→    'This message will NOT be retried to prevent crash loops.';\n   378→\n   379→  constructor(\n   380→    public readonly eventId: string,\n   381→    public readonly deliveryCount: number,\n   382→    public readonly maxDeliveries: number,\n   383→  ) {\n   384→    super(\n   385→      `Message \"${eventId}\" delivered ${deliveryCount} times (max: ${maxDeliveries}). ` +\n   386→        `Possible poison message - will not be retried.`,\n   387→    );\n   388→  }\n   389→}\n   390→\n   391→/**\n   392→ * Thrown when a non-idempotent message cannot be retried after redelivery.\n   393→ */\n   394→export class IdempotentMessageCannotRetryError extends MatadorError {\n   395→  readonly description =\n   396→    'A non-idempotent subscriber received a redelivered message. ' +\n   397→    'Retrying would risk duplicate side effects (e.g., double payments, duplicate emails). ' +\n   398→    'ACTION: (1) Mark the subscriber as idempotent if it safely handles duplicates, ' +\n   399→    '(2) Implement idempotency keys in the subscriber logic, ' +\n   400→    '(3) Manually inspect and replay the message from the dead-letter queue after verification. ' +\n   401→    'The message will be sent to the dead-letter queue for manual review.';\n   402→\n   403→  constructor(\n   404→    public readonly eventId: string,\n   405→    public readonly subscriberName: string,\n   406→  ) {\n   407→    super(\n   408→      `Non-idempotent subscriber \"${subscriberName}\" cannot retry redelivered message \"${eventId}\". ` +\n   409→        `Mark subscriber as idempotent='yes' or implement idempotency handling.`,\n   410→    );\n   411→  }\n   412→}\n   413→\n   414→// ============================================================================\n   415→// Timeout Errors\n   416→// ============================================================================\n   417→\n   418→/**\n   419→ * Thrown when an operation times out.\n   420→ */\n   421→export class TimeoutError extends MatadorError {\n   422→  readonly description =\n   423→    'An operation timed out before completing. ' +\n   424→    'ACTION: (1) Increase the timeout if the operation legitimately needs more time, ' +\n   425→    '(2) Optimize the operation to complete faster, ' +\n   426→    '(3) Check for deadlocks or blocking operations, ' +\n   427→    '(4) Verify external service dependencies are responsive.';\n   428→\n   429→  constructor(\n   430→    public readonly operation: string,\n   431→    public readonly timeoutMs: number,\n   432→  ) {\n   433→    super(`Operation \"${operation}\" timed out after ${timeoutMs}ms.`);\n   434→  }\n   435→}\n   436→\n   437→// ============================================================================\n   438→// Type Guards\n   439→// ============================================================================\n   440→\n   441→export function isMatadorError(error: unknown): error is MatadorError {\n   442→  return error instanceof MatadorError;\n   443→}\n   444→\n   445→export function isNotStartedError(error: unknown): error is NotStartedError {\n   446→  return error instanceof NotStartedError;\n   447→}\n   448→\n   449→export function isTransportNotConnectedError(\n   450→  error: unknown,\n   451→): error is TransportNotConnectedError {\n   452→  return error instanceof TransportNotConnectedError;\n   453→}\n   454→\n   455→export function isEventNotRegisteredError(\n   456→  error: unknown,\n   457→): error is EventNotRegisteredError {\n   458→  return error instanceof EventNotRegisteredError;\n   459→}\n   460→\n   461→export function isSubscriberNotRegisteredError(\n   462→  error: unknown,\n   463→): error is SubscriberNotRegisteredError {\n   464→  return error instanceof SubscriberNotRegisteredError;\n   465→}\n   466→\n   467→export function isMessageMaybePoisonedError(\n   468→  error: unknown,\n   469→): error is MessageMaybePoisonedError {\n   470→  return error instanceof MessageMaybePoisonedError;\n   471→}\n   472→\n   473→export function isIdempotentMessageCannotRetryError(\n   474→  error: unknown,\n   475→): error is IdempotentMessageCannotRetryError {\n   476→  return error instanceof IdempotentMessageCannotRetryError;\n   477→}\n   478→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T15:37:51.117Z"
        },
        {
          "type": "user",
          "text": "     1→/**\n     2→ * Base class for retry control errors.\n     3→ * These errors control the retry behavior of message processing.\n     4→ */\n     5→export abstract class RetryControlError extends Error {\n     6→  /**\n     7→   * Error class name for monitoring tools.\n     8→   */\n     9→  declare readonly name: string;\n    10→\n    11→  /**\n    12→   * Human-readable description of the error and recommended actions.\n    13→   */\n    14→  abstract readonly description: string;\n    15→\n    16→  constructor(message: string) {\n    17→    super(message);\n    18→    this.name = this.constructor.name;\n    19→    // Ensure name is preserved when serialized\n    20→    Object.defineProperty(this, 'name', {\n    21→      value: this.constructor.name,\n    22→      enumerable: true,\n    23→      configurable: false,\n    24→      writable: false,\n    25→    });\n    26→  }\n    27→\n    28→  /**\n    29→   * Returns a serializable representation for logging/monitoring.\n    30→   */\n    31→  toJSON(): Record<string, unknown> {\n    32→    return {\n    33→      name: this.name,\n    34→      message: this.message,\n    35→      description: this.description,\n    36→      stack: this.stack,\n    37→    };\n    38→  }\n    39→}\n    40→\n    41→/**\n    42→ * Forces retry regardless of subscriber idempotency setting.\n    43→ * Use when you know the operation is safe to retry.\n    44→ *\n    45→ * ACTION: Check subscriber code to understand why retry was forced.\n    46→ * This overrides default retry behavior based on idempotency settings.\n    47→ */\n    48→export class DoRetry extends RetryControlError {\n    49→  readonly description =\n    50→    'A subscriber explicitly requested retry by throwing DoRetry. ' +\n    51→    'ACTION: Check the subscriber code to understand why retry was forced. ' +\n    52→    'This overrides the default retry behavior based on idempotency settings.';\n    53→\n    54→  constructor(message = 'Forced retry requested') {\n    55→    super(message);\n    56→  }\n    57→}\n    58→\n    59→/**\n    60→ * Prevents retry regardless of subscriber idempotency setting.\n    61→ * Use for permanent failures that should not be retried.\n    62→ *\n    63→ * ACTION: Check subscriber code to understand why retry was disabled.\n    64→ * Typically used for permanent failures like invalid data or business rule violations.\n    65→ */\n    66→export class DontRetry extends RetryControlError {\n    67→  readonly description =\n    68→    'A subscriber explicitly prevented retry by throwing DontRetry. ' +\n    69→    'ACTION: Check the subscriber code to understand why retry was disabled. ' +\n    70→    'Typically used for permanent failures like invalid data or business rule violations. ' +\n    71→    'The message will be sent to the dead-letter queue for manual review.';\n    72→\n    73→  constructor(message = 'Retry explicitly disabled') {\n    74→    super(message);\n    75→  }\n    76→}\n    77→\n    78→/**\n    79→ * Assertion error that should never be retried.\n    80→ * Use for programming errors and invariant violations.\n    81→ *\n    82→ * ACTION: Review the assertion failure message to identify the bug\n    83→ * in the event payload or subscriber logic.\n    84→ */\n    85→export class EventAssertionError extends Error {\n    86→  declare readonly name: string;\n    87→\n    88→  readonly description =\n    89→    'An event assertion failed, indicating a programming error or invariant violation. ' +\n    90→    'ACTION: Review the assertion failure message to identify the bug in the ' +\n    91→    'event payload or subscriber logic. These errors are never retried and go ' +\n    92→    'directly to the dead-letter queue.';\n    93→\n    94→  constructor(message: string) {\n    95→    super(message);\n    96→    this.name = 'EventAssertionError';\n    97→    Object.defineProperty(this, 'name', {\n    98→      value: 'EventAssertionError',\n    99→      enumerable: true,\n   100→      configurable: false,\n   101→      writable: false,\n   102→    });\n   103→  }\n   104→\n   105→  toJSON(): Record<string, unknown> {\n   106→    return {\n   107→      name: this.name,\n   108→      message: this.message,\n   109→      description: this.description,\n   110→      stack: this.stack,\n   111→    };\n   112→  }\n   113→}\n   114→\n   115→/**\n   116→ * Checks if an error forces a retry.\n   117→ */\n   118→export function isDoRetry(error: unknown): error is DoRetry {\n   119→  return error instanceof DoRetry;\n   120→}\n   121→\n   122→/**\n   123→ * Checks if an error prevents retry.\n   124→ */\n   125→export function isDontRetry(error: unknown): error is DontRetry {\n   126→  return error instanceof DontRetry;\n   127→}\n   128→\n   129→/**\n   130→ * Checks if an error is an assertion error (never retry).\n   131→ */\n   132→export function isAssertionError(error: unknown): error is EventAssertionError {\n   133→  return error instanceof EventAssertionError;\n   134→}\n   135→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T15:37:51.117Z"
        },
        {
          "type": "user",
          "text": "     1→export type {\n     2→  DeadLetterConfig,\n     3→  DeadLetterQueueConfig,\n     4→  QueueDefinition,\n     5→  RetryConfig,\n     6→  Topology,\n     7→} from './types.js';\n     8→export {\n     9→  getDeadLetterQueueName,\n    10→  getQualifiedQueueName,\n    11→  getRetryQueueName,\n    12→} from './types.js';\n    13→\n    14→export type { QueueOptions } from './builder.js';\n    15→export { TopologyBuilder, TopologyValidationError } from './builder.js';\n    16→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T15:37:51.118Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/topology/types.ts"
          },
          "timestamp": "2025-12-11T15:37:55.159Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/retry/index.ts"
          },
          "timestamp": "2025-12-11T15:37:55.644Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/transport/multi/index.ts"
          },
          "timestamp": "2025-12-11T15:37:56.265Z"
        },
        {
          "type": "tool_use",
          "name": "Glob",
          "input": {
            "path": "/home/z/Desktop/work/matador/packages/matador/src",
            "pattern": "**/transport/multi/*.ts"
          },
          "timestamp": "2025-12-11T15:37:56.897Z"
        },
        {
          "type": "user",
          "text": "<tool_use_error>File does not exist.</tool_use_error>",
          "timestamp": "2025-12-11T15:37:56.957Z"
        },
        {
          "type": "user",
          "text": "     1→/**\n     2→ * Transport-agnostic topology definition.\n     3→ * Matador owns the topology; transports translate and apply it.\n     4→ */\n     5→export interface Topology {\n     6→  /** Namespace prefix for all queues */\n     7→  readonly namespace: string;\n     8→\n     9→  /** Work queues for processing events */\n    10→  readonly queues: readonly QueueDefinition[];\n    11→\n    12→  /** Dead-letter queue configuration */\n    13→  readonly deadLetter: DeadLetterConfig;\n    14→\n    15→  /** Retry queue configuration */\n    16→  readonly retry: RetryConfig;\n    17→}\n    18→\n    19→/**\n    20→ * Individual queue definition.\n    21→ */\n    22→export interface QueueDefinition {\n    23→  /** Queue name (will be prefixed with namespace) */\n    24→  readonly name: string;\n    25→\n    26→  /** Concurrency for this queue */\n    27→  readonly concurrency?: number | undefined;\n    28→\n    29→  /** Consumer timeout in milliseconds */\n    30→  readonly consumerTimeout?: number | undefined;\n    31→\n    32→  /** Enable priority support if transport allows */\n    33→  readonly priorities?: boolean | undefined;\n    34→\n    35→  /**\n    36→   * When true, the queue name is used exactly as provided without any\n    37→   * modification. The namespace prefix will NOT be added, and no other\n    38→   * transformations will be applied. Use this for referencing external\n    39→   * queues that are not managed by Matador.\n    40→   */\n    41→  readonly exact?: boolean | undefined;\n    42→}\n    43→\n    44→/**\n    45→ * Dead-letter queue configuration.\n    46→ */\n    47→export interface DeadLetterConfig {\n    48→  /** Unhandled events (schema mismatch) queue */\n    49→  readonly unhandled: DeadLetterQueueConfig;\n    50→\n    51→  /** Undeliverable events (permanent failures) queue */\n    52→  readonly undeliverable: DeadLetterQueueConfig;\n    53→}\n    54→\n    55→/**\n    56→ * Configuration for a specific dead-letter queue.\n    57→ */\n    58→export interface DeadLetterQueueConfig {\n    59→  /** Whether this DLQ is enabled */\n    60→  readonly enabled: boolean;\n    61→\n    62→  /** Maximum number of messages in the DLQ */\n    63→  readonly maxLength?: number | undefined;\n    64→}\n    65→\n    66→/**\n    67→ * Retry queue configuration.\n    68→ */\n    69→export interface RetryConfig {\n    70→  /** Enable retry queue with delay */\n    71→  readonly enabled: boolean;\n    72→\n    73→  /** Default retry delay in milliseconds */\n    74→  readonly defaultDelayMs: number;\n    75→\n    76→  /** Maximum retry delay in milliseconds */\n    77→  readonly maxDelayMs: number;\n    78→}\n    79→\n    80→/**\n    81→ * Gets the fully qualified queue name with namespace prefix.\n    82→ */\n    83→export function getQualifiedQueueName(\n    84→  namespace: string,\n    85→  queueName: string,\n    86→): string {\n    87→  return `${namespace}.${queueName}`;\n    88→}\n    89→\n    90→/**\n    91→ * Gets the dead-letter queue name for a given queue.\n    92→ */\n    93→export function getDeadLetterQueueName(\n    94→  namespace: string,\n    95→  queueName: string,\n    96→  dlqType: 'unhandled' | 'undeliverable',\n    97→): string {\n    98→  return `${namespace}.${queueName}.${dlqType}`;\n    99→}\n   100→\n   101→/**\n   102→ * Gets the retry queue name for a given queue.\n   103→ */\n   104→export function getRetryQueueName(\n   105→  namespace: string,\n   106→  queueName: string,\n   107→): string {\n   108→  return `${namespace}.${queueName}.retry`;\n   109→}\n   110→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T15:37:57.080Z"
        },
        {
          "type": "user",
          "text": "     1→export type { RetryContext, RetryDecision, RetryPolicy } from './policy.js';\n     2→\n     3→export type { StandardRetryPolicyConfig } from './standard-policy.js';\n     4→export { defaultRetryConfig, StandardRetryPolicy } from './standard-policy.js';\n     5→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T15:37:57.080Z"
        },
        {
          "type": "user",
          "text": "/home/z/Desktop/work/matador/packages/matador/src/transport/multi/multi-transport.ts\n/home/z/Desktop/work/matador/packages/matador/src/transport/multi/multi-transport.test.ts",
          "timestamp": "2025-12-11T15:37:57.104Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/transport/multi/multi-transport.ts"
          },
          "timestamp": "2025-12-11T15:38:02.067Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/retry/standard-policy.ts"
          },
          "timestamp": "2025-12-11T15:38:02.835Z"
        },
        {
          "type": "tool_use",
          "name": "Glob",
          "input": {
            "path": "/home/z/Desktop/work/matador/packages/matador/src",
            "pattern": "**/cli*.ts"
          },
          "timestamp": "2025-12-11T15:38:03.508Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/package.json"
          },
          "timestamp": "2025-12-11T15:38:03.793Z"
        },
        {
          "type": "user",
          "text": "     1→import { AllTransportsFailedError } from '../../errors/index.js';\n     2→import type { TransportFallbackContext } from '../../hooks/index.js';\n     3→import type { Topology } from '../../topology/types.js';\n     4→import type { Envelope } from '../../types/index.js';\n     5→import type { TransportCapabilities } from '../capabilities.js';\n     6→import type {\n     7→  MessageHandler,\n     8→  MessageReceipt,\n     9→  SendOptions,\n    10→  SubscribeOptions,\n    11→  Subscription,\n    12→  Transport,\n    13→} from '../transport.js';\n    14→\n    15→/**\n    16→ * Symbol key used to store the source transport on wrapped receipts.\n    17→ */\n    18→const SOURCE_TRANSPORT = Symbol('sourceTransport');\n    19→\n    20→/**\n    21→ * Extracts the source transport from a tagged receipt.\n    22→ */\n    23→function getSourceTransport(receipt: MessageReceipt): Transport | undefined {\n    24→  return (receipt as unknown as Record<symbol, Transport | undefined>)[\n    25→    SOURCE_TRANSPORT\n    26→  ];\n    27→}\n    28→\n    29→/**\n    30→ * Configuration for MultiTransport.\n    31→ */\n    32→export interface MultiTransportConfig {\n    33→  /**\n    34→   * Ordered list of transports.\n    35→   * First transport is primary, rest are used as fallbacks when primary fails\n    36→   * (if fallback is enabled), or can be explicitly selected via the getDesiredBackend hook.\n    37→   */\n    38→  readonly transports: readonly Transport[];\n    39→\n    40→  /**\n    41→   * Whether to automatically try fallback transports when the primary/selected fails.\n    42→   * When true (default), send() will try each transport in order until one succeeds.\n    43→   * When false, send() will only use the selected transport and throw immediately on failure.\n    44→   *\n    45→   * @default true\n    46→   */\n    47→  readonly fallbackEnabled?: boolean;\n    48→}\n    49→\n    50→/**\n    51→ * Hooks for MultiTransport.\n    52→ */\n    53→export interface MultiTransportHooks {\n    54→  /**\n    55→   * Hook to dynamically select which backend to use.\n    56→   * Return the transport name (e.g., 'local', 'rabbitmq') or undefined to use primary.\n    57→   *\n    58→   * @example\n    59→   * ```typescript\n    60→   * getDesiredBackend: async () => {\n    61→   *   if (process.env.SANDBOX === 'true') return 'local';\n    62→   *   const backend = await runtimeConfig.get('events.backend');\n    63→   *   return backend || 'rabbitmq';\n    64→   * }\n    65→   * ```\n    66→   */\n    67→  readonly getDesiredBackend?: () =>\n    68→    | string\n    69→    | undefined\n    70→    | Promise<string | undefined>;\n    71→\n    72→  /**\n    73→   * Called when a fallback transport is used successfully after the selected one fails.\n    74→   * Only called when fallbackEnabled is true.\n    75→   */\n    76→  readonly onEnqueueFallback?: (context: TransportFallbackContext) => void;\n    77→}\n    78→\n    79→/**\n    80→ * Computes merged capabilities from multiple transports.\n    81→ * Uses the most restrictive/conservative interpretation.\n    82→ */\n    83→function mergeCapabilities(\n    84→  transports: readonly Transport[],\n    85→): TransportCapabilities {\n    86→  const primary = transports[0];\n    87→  if (!primary) {\n    88→    throw new Error('At least one transport is required');\n    89→  }\n    90→\n    91→  // For multi-transport scenarios, we use primary's capabilities since that's\n    92→  // what we'll use for subscriptions and most operations\n    93→  return primary.capabilities;\n    94→}\n    95→\n    96→/**\n    97→ * A transport wrapper that manages multiple transports.\n    98→ *\n    99→ * Features:\n   100→ * - All transports are connected upfront\n   101→ * - send() tries transports in order until one succeeds (fallback behavior)\n   102→ * - Specific transport can be selected via getDesiredBackend hook\n   103→ * - Subscriptions are created on ALL transports\n   104→ *\n   105→ * @example\n   106→ * ```typescript\n   107→ * const transport = new MultiTransport(\n   108→ *   { transports: [rabbitMQTransport, localTransport] },\n   109→ *   { onEnqueueFallback: (ctx) => console.warn(`Fallback to ${ctx.nextTransport}`) },\n   110→ * );\n   111→ * ```\n   112→ */\n   113→export class MultiTransport implements Transport {\n   114→  readonly name: string;\n   115→  readonly capabilities: TransportCapabilities;\n   116→  readonly primary: Transport;\n   117→\n   118→  /** All available transports, in order of preference (primary first). */\n   119→  readonly transports: readonly Transport[];\n   120→\n   121→  /** Whether fallback to secondary transports is enabled. */\n   122→  readonly fallbackEnabled: boolean;\n   123→\n   124→  private readonly hooks: MultiTransportHooks;\n   125→  private connected = false;\n   126→\n   127→  constructor(config: MultiTransportConfig, hooks: MultiTransportHooks = {}) {\n   128→    const primary = config.transports[0];\n   129→    if (!primary) {\n   130→      throw new Error('At least one transport is required');\n   131→    }\n   132→\n   133→    this.primary = primary;\n   134→    this.transports = config.transports;\n   135→    this.fallbackEnabled = config.fallbackEnabled ?? true;\n   136→    this.hooks = hooks;\n   137→    this.name = `multi(${this.transports.map((t) => t.name).join(',')})`;\n   138→    this.capabilities = mergeCapabilities(this.transports);\n   139→  }\n   140→\n   141→  async connect(): Promise<void> {\n   142→    // Connect all transports in parallel\n   143→    await Promise.all(this.transports.map((t) => t.connect()));\n   144→    this.connected = true;\n   145→  }\n   146→\n   147→  async disconnect(): Promise<void> {\n   148→    // Disconnect all transports in parallel\n   149→    await Promise.all(this.transports.map((t) => t.disconnect()));\n   150→    this.connected = false;\n   151→  }\n   152→\n   153→  isConnected(): boolean {\n   154→    // Consider connected if primary is connected\n   155→    return this.connected && this.primary.isConnected();\n   156→  }\n   157→\n   158→  async applyTopology(topology: Topology): Promise<void> {\n   159→    // Apply topology to all transports so they're all ready\n   160→    await Promise.all(this.transports.map((t) => t.applyTopology(topology)));\n   161→  }\n   162→\n   163→  async send(\n   164→    queue: string,\n   165→    envelope: Envelope,\n   166→    options?: SendOptions,\n   167→  ): Promise<Transport['name']> {\n   168→    // Determine which transport to use\n   169→    const selectedTransport = await this.selectTransport();\n   170→\n   171→    // If fallback is disabled, only use selected transport\n   172→    if (!this.fallbackEnabled) {\n   173→      return selectedTransport.send(queue, envelope, options);\n   174→    }\n   175→\n   176→    // Build transport order: selected first, then others\n   177→    const transportOrder = this.getTransportOrder(selectedTransport);\n   178→\n   179→    const errors: Error[] = [];\n   180→\n   181→    for (let i = 0; i < transportOrder.length; i++) {\n   182→      const transport = transportOrder[i]!;\n   183→      try {\n   184→        return await transport.send(queue, envelope, options);\n   185→      } catch (error) {\n   186→        const err = error instanceof Error ? error : new Error(String(error));\n   187→        errors.push(err);\n   188→\n   189→        // Notify about fallback before trying next transport\n   190→        const nextTransport = transportOrder[i + 1];\n   191→        if (nextTransport && this.hooks.onEnqueueFallback) {\n   192→          this.hooks.onEnqueueFallback({\n   193→            envelope,\n   194→            queue,\n   195→            failedTransport: transport.name,\n   196→            nextTransport: nextTransport.name,\n   197→            error: err,\n   198→          });\n   199→        }\n   200→        // Continue to next transport\n   201→      }\n   202→    }\n   203→\n   204→    // All transports failed\n   205→    throw new AllTransportsFailedError(queue, errors);\n   206→  }\n   207→\n   208→  /**\n   209→   * Selects the transport to use based on the getDesiredBackend hook.\n   210→   */\n   211→  private async selectTransport(): Promise<Transport> {\n   212→    if (!this.hooks.getDesiredBackend) {\n   213→      return this.primary;\n   214→    }\n   215→\n   216→    try {\n   217→      const desiredBackend = await this.hooks.getDesiredBackend();\n   218→      if (!desiredBackend) {\n   219→        return this.primary;\n   220→      }\n   221→\n   222→      const selected = this.transports.find((t) => t.name === desiredBackend);\n   223→      if (selected) {\n   224→        return selected;\n   225→      }\n   226→\n   227→      // Desired backend not found, use primary\n   228→      return this.primary;\n   229→    } catch {\n   230→      // Hook threw, use primary\n   231→      return this.primary;\n   232→    }\n   233→  }\n   234→\n   235→  /**\n   236→   * Returns transports in order, with the selected transport first.\n   237→   */\n   238→  private getTransportOrder(selected: Transport): readonly Transport[] {\n   239→    if (selected === this.primary) {\n   240→      return this.transports;\n   241→    }\n   242→\n   243→    // Put selected first, then the rest (excluding selected)\n   244→    return [selected, ...this.transports.filter((t) => t !== selected)];\n   245→  }\n   246→\n   247→  async subscribe(\n   248→    queue: string,\n   249→    handler: MessageHandler,\n   250→    options?: SubscribeOptions,\n   251→  ): Promise<Subscription> {\n   252→    // Subscribe on ALL transports so messages are processed regardless of\n   253→    // which transport they were enqueued to\n   254→    const subscriptions = await Promise.all(\n   255→      this.transports.map((transport) => {\n   256→        // Wrap handler to tag receipts with source transport\n   257→        const wrappedHandler: MessageHandler = (envelope, receipt) => {\n   258→          const taggedReceipt = Object.assign(receipt, {\n   259→            [SOURCE_TRANSPORT]: transport,\n   260→          });\n   261→          return handler(envelope, taggedReceipt);\n   262→        };\n   263→        return transport.subscribe(queue, wrappedHandler, options);\n   264→      }),\n   265→    );\n   266→\n   267→    return {\n   268→      unsubscribe: async () => {\n   269→        await Promise.all(subscriptions.map((s) => s.unsubscribe()));\n   270→      },\n   271→      get isActive() {\n   272→        return subscriptions.some((s) => s.isActive);\n   273→      },\n   274→    };\n   275→  }\n   276→\n   277→  async complete(receipt: MessageReceipt): Promise<void> {\n   278→    const transport = getSourceTransport(receipt) ?? this.primary;\n   279→    return transport.complete(receipt);\n   280→  }\n   281→\n   282→  async sendToDeadLetter(\n   283→    receipt: MessageReceipt,\n   284→    dlqName: string,\n   285→    envelope: Envelope,\n   286→    reason: string,\n   287→  ): Promise<void> {\n   288→    const transport = getSourceTransport(receipt) ?? this.primary;\n   289→    if (transport.sendToDeadLetter) {\n   290→      return transport.sendToDeadLetter(receipt, dlqName, envelope, reason);\n   291→    }\n   292→    throw new Error('Transport does not support dead letter routing');\n   293→  }\n   294→}\n   295→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T15:38:04.041Z"
        },
        {
          "type": "user",
          "text": "     1→import {\n     2→  IdempotentMessageCannotRetryError,\n     3→  MessageMaybePoisonedError,\n     4→  isAssertionError,\n     5→  isDoRetry,\n     6→  isDontRetry,\n     7→} from '../errors/index.js';\n     8→import type { RetryContext, RetryDecision, RetryPolicy } from './policy.js';\n     9→\n    10→/**\n    11→ * Configuration for the standard retry policy.\n    12→ */\n    13→export interface StandardRetryPolicyConfig {\n    14→  /** Maximum number of attempts before dead-lettering */\n    15→  readonly maxAttempts: number;\n    16→\n    17→  /** Base delay between retries in milliseconds */\n    18→  readonly baseDelay: number;\n    19→\n    20→  /** Maximum delay between retries in milliseconds */\n    21→  readonly maxDelay: number;\n    22→\n    23→  /** Multiplier for exponential backoff */\n    24→  readonly backoffMultiplier: number;\n    25→\n    26→  /**\n    27→   * Maximum native delivery count before considering message poisoned.\n    28→   * This prevents crash loops from messages that crash the worker.\n    29→   * Poison messages are sent directly to the dead-letter queue.\n    30→   * Default: 5\n    31→   */\n    32→  readonly maxDeliveries: number;\n    33→}\n    34→\n    35→/**\n    36→ * Default configuration values.\n    37→ */\n    38→export const defaultRetryConfig: StandardRetryPolicyConfig = {\n    39→  maxAttempts: 3,\n    40→  baseDelay: 1000,\n    41→  maxDelay: 300000, // 5 minutes\n    42→  backoffMultiplier: 2,\n    43→  maxDeliveries: 5,\n    44→};\n    45→\n    46→/**\n    47→ * Standard retry policy implementing Matador v1 behavior.\n    48→ *\n    49→ * Decision logic (in priority order):\n    50→ * 1. Poison message → dead-letter (prevent crash loops)\n    51→ * 2. EventAssertionError → dead-letter (never retry)\n    52→ * 3. DontRetry → dead-letter (explicit no-retry)\n    53→ * 4. DoRetry → retry if under max attempts\n    54→ * 5. Max attempts exceeded → dead-letter\n    55→ * 6. Non-idempotent subscriber on redelivery → dead-letter\n    56→ * 7. Default → retry with exponential backoff\n    57→ */\n    58→export class StandardRetryPolicy implements RetryPolicy {\n    59→  private readonly config: StandardRetryPolicyConfig;\n    60→\n    61→  constructor(config: Partial<StandardRetryPolicyConfig> = {}) {\n    62→    this.config = { ...defaultRetryConfig, ...config };\n    63→  }\n    64→\n    65→  shouldRetry(context: RetryContext): RetryDecision {\n    66→    const { envelope, error, subscriber, receipt } = context;\n    67→    const errorMessage = error.message;\n    68→\n    69→    // 1. Poison message detection - prevent crash loops\n    70→    if (receipt.deliveryCount >= this.config.maxDeliveries) {\n    71→      const poisonError = new MessageMaybePoisonedError(\n    72→        envelope.id,\n    73→        receipt.deliveryCount,\n    74→        this.config.maxDeliveries,\n    75→      );\n    76→      return {\n    77→        action: 'dead-letter',\n    78→        queue: 'undeliverable',\n    79→        reason: poisonError.message,\n    80→      };\n    81→    }\n    82→\n    83→    // 2. Assertion errors never retry\n    84→    if (isAssertionError(error)) {\n    85→      return {\n    86→        action: 'dead-letter',\n    87→        queue: 'undeliverable',\n    88→        reason: `assertion error: ${errorMessage}`,\n    89→      };\n    90→    }\n    91→\n    92→    // 3. Explicit no-retry\n    93→    if (isDontRetry(error)) {\n    94→      return {\n    95→        action: 'dead-letter',\n    96→        queue: 'undeliverable',\n    97→        reason: errorMessage,\n    98→      };\n    99→    }\n   100→\n   101→    // 4. Explicit retry request\n   102→    if (isDoRetry(error)) {\n   103→      if (receipt.attemptNumber >= this.config.maxAttempts) {\n   104→        return {\n   105→          action: 'dead-letter',\n   106→          queue: 'undeliverable',\n   107→          reason: `max attempts exceeded (${this.config.maxAttempts}) with forced retry`,\n   108→        };\n   109→      }\n   110→      return {\n   111→        action: 'retry',\n   112→        delay: this.getDelay(context),\n   113→      };\n   114→    }\n   115→\n   116→    // 5. Max attempts exceeded\n   117→    if (receipt.attemptNumber >= this.config.maxAttempts) {\n   118→      return {\n   119→        action: 'dead-letter',\n   120→        queue: 'undeliverable',\n   121→        reason: `max attempts exceeded (${this.config.maxAttempts})`,\n   122→      };\n   123→    }\n   124→\n   125→    // 6. Non-idempotent subscriber on redelivery\n   126→    if (receipt.redelivered && subscriber.idempotent === 'no') {\n   127→      const idempotentError = new IdempotentMessageCannotRetryError(\n   128→        envelope.id,\n   129→        subscriber.name,\n   130→      );\n   131→      return {\n   132→        action: 'dead-letter',\n   133→        queue: 'undeliverable',\n   134→        reason: idempotentError.message,\n   135→      };\n   136→    }\n   137→\n   138→    // 7. Default: retry with backoff\n   139→    return {\n   140→      action: 'retry',\n   141→      delay: this.getDelay(context),\n   142→    };\n   143→  }\n   144→\n   145→  getDelay(context: RetryContext): number {\n   146→    const attempt = context.receipt.attemptNumber;\n   147→    const delay =\n   148→      this.config.baseDelay *\n   149→      Math.pow(this.config.backoffMultiplier, attempt - 1);\n   150→    return Math.min(delay, this.config.maxDelay);\n   151→  }\n   152→}\n   153→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T15:38:04.042Z"
        },
        {
          "type": "user",
          "text": "     1→{\n     2→  \"name\": \"@meetsmore/matador-v2\",\n     3→  \"version\": \"2.0.0\",\n     4→  \"description\": \"Transport-agnostic event processing library\",\n     5→  \"type\": \"module\",\n     6→  \"main\": \"./dist/index.cjs\",\n     7→  \"module\": \"./dist/index.js\",\n     8→  \"types\": \"./dist/index.d.ts\",\n     9→  \"exports\": {\n    10→    \".\": {\n    11→      \"import\": {\n    12→        \"types\": \"./dist/index.d.ts\",\n    13→        \"default\": \"./dist/index.js\"\n    14→      },\n    15→      \"require\": {\n    16→        \"types\": \"./dist/index.d.cts\",\n    17→        \"default\": \"./dist/index.cjs\"\n    18→      }\n    19→    }\n    20→  },\n    21→  \"bin\": {\n    22→    \"matador-cli\": \"./cli.ts\"\n    23→  },\n    24→  \"scripts\": {\n    25→    \"build\": \"tsup\",\n    26→    \"test\": \"bun test\",\n    27→    \"test:watch\": \"bun test --watch\",\n    28→    \"test:integration\": \"bun test --grep integration\",\n    29→    \"lint\": \"bunx biome check .\",\n    30→    \"lint:fix\": \"bunx biome check . --fix\",\n    31→    \"typecheck\": \"tsc --noEmit\",\n    32→    \"clean\": \"rm -rf dist\",\n    33→    \"cli\": \"bun ./cli.ts\",\n    34→    \"send-test-event\": \"bun ./cli.ts ./examples/config.ts ./examples/event.ts\"\n    35→  },\n    36→  \"dependencies\": {\n    37→    \"amqplib\": \"^0.10.4\"\n    38→  },\n    39→  \"devDependencies\": {\n    40→    \"@testcontainers/rabbitmq\": \"^10.16.0\",\n    41→    \"@types/amqplib\": \"^0.10.5\",\n    42→    \"testcontainers\": \"^10.16.0\",\n    43→    \"tsup\": \"^8.3.5\"\n    44→  },\n    45→  \"peerDependencies\": {\n    46→    \"zod\": \"^3.0.0\"\n    47→  },\n    48→  \"peerDependenciesMeta\": {\n    49→    \"zod\": {\n    50→      \"optional\": true\n    51→    }\n    52→  },\n    53→  \"engines\": {\n    54→    \"node\": \">=18.0.0\"\n    55→  },\n    56→  \"keywords\": [\n    57→    \"events\",\n    58→    \"messaging\",\n    59→    \"queue\",\n    60→    \"rabbitmq\",\n    61→    \"bullmq\",\n    62→    \"kafka\",\n    63→    \"transport\"\n    64→  ],\n    65→  \"license\": \"MIT\"\n    66→}\n    67→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T15:38:04.042Z"
        },
        {
          "type": "user",
          "text": "No files found",
          "timestamp": "2025-12-11T15:38:04.070Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/cli.ts"
          },
          "timestamp": "2025-12-11T15:38:07.474Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/types/subscriber.ts"
          },
          "timestamp": "2025-12-11T15:38:08.045Z"
        },
        {
          "type": "tool_use",
          "name": "Grep",
          "input": {
            "path": "/home/z/Desktop/work/matador/packages/matador/src",
            "pattern": "installPlugin"
          },
          "timestamp": "2025-12-11T15:38:08.620Z"
        },
        {
          "type": "user",
          "text": "     1→#!/usr/bin/env bun\n     2→/**\n     3→ * Matador CLI - Quick local testing of your Matador config\n     4→ *\n     5→ * Usage: ./cli.ts <path-to-config-file> <path-to-event-file>\n     6→ *\n     7→ * Config file should export:\n     8→ *   - schema: MatadorSchema - Map of event keys to [EventClass, Subscribers[]]\n     9→ *   - topology?: Topology - Optional topology (defaults to simple 'events' queue)\n    10→ *   - hooks?: MatadorHooks - Optional hooks\n    11→ *\n    12→ * Event file should export:\n    13→ *   - eventKey: string - The key of the event to dispatch\n    14→ *   - data: unknown - The event data payload\n    15→ *   - before?: unknown - Optional 'before' data for change events\n    16→ *   - options?: EventOptions - Optional dispatch options (correlationId, metadata, delayMs)\n    17→ */\n    18→\n    19→import { resolve } from 'node:path';\n    20→import { parseArgs } from 'node:util';\n    21→import {\n    22→  type EventOptions,\n    23→  LocalTransport,\n    24→  Matador,\n    25→  type MatadorHooks,\n    26→  type MatadorSchema,\n    27→  type Topology,\n    28→  TopologyBuilder,\n    29→  consoleLogger,\n    30→  isSchemaEntryTuple,\n    31→} from './src/index.js';\n    32→\n    33→// Colors for terminal output\n    34→const colors = {\n    35→  reset: '\\x1b[0m',\n    36→  bold: '\\x1b[1m',\n    37→  dim: '\\x1b[2m',\n    38→  red: '\\x1b[31m',\n    39→  green: '\\x1b[32m',\n    40→  yellow: '\\x1b[33m',\n    41→  blue: '\\x1b[34m',\n    42→  magenta: '\\x1b[35m',\n    43→  cyan: '\\x1b[36m',\n    44→};\n    45→\n    46→function log(message: string, color: keyof typeof colors = 'reset'): void {\n    47→  console.log(`${colors[color]}${message}${colors.reset}`);\n    48→}\n    49→\n    50→function logSection(title: string): void {\n    51→  console.log();\n    52→  log(`━━━ ${title} ━━━`, 'cyan');\n    53→}\n    54→\n    55→function logSuccess(message: string): void {\n    56→  log(`✓ ${message}`, 'green');\n    57→}\n    58→\n    59→function logError(message: string): void {\n    60→  log(`✗ ${message}`, 'red');\n    61→}\n    62→\n    63→function logInfo(message: string): void {\n    64→  log(`ℹ ${message}`, 'blue');\n    65→}\n    66→\n    67→function logWarning(message: string): void {\n    68→  log(`⚠ ${message}`, 'yellow');\n    69→}\n    70→\n    71→interface ConfigExport {\n    72→  schema: MatadorSchema;\n    73→  topology?: Topology;\n    74→  hooks?: MatadorHooks;\n    75→}\n    76→\n    77→interface EventExport {\n    78→  eventKey: string;\n    79→  data: unknown;\n    80→  before?: unknown;\n    81→  options?: EventOptions;\n    82→}\n    83→\n    84→function printUsage(): void {\n    85→  console.log(`\n    86→${colors.bold}Matador CLI${colors.reset} - Quick local testing of your Matador config\n    87→\n    88→${colors.cyan}Usage:${colors.reset}\n    89→  ./cli.ts <config-file> <event-file>\n    90→  bun cli.ts <config-file> <event-file>\n    91→\n    92→${colors.cyan}Arguments:${colors.reset}\n    93→  config-file   Path to your Matador config file (TypeScript/JavaScript)\n    94→  event-file    Path to your event file (TypeScript/JavaScript/JSON)\n    95→\n    96→${colors.cyan}Options:${colors.reset}\n    97→  --help, -h    Show this help message\n    98→  --dry-run     Validate config and event without dispatching\n    99→  --timeout     Timeout in milliseconds for processing (default: 5000)\n   100→  --verbose     Show verbose output including all hook logs\n   101→\n   102→${colors.cyan}Config file exports:${colors.reset}\n   103→  schema        MatadorSchema - Map of event keys to [EventClass, Subscribers[]]\n   104→  topology?     Topology - Optional topology config\n   105→  hooks?        MatadorHooks - Optional hooks for logging\n   106→\n   107→${colors.cyan}Event file exports:${colors.reset}\n   108→  eventKey      string - The key of the event to dispatch\n   109→  data          unknown - The event data payload\n   110→  before?       unknown - Optional 'before' data for change events\n   111→  options?      EventOptions - Optional dispatch options\n   112→\n   113→${colors.cyan}Examples:${colors.reset}\n   114→  ./cli.ts ./my-config.ts ./test-event.ts\n   115→  bun cli.ts ./config/matador.ts ./events/user-created.json --verbose\n   116→`);\n   117→}\n   118→\n   119→async function loadModule<T>(filePath: string): Promise<T> {\n   120→  const absolutePath = resolve(process.cwd(), filePath);\n   121→\n   122→  if (filePath.endsWith('.json')) {\n   123→    const file = Bun.file(absolutePath);\n   124→    return (await file.json()) as T;\n   125→  }\n   126→\n   127→  const module = await import(absolutePath);\n   128→  return module.default ?? module;\n   129→}\n   130→\n   131→async function main(): Promise<void> {\n   132→  const { values, positionals } = parseArgs({\n   133→    args: Bun.argv.slice(2),\n   134→    options: {\n   135→      help: { type: 'boolean', short: 'h' },\n   136→      'dry-run': { type: 'boolean' },\n   137→      timeout: { type: 'string', default: '5000' },\n   138→      verbose: { type: 'boolean' },\n   139→    },\n   140→    allowPositionals: true,\n   141→  });\n   142→\n   143→  if (values.help) {\n   144→    printUsage();\n   145→    process.exit(0);\n   146→  }\n   147→\n   148→  if (positionals.length < 2) {\n   149→    logError('Missing required arguments');\n   150→    printUsage();\n   151→    process.exit(1);\n   152→  }\n   153→\n   154→  const [configPath, eventPath] = positionals;\n   155→  const timeout = Number.parseInt(values.timeout ?? '5000', 10);\n   156→  const dryRun = values['dry-run'] ?? false;\n   157→  const verbose = values.verbose ?? false;\n   158→\n   159→  logSection('Loading Configuration');\n   160→\n   161→  // Load config file\n   162→  let config: ConfigExport;\n   163→  try {\n   164→    logInfo(`Loading config from: ${configPath}`);\n   165→    config = await loadModule<ConfigExport>(configPath);\n   166→\n   167→    if (!config.schema || typeof config.schema !== 'object') {\n   168→      throw new Error('Config must export a \"schema\" object');\n   169→    }\n   170→\n   171→    const eventCount = Object.keys(config.schema).length;\n   172→    const subscriberCount = Object.values(config.schema).reduce(\n   173→      (acc, entry) => {\n   174→        if (isSchemaEntryTuple(entry)) {\n   175→          return acc + entry[1].length;\n   176→        }\n   177→        return acc + entry.subscribers.length;\n   178→      },\n   179→      0,\n   180→    );\n   181→    logSuccess(\n   182→      `Loaded ${eventCount} event(s) and ${subscriberCount} subscriber(s)`,\n   183→    );\n   184→  } catch (err) {\n   185→    logError(\n   186→      `Failed to load config: ${err instanceof Error ? err.message : err}`,\n   187→    );\n   188→    process.exit(1);\n   189→  }\n   190→\n   191→  // Load event file\n   192→  let eventSpec: EventExport;\n   193→  try {\n   194→    logInfo(`Loading event from: ${eventPath}`);\n   195→    eventSpec = await loadModule<EventExport>(eventPath);\n   196→\n   197→    if (!eventSpec.eventKey || typeof eventSpec.eventKey !== 'string') {\n   198→      throw new Error('Event file must export an \"eventKey\" string');\n   199→    }\n   200→    if (eventSpec.data === undefined) {\n   201→      throw new Error('Event file must export a \"data\" property');\n   202→    }\n   203→\n   204→    logSuccess(`Event key: ${eventSpec.eventKey}`);\n   205→  } catch (err) {\n   206→    logError(\n   207→      `Failed to load event: ${err instanceof Error ? err.message : err}`,\n   208→    );\n   209→    process.exit(1);\n   210→  }\n   211→\n   212→  // Validate event exists in config\n   213→  const schemaEntry = config.schema[eventSpec.eventKey];\n   214→  if (!schemaEntry) {\n   215→    logError(`Event \"${eventSpec.eventKey}\" not found in config`);\n   216→    logInfo(`Available events: ${Object.keys(config.schema).join(', ')}`);\n   217→    process.exit(1);\n   218→  }\n   219→\n   220→  // Extract EventClass and subscribers from schema entry\n   221→  const EventClass = isSchemaEntryTuple(schemaEntry)\n   222→    ? schemaEntry[0]\n   223→    : schemaEntry.eventClass;\n   224→  const subscribers = isSchemaEntryTuple(schemaEntry)\n   225→    ? schemaEntry[1]\n   226→    : schemaEntry.subscribers;\n   227→\n   228→  if (!subscribers || subscribers.length === 0) {\n   229→    logWarning(`No subscribers registered for event \"${eventSpec.eventKey}\"`);\n   230→  } else {\n   231→    logInfo(`Subscribers: ${subscribers.map((s) => s.name).join(', ')}`);\n   232→  }\n   233→\n   234→  if (dryRun) {\n   235→    logSection('Dry Run Complete');\n   236→    logSuccess('Config and event validated successfully');\n   237→    logInfo('Use without --dry-run to actually dispatch the event');\n   238→    process.exit(0);\n   239→  }\n   240→\n   241→  logSection('Dispatching Event');\n   242→\n   243→  // Create topology\n   244→  const topology =\n   245→    config.topology ??\n   246→    TopologyBuilder.create()\n   247→      .withNamespace('cli-test')\n   248→      .addQueue('events')\n   249→      .withoutDeadLetter()\n   250→      .build();\n   251→\n   252→  // Create transport\n   253→  const transport = new LocalTransport();\n   254→\n   255→  // Create hooks for logging\n   256→  const hooks: MatadorHooks = {\n   257→    logger: verbose ? consoleLogger : undefined,\n   258→    onWorkerSuccess: (ctx) => {\n   259→      logSuccess(`[${ctx.subscriber.name}] processed in ${ctx.durationMs}ms`);\n   260→    },\n   261→    onWorkerError: (ctx) => {\n   262→      logError(\n   263→        `[${ctx.subscriber.name}] failed after ${ctx.durationMs}ms: ${ctx.error.message}`,\n   264→      );\n   265→    },\n   266→    ...config.hooks,\n   267→  };\n   268→\n   269→  // Create Matador instance with schema and hooks\n   270→  const matador = new Matador(\n   271→    {\n   272→      transport,\n   273→      topology,\n   274→      schema: config.schema,\n   275→      consumeFrom: topology.queues.map((q) => q.name),\n   276→    },\n   277→    hooks,\n   278→  );\n   279→\n   280→  try {\n   281→    await matador.start();\n   282→    logSuccess('Matador started');\n   283→\n   284→    // Create and dispatch the event\n   285→    const event = new EventClass(eventSpec.data, eventSpec.before);\n   286→    logInfo(`Dispatching: ${eventSpec.eventKey}`);\n   287→\n   288→    if (verbose) {\n   289→      logInfo(`Data: ${JSON.stringify(eventSpec.data, null, 2)}`);\n   290→      if (eventSpec.before) {\n   291→        logInfo(`Before: ${JSON.stringify(eventSpec.before, null, 2)}`);\n   292→      }\n   293→      if (eventSpec.options) {\n   294→        logInfo(`Options: ${JSON.stringify(eventSpec.options, null, 2)}`);\n   295→      }\n   296→    }\n   297→\n   298→    const result = await matador.send(event, eventSpec.options);\n   299→\n   300→    logSection('Send Result');\n   301→    logInfo(`Event key: ${result.eventKey}`);\n   302→    logInfo(`Subscribers sent: ${result.subscribersSent}`);\n   303→    logInfo(`Subscribers skipped: ${result.subscribersSkipped}`);\n   304→\n   305→    if (result.errors.length > 0) {\n   306→      logWarning(`Dispatch errors: ${result.errors.length}`);\n   307→      for (const err of result.errors) {\n   308→        logError(`  [${err.subscriberName}] ${err.error.message}`);\n   309→      }\n   310→    }\n   311→\n   312→    // Wait for processing\n   313→    logSection('Processing');\n   314→    const idle = await matador.waitForIdle(timeout);\n   315→\n   316→    if (idle) {\n   317→      logSuccess('All subscribers finished processing');\n   318→    } else {\n   319→      logWarning(`Timed out after ${timeout}ms waiting for processing`);\n   320→    }\n   321→\n   322→    await matador.shutdown();\n   323→    logSuccess('Matador shutdown complete');\n   324→\n   325→    logSection('Summary');\n   326→    if (result.errors.length === 0 && idle) {\n   327→      logSuccess('Event dispatched and processed successfully!');\n   328→      process.exit(0);\n   329→    } else {\n   330→      logWarning('Event dispatched with issues');\n   331→      process.exit(1);\n   332→    }\n   333→  } catch (err) {\n   334→    logError(`Error: ${err instanceof Error ? err.message : err}`);\n   335→    await matador.shutdown().catch(() => {});\n   336→    process.exit(1);\n   337→  }\n   338→}\n   339→\n   340→main();\n   341→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T15:38:08.790Z"
        },
        {
          "type": "user",
          "text": "     1→import type { SubscriberContext } from '../checkpoint/index.js';\n     2→import type { Idempotency, Importance } from './common.js';\n     3→import type { Envelope } from './envelope.js';\n     4→import type { MatadorEvent } from './event.js';\n     5→\n     6→/**\n     7→ * Helper type to get the envelope type for a subscriber callback.\n     8→ * Extracts the data type from a MatadorEvent and wraps it in an Envelope.\n     9→ *\n    10→ * @example\n    11→ * async callback(envelope: EnvelopeOf<MyEvent>) {\n    12→ *   console.log(envelope.data.someField); // Type-safe access\n    13→ * }\n    14→ */\n    15→export type EnvelopeOf<T extends MatadorEvent> = Envelope<T['data']>;\n    16→\n    17→/**\n    18→ * Callback function executed when an event is received (standard subscribers).\n    19→ * Receives the full envelope containing id, data, and docket.\n    20→ */\n    21→export type StandardCallback<T = unknown> = (\n    22→  envelope: Envelope<T>,\n    23→) => Promise<void> | void;\n    24→\n    25→/**\n    26→ * Callback function for resumable subscribers.\n    27→ * Receives the envelope and a SubscriberContext with io() for checkpointed operations.\n    28→ */\n    29→export type ResumableCallback<T = unknown> = (\n    30→  envelope: Envelope<T>,\n    31→  context: SubscriberContext,\n    32→) => Promise<void> | void;\n    33→\n    34→/**\n    35→ * Callback function executed when an event is received.\n    36→ * @deprecated Use StandardCallback or ResumableCallback instead.\n    37→ */\n    38→export type SubscriberCallback<T = unknown> = StandardCallback<T>;\n    39→\n    40→/**\n    41→ * Base configuration options shared by all subscriber types.\n    42→ */\n    43→export interface BaseSubscriberOptions {\n    44→  /** Route this subscriber's events to a specific queue */\n    45→  readonly targetQueue?: string | undefined;\n    46→\n    47→  /** Importance level for monitoring and alerting */\n    48→  readonly importance?: Importance | undefined;\n    49→\n    50→  /** Feature flag function to conditionally enable/disable the subscriber */\n    51→  readonly enabled?: (() => boolean | Promise<boolean>) | undefined;\n    52→}\n    53→\n    54→/**\n    55→ * Options for standard (non-resumable) subscribers.\n    56→ */\n    57→export interface StandardSubscriberOptions extends BaseSubscriberOptions {\n    58→  /** Idempotency declaration for retry handling (non-resumable) */\n    59→  readonly idempotent?: 'yes' | 'no' | 'unknown' | undefined;\n    60→}\n    61→\n    62→/**\n    63→ * Options for resumable subscribers that use io() for checkpointed operations.\n    64→ */\n    65→export interface ResumableSubscriberOptions extends BaseSubscriberOptions {\n    66→  /** Must be 'resumable' to enable checkpoint-based idempotency */\n    67→  readonly idempotent: 'resumable';\n    68→}\n    69→\n    70→/**\n    71→ * Configuration options for a subscriber.\n    72→ * Discriminated union based on idempotent value.\n    73→ */\n    74→export type SubscriberOptions =\n    75→  | StandardSubscriberOptions\n    76→  | ResumableSubscriberOptions;\n    77→\n    78→/**\n    79→ * Standard subscriber definition with standard callback.\n    80→ */\n    81→export interface StandardSubscriber<T extends MatadorEvent>\n    82→  extends StandardSubscriberOptions {\n    83→  /** Human-readable name for the subscriber */\n    84→  readonly name: string;\n    85→\n    86→  /** Callback function to execute when event is received */\n    87→  readonly callback: StandardCallback<T['data']>;\n    88→}\n    89→\n    90→/**\n    91→ * Resumable subscriber definition with resumable callback.\n    92→ */\n    93→export interface ResumableSubscriber<T extends MatadorEvent>\n    94→  extends ResumableSubscriberOptions {\n    95→  /** Human-readable name for the subscriber */\n    96→  readonly name: string;\n    97→\n    98→  /** Callback function with SubscriberContext for checkpointed operations */\n    99→  readonly callback: ResumableCallback<T['data']>;\n   100→}\n   101→\n   102→/**\n   103→ * Full subscriber definition with callback (either standard or resumable).\n   104→ */\n   105→export type Subscriber<T extends MatadorEvent> =\n   106→  | StandardSubscriber<T>\n   107→  | ResumableSubscriber<T>;\n   108→\n   109→/**\n   110→ * Subscriber stub for multi-codebase scenarios where subscriber implementation\n   111→ * is in a remote service. Declares the subscriber contract without providing\n   112→ * the callback.\n   113→ */\n   114→export interface SubscriberStub extends StandardSubscriberOptions {\n   115→  /** Human-readable name for the subscriber */\n   116→  readonly name: string;\n   117→\n   118→  /** Indicates this is a stub without implementation */\n   119→  readonly isStub: true;\n   120→}\n   121→\n   122→/**\n   123→ * Union type for any subscriber definition (full or stub).\n   124→ * This is the type-erased version for use in collections and schema.\n   125→ * Uses `any` because Subscriber<T> is contravariant in T (callback parameter),\n   126→ * making it impossible to assign Subscriber<SpecificEvent> to Subscriber<MatadorEvent<unknown>>.\n   127→ */\n   128→// biome-ignore lint/suspicious/noExplicitAny: Required for variance compatibility in heterogeneous collections\n   129→export type AnySubscriber = Subscriber<MatadorEvent<any>> | SubscriberStub;\n   130→\n   131→/**\n   132→ * Type guard to check if a subscriber is a stub.\n   133→ */\n   134→export function isSubscriberStub(\n   135→  subscriber: AnySubscriber,\n   136→): subscriber is SubscriberStub {\n   137→  return 'isStub' in subscriber && subscriber.isStub === true;\n   138→}\n   139→\n   140→/**\n   141→ * Type guard to check if a subscriber has a callback implementation.\n   142→ */\n   143→export function isSubscriber(\n   144→  subscriber: AnySubscriber,\n   145→  // biome-ignore lint/suspicious/noExplicitAny: Required for variance compatibility\n   146→): subscriber is Subscriber<MatadorEvent<any>> {\n   147→  return 'callback' in subscriber && typeof subscriber.callback === 'function';\n   148→}\n   149→\n   150→/**\n   151→ * Type guard to check if a subscriber is resumable.\n   152→ */\n   153→export function isResumableSubscriber(\n   154→  subscriber: AnySubscriber,\n   155→  // biome-ignore lint/suspicious/noExplicitAny: Required for variance compatibility\n   156→): subscriber is ResumableSubscriber<MatadorEvent<any>> {\n   157→  return isSubscriber(subscriber) && subscriber.idempotent === 'resumable';\n   158→}\n   159→\n   160→/**\n   161→ * Type guard to check if a subscriber is a standard (non-resumable) subscriber.\n   162→ */\n   163→export function isStandardSubscriber(\n   164→  subscriber: AnySubscriber,\n   165→  // biome-ignore lint/suspicious/noExplicitAny: Required for variance compatibility\n   166→): subscriber is StandardSubscriber<MatadorEvent<any>> {\n   167→  return isSubscriber(subscriber) && subscriber.idempotent !== 'resumable';\n   168→}\n   169→\n   170→/**\n   171→ * Input options for createSubscriber with standard callback.\n   172→ */\n   173→export interface CreateStandardSubscriberInput<T extends MatadorEvent> {\n   174→  readonly name: string;\n   175→  readonly callback: StandardCallback<T['data']>;\n   176→  readonly idempotent?: 'yes' | 'no' | 'unknown' | undefined;\n   177→  readonly importance?: Importance | undefined;\n   178→  readonly targetQueue?: string | undefined;\n   179→  readonly enabled?: (() => boolean | Promise<boolean>) | undefined;\n   180→}\n   181→\n   182→/**\n   183→ * Input options for createSubscriber with resumable callback.\n   184→ */\n   185→export interface CreateResumableSubscriberInput<T extends MatadorEvent> {\n   186→  readonly name: string;\n   187→  readonly callback: ResumableCallback<T['data']>;\n   188→  readonly idempotent: 'resumable';\n   189→  readonly importance?: Importance | undefined;\n   190→  readonly targetQueue?: string | undefined;\n   191→  readonly enabled?: (() => boolean | Promise<boolean>) | undefined;\n   192→}\n   193→\n   194→/**\n   195→ * Input options for createSubscriber (discriminated union).\n   196→ */\n   197→export type CreateSubscriberInput<T extends MatadorEvent> =\n   198→  | CreateStandardSubscriberInput<T>\n   199→  | CreateResumableSubscriberInput<T>;\n   200→\n   201→/**\n   202→ * Creates a subscriber definition.\n   203→ *\n   204→ * @example Standard subscriber (new API)\n   205→ * ```typescript\n   206→ * const subscriber = createSubscriber<MyEvent>({\n   207→ *   name: 'my-subscriber',\n   208→ *   callback: async (envelope) => {\n   209→ *     console.log(envelope.data);\n   210→ *   },\n   211→ * });\n   212→ * ```\n   213→ *\n   214→ * @example Standard subscriber (legacy API)\n   215→ * ```typescript\n   216→ * const subscriber = createSubscriber<MyEvent>(\n   217→ *   'my-subscriber',\n   218→ *   async (envelope) => console.log(envelope.data),\n   219→ *   { idempotent: 'yes' },\n   220→ * );\n   221→ * ```\n   222→ *\n   223→ * @example Resumable subscriber with io()\n   224→ * ```typescript\n   225→ * const subscriber = createSubscriber<MyEvent>({\n   226→ *   name: 'my-resumable-subscriber',\n   227→ *   idempotent: 'resumable',\n   228→ *   callback: async (envelope, { io }) => {\n   229→ *     await io('step-1', () => doSomething());\n   230→ *   },\n   231→ * });\n   232→ * ```\n   233→ */\n   234→export function createSubscriber<T extends MatadorEvent>(\n   235→  input: CreateSubscriberInput<T>,\n   236→): Subscriber<T>;\n   237→\n   238→/**\n   239→ * @deprecated Use object-based API instead: createSubscriber({ name, callback, ...options })\n   240→ */\n   241→export function createSubscriber<T extends MatadorEvent>(\n   242→  name: string,\n   243→  callback: StandardCallback<T['data']>,\n   244→  options?: StandardSubscriberOptions,\n   245→): StandardSubscriber<T>;\n   246→\n   247→export function createSubscriber<T extends MatadorEvent>(\n   248→  inputOrName: CreateSubscriberInput<T> | string,\n   249→  callback?: StandardCallback<T['data']>,\n   250→  options?: StandardSubscriberOptions,\n   251→): Subscriber<T> {\n   252→  // Legacy API: createSubscriber(name, callback, options)\n   253→  if (typeof inputOrName === 'string') {\n   254→    const opts = options ?? {};\n   255→    return {\n   256→      name: inputOrName,\n   257→      callback: callback!,\n   258→      idempotent: opts.idempotent ?? 'unknown',\n   259→      importance: opts.importance ?? 'should-investigate',\n   260→      ...(opts.targetQueue !== undefined && {\n   261→        targetQueue: opts.targetQueue,\n   262→      }),\n   263→      ...(opts.enabled !== undefined && { enabled: opts.enabled }),\n   264→    } as StandardSubscriber<T>;\n   265→  }\n   266→\n   267→  // New API: createSubscriber({ name, callback, ... })\n   268→  const input = inputOrName;\n   269→  const base = {\n   270→    name: input.name,\n   271→    callback: input.callback,\n   272→    importance: input.importance ?? 'should-investigate',\n   273→    ...(input.targetQueue !== undefined && {\n   274→      targetQueue: input.targetQueue,\n   275→    }),\n   276→    ...(input.enabled !== undefined && { enabled: input.enabled }),\n   277→  };\n   278→\n   279→  if (input.idempotent === 'resumable') {\n   280→    return {\n   281→      ...base,\n   282→      idempotent: 'resumable',\n   283→      callback: input.callback,\n   284→    } as ResumableSubscriber<T>;\n   285→  }\n   286→\n   287→  return {\n   288→    ...base,\n   289→    idempotent: input.idempotent ?? 'unknown',\n   290→    callback: input.callback,\n   291→  } as StandardSubscriber<T>;\n   292→}\n   293→\n   294→/**\n   295→ * Creates a subscriber stub for remote implementations.\n   296→ */\n   297→export function createSubscriberStub(\n   298→  name: string,\n   299→  options: StandardSubscriberOptions = {},\n   300→): SubscriberStub {\n   301→  return {\n   302→    name,\n   303→    isStub: true,\n   304→    idempotent: options.idempotent ?? 'unknown',\n   305→    importance: options.importance ?? 'should-investigate',\n   306→    ...(options.targetQueue !== undefined && {\n   307→      targetQueue: options.targetQueue,\n   308→    }),\n   309→    ...(options.enabled !== undefined && { enabled: options.enabled }),\n   310→  };\n   311→}\n   312→\n   313→/**\n   314→ * Definition interface used by the pipeline (excludes event class reference).\n   315→ */\n   316→export interface SubscriberDefinition {\n   317→  readonly name: string;\n   318→  readonly idempotent: Idempotency;\n   319→  readonly importance: Importance;\n   320→  readonly targetQueue?: string | undefined;\n   321→}\n   322→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T15:38:08.791Z"
        },
        {
          "type": "user",
          "text": "No files found",
          "timestamp": "2025-12-11T15:38:08.819Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/types/common.ts"
          },
          "timestamp": "2025-12-11T15:38:14.612Z"
        },
        {
          "type": "tool_use",
          "name": "Grep",
          "input": {
            "-C": 2,
            "glob": "*.ts",
            "output_mode": "content",
            "path": "/home/z/Desktop/work/matador/packages/matador/src",
            "pattern": "enabled"
          },
          "timestamp": "2025-12-11T15:38:15.607Z"
        },
        {
          "type": "user",
          "text": "     1→/**\n     2→ * Delivery semantics for message processing.\n     3→ * - 'at-least-once': Acknowledge after processing (may redeliver on failure)\n     4→ * - 'at-most-once': Acknowledge before processing (no redelivery, may lose messages)\n     5→ */\n     6→export type DeliveryMode = 'at-least-once' | 'at-most-once';\n     7→\n     8→/**\n     9→ * Importance level for subscribers, used for monitoring and alerting prioritization.\n    10→ */\n    11→export type Importance =\n    12→  | 'can-ignore'\n    13→  | 'should-investigate'\n    14→  | 'must-investigate';\n    15→\n    16→/**\n    17→ * Idempotency declaration for subscribers.\n    18→ * - 'yes': Safe to retry on failure (subscriber handles duplicates)\n    19→ * - 'no': Not safe to retry, may cause duplicate side effects\n    20→ * - 'unknown': Idempotency not determined (default)\n    21→ * - 'resumable': Uses checkpoint-based idempotency via io() calls\n    22→ */\n    23→export type Idempotency = 'yes' | 'no' | 'unknown' | 'resumable';\n    24→\n    25→/**\n    26→ * Result of a validation operation.\n    27→ */\n    28→export interface ValidationResult {\n    29→  readonly valid: boolean;\n    30→  readonly errors: readonly ValidationError[];\n    31→}\n    32→\n    33→/**\n    34→ * Individual validation error.\n    35→ */\n    36→export interface ValidationError {\n    37→  readonly path: string;\n    38→  readonly message: string;\n    39→}\n    40→\n    41→/**\n    42→ * Creates a successful validation result.\n    43→ */\n    44→export function validResult(): ValidationResult {\n    45→  return { valid: true, errors: [] };\n    46→}\n    47→\n    48→/**\n    49→ * Creates a failed validation result.\n    50→ */\n    51→export function invalidResult(errors: ValidationError[]): ValidationResult {\n    52→  return { valid: false, errors };\n    53→}\n    54→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T15:38:15.914Z"
        },
        {
          "type": "user",
          "text": "/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-126-        .addQueue('events')\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-127-        .withDeadLetter({\npackages/matador/src/topology/builder.test.ts:128:          unhandled: { enabled: false },\npackages/matador/src/topology/builder.test.ts:129:          undeliverable: { enabled: true },\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-130-        })\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-131-        .build();\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-132-\npackages/matador/src/topology/builder.test.ts:133:      expect(topology.deadLetter.unhandled.enabled).toBe(false);\npackages/matador/src/topology/builder.test.ts:134:      expect(topology.deadLetter.undeliverable.enabled).toBe(true);\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-135-    });\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-136-\n--\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-139-        .withNamespace('test')\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-140-        .addQueue('events')\npackages/matador/src/topology/builder.test.ts:141:        .withDeadLetter({ unhandled: { enabled: false } })\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-142-        .build();\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-143-\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-144-      // undeliverable should keep default\npackages/matador/src/topology/builder.test.ts:145:      expect(topology.deadLetter.unhandled.enabled).toBe(false);\npackages/matador/src/topology/builder.test.ts:146:      expect(topology.deadLetter.undeliverable.enabled).toBe(true);\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-147-    });\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-148-  });\n--\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-154-        .addQueue('events')\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-155-        .withRetry({\npackages/matador/src/topology/builder.test.ts:156:          enabled: true,\npackages/matador/src/topology/builder.test.ts-157-          defaultDelayMs: 5000,\npackages/matador/src/topology/builder.test.ts-158-          maxDelayMs: 600000,\n--\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-160-        .build();\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-161-\npackages/matador/src/topology/builder.test.ts:162:      expect(topology.retry.enabled).toBe(true);\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-163-      expect(topology.retry.defaultDelayMs).toBe(5000);\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-164-      expect(topology.retry.maxDelayMs).toBe(600000);\n--\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-197-        .build();\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-198-\npackages/matador/src/topology/builder.test.ts:199:      expect(topology.retry.enabled).toBe(false);\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-200-    });\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-201-  });\n--\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-209-        .build();\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-210-\npackages/matador/src/topology/builder.test.ts:211:      expect(topology.deadLetter.unhandled.enabled).toBe(false);\npackages/matador/src/topology/builder.test.ts:212:      expect(topology.deadLetter.undeliverable.enabled).toBe(false);\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-213-    });\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-214-  });\n--\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-258-      expect(topology.namespace).toBe('test');\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-259-      expect(topology.queues).toHaveLength(1);\npackages/matador/src/topology/builder.test.ts:260:      expect(topology.deadLetter.unhandled.enabled).toBe(true);\npackages/matador/src/topology/builder.test.ts:261:      expect(topology.retry.enabled).toBe(true);\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-262-    });\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.test.ts-263-  });\n--\n/home/z/Desktop/work/matador/packages/matador/src/topology/types.ts-57- */\n/home/z/Desktop/work/matador/packages/matador/src/topology/types.ts-58-export interface DeadLetterQueueConfig {\npackages/matador/src/topology/types.ts:59:  /** Whether this DLQ is enabled */\npackages/matador/src/topology/types.ts:60:  readonly enabled: boolean;\n/home/z/Desktop/work/matador/packages/matador/src/topology/types.ts-61-\n/home/z/Desktop/work/matador/packages/matador/src/topology/types.ts-62-  /** Maximum number of messages in the DLQ */\n--\n/home/z/Desktop/work/matador/packages/matador/src/topology/types.ts-69-export interface RetryConfig {\n/home/z/Desktop/work/matador/packages/matador/src/topology/types.ts-70-  /** Enable retry queue with delay */\npackages/matador/src/topology/types.ts:71:  readonly enabled: boolean;\n/home/z/Desktop/work/matador/packages/matador/src/topology/types.ts-72-\n/home/z/Desktop/work/matador/packages/matador/src/topology/types.ts-73-  /** Default retry delay in milliseconds */\n--\npackages/matador/src/topology/builder.ts-46-  private queues: QueueDefinition[] = [];\npackages/matador/src/topology/builder.ts-47-  private deadLetter: DeadLetterConfig = {\npackages/matador/src/topology/builder.ts:48:    unhandled: { enabled: true },\npackages/matador/src/topology/builder.ts:49:    undeliverable: { enabled: true },\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.ts-50-  };\npackages/matador/src/topology/builder.ts-51-  private retry: RetryConfig = {\npackages/matador/src/topology/builder.ts:52:    enabled: true,\npackages/matador/src/topology/builder.ts-53-    defaultDelayMs: 1000,\npackages/matador/src/topology/builder.ts-54-    maxDelayMs: 300000, // 5 minutes\n--\npackages/matador/src/topology/builder.ts-94-  withRetry(config: Partial<RetryConfig>): this {\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.ts-95-    this.retry = {\npackages/matador/src/topology/builder.ts:96:      enabled: config.enabled ?? this.retry.enabled,\npackages/matador/src/topology/builder.ts-97-      defaultDelayMs: config.defaultDelayMs ?? this.retry.defaultDelayMs,\npackages/matador/src/topology/builder.ts-98-      maxDelayMs: config.maxDelayMs ?? this.retry.maxDelayMs,\n--\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.ts-105-   */\npackages/matador/src/topology/builder.ts-106-  withoutRetry(): this {\npackages/matador/src/topology/builder.ts:107:    this.retry = { ...this.retry, enabled: false };\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.ts-108-    return this;\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.ts-109-  }\n--\npackages/matador/src/topology/builder.ts-114-  withoutDeadLetter(): this {\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.ts-115-    this.deadLetter = {\npackages/matador/src/topology/builder.ts:116:      unhandled: { enabled: false },\npackages/matador/src/topology/builder.ts:117:      undeliverable: { enabled: false },\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.ts-118-    };\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.ts-119-    return this;\n--\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.ts-163-    }\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.ts-164-\npackages/matador/src/topology/builder.ts:165:    if (this.retry.enabled) {\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.ts-166-      if (this.retry.defaultDelayMs < 0) {\n/home/z/Desktop/work/matador/packages/matador/src/topology/builder.ts-167-        issues.push('Default retry delay must be non-negative');\n--\n/home/z/Desktop/work/matador/packages/matador/src/types/subscriber.ts-49-\n/home/z/Desktop/work/matador/packages/matador/src/types/subscriber.ts-50-  /** Feature flag function to conditionally enable/disable the subscriber */\npackages/matador/src/types/subscriber.ts:51:  readonly enabled?: (() => boolean | Promise<boolean>) | undefined;\n/home/z/Desktop/work/matador/packages/matador/src/types/subscriber.ts-52-}\n/home/z/Desktop/work/matador/packages/matador/src/types/subscriber.ts-53-\n--\npackages/matador/src/types/subscriber.ts-177-  readonly importance?: Importance | undefined;\npackages/matador/src/types/subscriber.ts-178-  readonly targetQueue?: string | undefined;\npackages/matador/src/types/subscriber.ts:179:  readonly enabled?: (() => boolean | Promise<boolean>) | undefined;\n/home/z/Desktop/work/matador/packages/matador/src/types/subscriber.ts-180-}\n/home/z/Desktop/work/matador/packages/matador/src/types/subscriber.ts-181-\n--\npackages/matador/src/types/subscriber.ts-189-  readonly importance?: Importance | undefined;\npackages/matador/src/types/subscriber.ts-190-  readonly targetQueue?: string | undefined;\npackages/matador/src/types/subscriber.ts:191:  readonly enabled?: (() => boolean | Promise<boolean>) | undefined;\n/home/z/Desktop/work/matador/packages/matador/src/types/subscriber.ts-192-}\n/home/z/Desktop/work/matador/packages/matador/src/types/subscriber.ts-193-\n--\npackages/matador/src/types/subscriber.ts-261-        targetQueue: opts.targetQueue,\n/home/z/Desktop/work/matador/packages/matador/src/types/subscriber.ts-262-      }),\npackages/matador/src/types/subscriber.ts:263:      ...(opts.enabled !== undefined && { enabled: opts.enabled }),\n/home/z/Desktop/work/matador/packages/matador/src/types/subscriber.ts-264-    } as StandardSubscriber<T>;\n/home/z/Desktop/work/matador/packages/matador/src/types/subscriber.ts-265-  }\n--\npackages/matador/src/types/subscriber.ts-274-      targetQueue: input.targetQueue,\n/home/z/Desktop/work/matador/packages/matador/src/types/subscriber.ts-275-    }),\npackages/matador/src/types/subscriber.ts:276:    ...(input.enabled !== undefined && { enabled: input.enabled }),\n/home/z/Desktop/work/matador/packages/matador/src/types/subscriber.ts-277-  };\n/home/z/Desktop/work/matador/packages/matador/src/types/subscriber.ts-278-\n--\npackages/matador/src/types/subscriber.ts-307-      targetQueue: options.targetQueue,\n/home/z/Desktop/work/matador/packages/matador/src/types/subscriber.ts-308-    }),\npackages/matador/src/types/subscriber.ts:309:    ...(options.enabled !== undefined && { enabled: options.enabled }),\n/home/z/Desktop/work/matador/packages/matador/src/types/subscriber.ts-310-  };\n/home/z/Desktop/work/matador/packages/matador/src/types/subscriber.ts-311-}\n--\npackages/matador/src/core/fanout.ts-47- * Handles:\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.ts-48- * 1. Getting subscribers from schema\npackages/matador/src/core/fanout.ts:49: * 2. Filtering by enabled() hook\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.ts-50- * 3. Creating envelopes for each subscriber\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.ts-51- * 4. Sending to appropriate queues via transport\n--\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.ts-99-\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.ts-100-    for (const subscriber of subscribers) {\npackages/matador/src/core/fanout.ts:101:      // Check if subscriber is enabled\npackages/matador/src/core/fanout.ts:102:      const enabled = await this.isSubscriberEnabled(subscriber);\npackages/matador/src/core/fanout.ts:103:      if (!enabled) {\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.ts-104-        skipped++;\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.ts-105-        continue;\n--\npackages/matador/src/core/fanout.ts-170-    subscriber: AnySubscriber,\npackages/matador/src/core/fanout.ts-171-  ): Promise<boolean> {\npackages/matador/src/core/fanout.ts:172:    if (!subscriber.enabled) {\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.ts-173-      return true;\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.ts-174-    }\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.ts-175-\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.ts-176-    try {\npackages/matador/src/core/fanout.ts:177:      const result = await subscriber.enabled();\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.ts-178-      return result;\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.ts-179-    } catch {\npackages/matador/src/core/fanout.ts:180:      // If enabled check fails, consider it enabled\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.ts-181-      return true;\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.ts-182-    }\n--\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-420-\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-421-  describe('filtering disabled subscribers', () => {\npackages/matador/src/core/fanout.test.ts:422:    it('should send to enabled subscriber', async () => {\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-423-      const subscriber = createSubscriber('handle-user', async () => {}, {\npackages/matador/src/core/fanout.test.ts:424:        enabled: () => true,\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-425-      });\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-426-\n--\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-440-    it('should skip disabled subscriber', async () => {\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-441-      const subscriber = createSubscriber('handle-user', async () => {}, {\npackages/matador/src/core/fanout.test.ts:442:        enabled: () => false,\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-443-      });\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-444-\n--\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-458-\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-459-    it('should filter some subscribers and send to others', async () => {\npackages/matador/src/core/fanout.test.ts:460:      const sub1 = createSubscriber('enabled-sub', async () => {}, {\npackages/matador/src/core/fanout.test.ts:461:        enabled: () => true,\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-462-      });\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-463-      const sub2 = createSubscriber('disabled-sub', async () => {}, {\npackages/matador/src/core/fanout.test.ts:464:        enabled: () => false,\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-465-      });\npackages/matador/src/core/fanout.test.ts:466:      const sub3 = createSubscriber('always-enabled-sub', async () => {});\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-467-\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-468-      schema.register(UserCreatedEvent, [sub1, sub2, sub3]);\n--\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-480-    });\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-481-\npackages/matador/src/core/fanout.test.ts:482:    it('should support async enabled function', async () => {\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-483-      const subscriber = createSubscriber('handle-user', async () => {}, {\npackages/matador/src/core/fanout.test.ts:484:        enabled: async () => {\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-485-          await new Promise((resolve) => setTimeout(resolve, 10));\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-486-          return true;\n--\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-501-    });\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-502-\npackages/matador/src/core/fanout.test.ts:503:    it('should treat subscriber as enabled if enabled() throws error', async () => {\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-504-      const subscriber = createSubscriber('handle-user', async () => {}, {\npackages/matador/src/core/fanout.test.ts:505:        enabled: () => {\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-506-          throw new Error('Feature flag service down');\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-507-        },\n--\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-521-    });\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-522-\npackages/matador/src/core/fanout.test.ts:523:    it('should treat subscriber as enabled if no enabled hook provided', async () => {\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-524-      const subscriber = createSubscriber('handle-user', async () => {});\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-525-\n--\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-539-    it('should work with subscriber stubs', async () => {\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-540-      const stub = createSubscriberStub('remote-subscriber', {\npackages/matador/src/core/fanout.test.ts:541:        enabled: () => false,\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-542-      });\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-543-\n--\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-1003-\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-1004-      const subscriber = createSubscriber('handle-user', async () => {}, {\npackages/matador/src/core/fanout.test.ts:1005:        enabled: () => false,\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-1006-      });\n/home/z/Desktop/work/matador/packages/matador/src/core/fanout.test.ts-1007-\n--\npackages/matador/src/transport/rabbitmq/rabbitmq-transport.ts-141-    await channel.assertExchange(mainExchange, 'direct', { durable: true });\n/home/z/Desktop/work/matador/packages/matador/src/transport/rabbitmq/rabbitmq-transport.ts-142-\npackages/matador/src/transport/rabbitmq/rabbitmq-transport.ts:143:    // Create dead-letter exchange if DLQ is enabled\n/home/z/Desktop/work/matador/packages/matador/src/transport/rabbitmq/rabbitmq-transport.ts-144-    const dlxExchange = this.getDLXExchangeName(topology.namespace);\n/home/z/Desktop/work/matador/packages/matador/src/transport/rabbitmq/rabbitmq-transport.ts-145-    if (\npackages/matador/src/transport/rabbitmq/rabbitmq-transport.ts:146:      topology.deadLetter.unhandled.enabled ||\npackages/matador/src/transport/rabbitmq/rabbitmq-transport.ts:147:      topology.deadLetter.undeliverable.enabled\n/home/z/Desktop/work/matador/packages/matador/src/transport/rabbitmq/rabbitmq-transport.ts-148-    ) {\npackages/matador/src/transport/rabbitmq/rabbitmq-transport.ts-149-      await channel.assertExchange(dlxExchange, 'direct', { durable: true });\n--\n/home/z/Desktop/work/matador/packages/matador/src/transport/rabbitmq/rabbitmq-transport.ts-161-\n/home/z/Desktop/work/matador/packages/matador/src/transport/rabbitmq/rabbitmq-transport.ts-162-    // Create DLQs\npackages/matador/src/transport/rabbitmq/rabbitmq-transport.ts:163:    if (topology.deadLetter.unhandled.enabled) {\n/home/z/Desktop/work/matador/packages/matador/src/transport/rabbitmq/rabbitmq-transport.ts-164-      await this.assertDeadLetterQueues(channel, topology, 'unhandled');\n/home/z/Desktop/work/matador/packages/matador/src/transport/rabbitmq/rabbitmq-transport.ts-165-    }\n/home/z/Desktop/work/matador/packages/matador/src/transport/rabbitmq/rabbitmq-transport.ts-166-\npackages/matador/src/transport/rabbitmq/rabbitmq-transport.ts:167:    if (topology.deadLetter.undeliverable.enabled) {\n/home/z/Desktop/work/matador/packages/matador/src/transport/rabbitmq/rabbitmq-transport.ts-168-      await this.assertDeadLetterQueues(channel, topology, 'undeliverable');\n/home/z/Desktop/work/matador/packages/matador/src/transport/rabbitmq/rabbitmq-transport.ts-169-    }\n--\n/home/z/Desktop/work/matador/packages/matador/src/transport/rabbitmq/rabbitmq-transport.ts-603-    const dlxExchange = this.getDLXExchangeName(topology.namespace);\n/home/z/Desktop/work/matador/packages/matador/src/transport/rabbitmq/rabbitmq-transport.ts-604-    if (\npackages/matador/src/transport/rabbitmq/rabbitmq-transport.ts:605:      topology.deadLetter.unhandled.enabled ||\npackages/matador/src/transport/rabbitmq/rabbitmq-transport.ts:606:      topology.deadLetter.undeliverable.enabled\n/home/z/Desktop/work/matador/packages/matador/src/transport/rabbitmq/rabbitmq-transport.ts-607-    ) {\n/home/z/Desktop/work/matador/packages/matador/src/transport/rabbitmq/rabbitmq-transport.ts-608-      queueOptions.arguments['x-dead-letter-exchange'] = dlxExchange;\n--\n/home/z/Desktop/work/matador/packages/matador/src/transport/rabbitmq/rabbitmq-transport.ts-631-    }\n/home/z/Desktop/work/matador/packages/matador/src/transport/rabbitmq/rabbitmq-transport.ts-632-\npackages/matador/src/transport/rabbitmq/rabbitmq-transport.ts:633:    // Create retry queue if retry is enabled\npackages/matador/src/transport/rabbitmq/rabbitmq-transport.ts:634:    if (topology.retry.enabled) {\n/home/z/Desktop/work/matador/packages/matador/src/transport/rabbitmq/rabbitmq-transport.ts-635-      await this.assertRetryQueue(channel, topology, queueName);\n/home/z/Desktop/work/matador/packages/matador/src/transport/rabbitmq/rabbitmq-transport.ts-636-    }\n--\npackages/matador/src/transport/local/local-transport.test.ts-177-        queues: [{ name: 'events' }, { name: 'notifications' }],\npackages/matador/src/transport/local/local-transport.test.ts-178-        deadLetter: {\npackages/matador/src/transport/local/local-transport.test.ts:179:          unhandled: { enabled: true },\npackages/matador/src/transport/local/local-transport.test.ts:180:          undeliverable: { enabled: true },\n/home/z/Desktop/work/matador/packages/matador/src/transport/local/local-transport.test.ts-181-        },\npackages/matador/src/transport/local/local-transport.test.ts-182-        retry: {\npackages/matador/src/transport/local/local-transport.test.ts:183:          enabled: true,\npackages/matador/src/transport/local/local-transport.test.ts-184-          defaultDelayMs: 1000,\npackages/matador/src/transport/local/local-transport.test.ts-185-          maxDelayMs: 30000,\n--\npackages/matador/src/transport/multi/multi-transport.test.ts-84-        queues: [{ name: 'events' }],\npackages/matador/src/transport/multi/multi-transport.test.ts-85-        deadLetter: {\npackages/matador/src/transport/multi/multi-transport.test.ts:86:          unhandled: { enabled: true },\npackages/matador/src/transport/multi/multi-transport.test.ts:87:          undeliverable: { enabled: true },\n/home/z/Desktop/work/matador/packages/matador/src/transport/multi/multi-transport.test.ts-88-        },\npackages/matador/src/transport/multi/multi-transport.test.ts-89-        retry: {\npackages/matador/src/transport/multi/multi-transport.test.ts:90:          enabled: true,\npackages/matador/src/transport/multi/multi-transport.test.ts-91-          defaultDelayMs: 1000,\npackages/matador/src/transport/multi/multi-transport.test.ts-92-          maxDelayMs: 30000,\n--\n/home/z/Desktop/work/matador/packages/matador/src/transport/multi/multi-transport.ts-34-   * Ordered list of transports.\n/home/z/Desktop/work/matador/packages/matador/src/transport/multi/multi-transport.ts-35-   * First transport is primary, rest are used as fallbacks when primary fails\npackages/matador/src/transport/multi/multi-transport.ts:36:   * (if fallback is enabled), or can be explicitly selected via the getDesiredBackend hook.\n/home/z/Desktop/work/matador/packages/matador/src/transport/multi/multi-transport.ts-37-   */\npackages/matador/src/transport/multi/multi-transport.ts-38-  readonly transports: readonly Transport[];\n--\npackages/matador/src/transport/multi/multi-transport.ts-119-  readonly transports: readonly Transport[];\n/home/z/Desktop/work/matador/packages/matador/src/transport/multi/multi-transport.ts-120-\npackages/matador/src/transport/multi/multi-transport.ts:121:  /** Whether fallback to secondary transports is enabled. */\npackages/matador/src/transport/multi/multi-transport.ts-122-  readonly fallbackEnabled: boolean;\n/home/z/Desktop/work/matador/packages/matador/src/transport/multi/multi-transport.ts-123-",
          "timestamp": "2025-12-11T15:38:15.958Z"
        },
        {
          "type": "assistant",
          "text": "Now I have enough information to fix the TODOs. Let me read a few more files to gather remaining details:",
          "timestamp": "2025-12-11T15:38:19.594Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/core/fanout.ts"
          },
          "timestamp": "2025-12-11T15:38:20.274Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/topology/builder.ts"
          },
          "timestamp": "2025-12-11T15:38:20.749Z"
        },
        {
          "type": "user",
          "text": "     1→import { TransportSendError } from '../errors/index.js';\n     2→import type { SafeHooks } from '../hooks/index.js';\n     3→import type { SchemaRegistry } from '../schema/index.js';\n     4→import { getQualifiedQueueName } from '../topology/index.js';\n     5→import type { Transport } from '../transport/index.js';\n     6→import type {\n     7→  AnySubscriber,\n     8→  Event,\n     9→  EventClass,\n    10→  EventOptions,\n    11→} from '../types/index.js';\n    12→import { createEnvelope } from '../types/index.js';\n    13→\n    14→/**\n    15→ * Configuration for the fanout engine.\n    16→ */\n    17→export interface FanoutConfig {\n    18→  readonly transport: Transport;\n    19→  readonly schema: SchemaRegistry;\n    20→  readonly hooks: SafeHooks;\n    21→  readonly namespace: string;\n    22→  readonly defaultQueue: string;\n    23→}\n    24→\n    25→/**\n    26→ * Result of sending an event.\n    27→ */\n    28→export interface SendResult {\n    29→  readonly eventKey: string;\n    30→  readonly subscribersSent: number;\n    31→  readonly subscribersSkipped: number;\n    32→  readonly errors: readonly SendError[];\n    33→}\n    34→\n    35→/**\n    36→ * Error during send.\n    37→ */\n    38→export interface SendError {\n    39→  readonly subscriberName: string;\n    40→  readonly queue: string;\n    41→  readonly error: Error;\n    42→}\n    43→\n    44→/**\n    45→ * Engine for fanning out events to subscribers.\n    46→ *\n    47→ * Handles:\n    48→ * 1. Getting subscribers from schema\n    49→ * 2. Filtering by enabled() hook\n    50→ * 3. Creating envelopes for each subscriber\n    51→ * 4. Sending to appropriate queues via transport\n    52→ */\n    53→export class FanoutEngine {\n    54→  private readonly transport: Transport;\n    55→  private readonly schema: SchemaRegistry;\n    56→  private readonly hooks: SafeHooks;\n    57→  private readonly namespace: string;\n    58→  private readonly defaultQueue: string;\n    59→  private enqueuingCount = 0;\n    60→\n    61→  constructor(config: FanoutConfig) {\n    62→    this.transport = config.transport;\n    63→    this.schema = config.schema;\n    64→    this.hooks = config.hooks;\n    65→    this.namespace = config.namespace;\n    66→    this.defaultQueue = config.defaultQueue;\n    67→  }\n    68→\n    69→  /**\n    70→   * Current count of events being enqueued.\n    71→   */\n    72→  get eventsBeingEnqueuedCount(): number {\n    73→    return this.enqueuingCount;\n    74→  }\n    75→\n    76→  /**\n    77→   * Sends an event to all registered subscribers.\n    78→   */\n    79→  async send<T>(\n    80→    eventClass: EventClass<T>,\n    81→    event: Event<T>,\n    82→    options: EventOptions = {},\n    83→  ): Promise<SendResult> {\n    84→    const eventKey = eventClass.key;\n    85→    const subscribers = this.schema.getSubscribers(eventKey);\n    86→\n    87→    const errors: SendError[] = [];\n    88→    let sent = 0;\n    89→    let skipped = 0;\n    90→\n    91→    // Load universal metadata\n    92→    const universalMetadata = await this.hooks.loadUniversalMetadata();\n    93→\n    94→    // Merge event.metadata with options.metadata (options takes precedence)\n    95→    const mergedMetadata =\n    96→      event.metadata || options.metadata\n    97→        ? { ...event.metadata, ...options.metadata }\n    98→        : undefined;\n    99→\n   100→    for (const subscriber of subscribers) {\n   101→      // Check if subscriber is enabled\n   102→      const enabled = await this.isSubscriberEnabled(subscriber);\n   103→      if (!enabled) {\n   104→        skipped++;\n   105→        continue;\n   106→      }\n   107→\n   108→      // Determine target queue\n   109→      const targetQueue = subscriber.targetQueue ?? this.defaultQueue;\n   110→      const qualifiedQueue = getQualifiedQueueName(this.namespace, targetQueue);\n   111→\n   112→      // Create envelope\n   113→      const envelope = createEnvelope({\n   114→        eventKey,\n   115→        eventDescription: eventClass.description,\n   116→        targetSubscriber: subscriber.name,\n   117→        data: event.data,\n   118→        importance: subscriber.importance ?? 'should-investigate',\n   119→        correlationId: options.correlationId,\n   120→        metadata: mergedMetadata,\n   121→        universalMetadata,\n   122→        delayMs: options.delayMs,\n   123→      });\n   124→\n   125→      // Send to transport\n   126→      this.enqueuingCount++;\n   127→      try {\n   128→        const usedTransport = await this.transport.send(\n   129→          qualifiedQueue,\n   130→          envelope,\n   131→          options.delayMs !== undefined\n   132→            ? { delay: options.delayMs }\n   133→            : undefined,\n   134→        );\n   135→        sent++;\n   136→\n   137→        await this.hooks.onEnqueueSuccess({\n   138→          envelope,\n   139→          queue: qualifiedQueue,\n   140→          transport: usedTransport,\n   141→        });\n   142→      } catch (error) {\n   143→        const cause = error instanceof Error ? error : new Error(String(error));\n   144→        const err = new TransportSendError(qualifiedQueue, cause);\n   145→        errors.push({\n   146→          subscriberName: subscriber.name,\n   147→          queue: qualifiedQueue,\n   148→          error: err,\n   149→        });\n   150→\n   151→        await this.hooks.onEnqueueError({\n   152→          envelope,\n   153→          error: err,\n   154→          transport: this.transport.name,\n   155→        });\n   156→      } finally {\n   157→        this.enqueuingCount--;\n   158→      }\n   159→    }\n   160→\n   161→    return {\n   162→      eventKey,\n   163→      subscribersSent: sent,\n   164→      subscribersSkipped: skipped,\n   165→      errors,\n   166→    };\n   167→  }\n   168→\n   169→  private async isSubscriberEnabled(\n   170→    subscriber: AnySubscriber,\n   171→  ): Promise<boolean> {\n   172→    if (!subscriber.enabled) {\n   173→      return true;\n   174→    }\n   175→\n   176→    try {\n   177→      const result = await subscriber.enabled();\n   178→      return result;\n   179→    } catch {\n   180→      // If enabled check fails, consider it enabled\n   181→      return true;\n   182→    }\n   183→  }\n   184→}\n   185→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T15:38:20.903Z"
        },
        {
          "type": "user",
          "text": "     1→import type { HasDescription } from '../errors/index.js';\n     2→import type {\n     3→  DeadLetterConfig,\n     4→  QueueDefinition,\n     5→  RetryConfig,\n     6→  Topology,\n     7→} from './types.js';\n     8→\n     9→/**\n    10→ * Options for adding a queue.\n    11→ * Excludes 'name' as that is provided as the first argument to addQueue.\n    12→ */\n    13→export type QueueOptions = Omit<QueueDefinition, 'name'>;\n    14→\n    15→/**\n    16→ * Error thrown when topology validation fails.\n    17→ */\n    18→export class TopologyValidationError extends Error implements HasDescription {\n    19→  readonly description =\n    20→    'The topology configuration is invalid. Check the issues array for ' +\n    21→    'specific validation failures such as missing namespace, invalid queue ' +\n    22→    'names, or conflicting settings. This error occurs during Matador ' +\n    23→    'initialization and must be fixed in the configuration.';\n    24→\n    25→  constructor(\n    26→    message: string,\n    27→    public readonly issues: readonly string[],\n    28→  ) {\n    29→    super(message);\n    30→    this.name = 'TopologyValidationError';\n    31→  }\n    32→}\n    33→\n    34→/**\n    35→ * Fluent builder for creating Topology configurations.\n    36→ */\n    37→export class TopologyBuilder {\n    38→  /**\n    39→   * Creates a new TopologyBuilder instance.\n    40→   */\n    41→  static create(): TopologyBuilder {\n    42→    return new TopologyBuilder();\n    43→  }\n    44→\n    45→  private namespace = '';\n    46→  private queues: QueueDefinition[] = [];\n    47→  private deadLetter: DeadLetterConfig = {\n    48→    unhandled: { enabled: true },\n    49→    undeliverable: { enabled: true },\n    50→  };\n    51→  private retry: RetryConfig = {\n    52→    enabled: true,\n    53→    defaultDelayMs: 1000,\n    54→    maxDelayMs: 300000, // 5 minutes\n    55→  };\n    56→\n    57→  /**\n    58→   * Sets the namespace prefix for all queues.\n    59→   */\n    60→  withNamespace(namespace: string): this {\n    61→    this.namespace = namespace;\n    62→    return this;\n    63→  }\n    64→\n    65→  /**\n    66→   * Adds a queue to the topology.\n    67→   */\n    68→  addQueue(name: string, options: QueueOptions = {}): this {\n    69→    this.queues.push({ name, ...options });\n    70→    return this;\n    71→  }\n    72→\n    73→  /**\n    74→   * Alias for addQueue().\n    75→   */\n    76→  queue(name: string, options: QueueOptions = {}): this {\n    77→    return this.addQueue(name, options);\n    78→  }\n    79→\n    80→  /**\n    81→   * Configures dead-letter queue settings.\n    82→   */\n    83→  withDeadLetter(config: Partial<DeadLetterConfig>): this {\n    84→    this.deadLetter = {\n    85→      unhandled: config.unhandled ?? this.deadLetter.unhandled,\n    86→      undeliverable: config.undeliverable ?? this.deadLetter.undeliverable,\n    87→    };\n    88→    return this;\n    89→  }\n    90→\n    91→  /**\n    92→   * Configures retry settings.\n    93→   */\n    94→  withRetry(config: Partial<RetryConfig>): this {\n    95→    this.retry = {\n    96→      enabled: config.enabled ?? this.retry.enabled,\n    97→      defaultDelayMs: config.defaultDelayMs ?? this.retry.defaultDelayMs,\n    98→      maxDelayMs: config.maxDelayMs ?? this.retry.maxDelayMs,\n    99→    };\n   100→    return this;\n   101→  }\n   102→\n   103→  /**\n   104→   * Disables retry functionality.\n   105→   */\n   106→  withoutRetry(): this {\n   107→    this.retry = { ...this.retry, enabled: false };\n   108→    return this;\n   109→  }\n   110→\n   111→  /**\n   112→   * Disables dead-letter queues.\n   113→   */\n   114→  withoutDeadLetter(): this {\n   115→    this.deadLetter = {\n   116→      unhandled: { enabled: false },\n   117→      undeliverable: { enabled: false },\n   118→    };\n   119→    return this;\n   120→  }\n   121→\n   122→  /**\n   123→   * Validates the topology configuration.\n   124→   */\n   125→  validate(): readonly string[] {\n   126→    const issues: string[] = [];\n   127→\n   128→    if (!this.namespace || this.namespace.trim() === '') {\n   129→      issues.push('Namespace is required');\n   130→    } else if (!/^[a-zA-Z][a-zA-Z0-9_-]*$/.test(this.namespace)) {\n   131→      issues.push(\n   132→        'Namespace must start with a letter and contain only alphanumeric characters, underscores, and hyphens',\n   133→      );\n   134→    }\n   135→\n   136→    if (this.queues.length === 0) {\n   137→      issues.push('At least one queue is required');\n   138→    }\n   139→\n   140→    const queueNames = new Set<string>();\n   141→    for (const queue of this.queues) {\n   142→      if (!queue.name || queue.name.trim() === '') {\n   143→        issues.push('Queue name cannot be empty');\n   144→      } else if (!/^[a-zA-Z][a-zA-Z0-9_-]*$/.test(queue.name)) {\n   145→        issues.push(\n   146→          `Queue name \"${queue.name}\" must start with a letter and contain only alphanumeric characters, underscores, and hyphens`,\n   147→        );\n   148→      } else if (queueNames.has(queue.name)) {\n   149→        issues.push(`Duplicate queue name: \"${queue.name}\"`);\n   150→      } else {\n   151→        queueNames.add(queue.name);\n   152→      }\n   153→\n   154→      if (queue.concurrency !== undefined && queue.concurrency < 1) {\n   155→        issues.push(`Queue \"${queue.name}\" concurrency must be at least 1`);\n   156→      }\n   157→\n   158→      if (queue.consumerTimeout !== undefined && queue.consumerTimeout < 0) {\n   159→        issues.push(\n   160→          `Queue \"${queue.name}\" consumer timeout must be non-negative`,\n   161→        );\n   162→      }\n   163→    }\n   164→\n   165→    if (this.retry.enabled) {\n   166→      if (this.retry.defaultDelayMs < 0) {\n   167→        issues.push('Default retry delay must be non-negative');\n   168→      }\n   169→      if (this.retry.maxDelayMs < this.retry.defaultDelayMs) {\n   170→        issues.push(\n   171→          'Max retry delay must be greater than or equal to default delay',\n   172→        );\n   173→      }\n   174→    }\n   175→\n   176→    return issues;\n   177→  }\n   178→\n   179→  /**\n   180→   * Builds the topology configuration.\n   181→   * @throws TopologyValidationError if validation fails\n   182→   */\n   183→  build(): Topology {\n   184→    const issues = this.validate();\n   185→    if (issues.length > 0) {\n   186→      throw new TopologyValidationError(\n   187→        `Invalid topology: ${issues.join('; ')}`,\n   188→        issues,\n   189→      );\n   190→    }\n   191→\n   192→    return {\n   193→      namespace: this.namespace,\n   194→      queues: [...this.queues],\n   195→      deadLetter: this.deadLetter,\n   196→      retry: this.retry,\n   197→    };\n   198→  }\n   199→}\n   200→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T15:38:20.904Z"
        },
        {
          "type": "assistant",
          "text": "Let me check how the unhandled queue TTL is configured and if schema plugins exist:",
          "timestamp": "2025-12-11T15:38:23.988Z"
        },
        {
          "type": "tool_use",
          "name": "Grep",
          "input": {
            "-C": 3,
            "-i": true,
            "output_mode": "content",
            "path": "/home/z/Desktop/work/matador/packages/matador/src",
            "pattern": "unhandled.*TTL|unhandled.*ttl|messageTtl"
          },
          "timestamp": "2025-12-11T15:38:25.887Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/schema/index.ts"
          },
          "timestamp": "2025-12-11T15:38:26.667Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/types/event.ts"
          },
          "timestamp": "2025-12-11T15:38:27.099Z"
        },
        {
          "type": "user",
          "text": "     1→export type {\n     2→  AnyEventClass,\n     3→  MatadorSchema,\n     4→  RegisterOptions,\n     5→  RuntimeSchemaEntry,\n     6→  RuntimeSchemaEntryTuple,\n     7→  SchemaEntry,\n     8→  SchemaEntryTuple,\n     9→  SchemaIssue,\n    10→  SchemaValidationResult,\n    11→} from './types.js';\n    12→\n    13→export { bind, isSchemaEntryTuple } from './types.js';\n    14→\n    15→export { SchemaError, SchemaRegistry } from './registry.js';\n    16→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T15:38:27.323Z"
        },
        {
          "type": "user",
          "text": "     1→/**\n     2→ * Unique event routing key type alias.\n     3→ */\n     4→export type EventKey = string;\n     5→\n     6→/**\n     7→ * JSON-serializable primitive types.\n     8→ */\n     9→export type JsonPrimitive = string | number | boolean | null;\n    10→\n    11→/**\n    12→ * JSON-serializable value (recursive type for objects and arrays).\n    13→ */\n    14→export type JsonValue =\n    15→  | JsonPrimitive\n    16→  | JsonValue[]\n    17→  | { [key: string]: JsonValue };\n    18→\n    19→/**\n    20→ * JSON-serializable record type for metadata.\n    21→ */\n    22→export type JsonRecord = Record<string, JsonValue>;\n    23→\n    24→/**\n    25→ * Static properties required on Event classes for schema registration.\n    26→ */\n    27→export interface EventStatic<T = unknown> {\n    28→  /** Unique routing key for the event */\n    29→  readonly key: string;\n    30→\n    31→  /** Human-readable description of the event */\n    32→  readonly description?: string;\n    33→\n    34→  /** Alternative names/keys for backwards compatibility */\n    35→  readonly aliases?: readonly string[];\n    36→\n    37→  /** Create an instance from data (for deserialization) */\n    38→  new (data: T): Event<T>;\n    39→}\n    40→\n    41→/**\n    42→ * Base interface for all events.\n    43→ * Events represent something that happened in the system.\n    44→ */\n    45→export interface Event<T = unknown> {\n    46→  /** The event data/payload */\n    47→  readonly data: T;\n    48→\n    49→  /** Event-specific metadata (merged with EventOptions metadata on dispatch) */\n    50→  readonly metadata?: JsonRecord | undefined;\n    51→}\n    52→\n    53→/**\n    54→ * Options for dispatching an event.\n    55→ */\n    56→export interface EventOptions {\n    57→  /** Delay processing by this many milliseconds */\n    58→  readonly delayMs?: number | undefined;\n    59→\n    60→  /** Correlation ID for request tracing */\n    61→  readonly correlationId?: string | undefined;\n    62→\n    63→  /**\n    64→   * Event-specific metadata to include in the docket.\n    65→   * This metadata will be merged with:\n    66→   * 1. Event instance metadata (if defined on the event)\n    67→   * 2. Universal metadata from the loadUniversalMetadata hook\n    68→   * With EventOptions metadata taking precedence over event metadata,\n    69→   * and both taking precedence over universal metadata.\n    70→   */\n    71→  readonly metadata?: JsonRecord | undefined;\n    72→}\n    73→\n    74→/**\n    75→ * Abstract base class for creating Matador events.\n    76→ * Extend this class to define custom events.\n    77→ *\n    78→ * @example\n    79→ * ```typescript\n    80→ * class UserCreatedEvent extends MatadorEvent {\n    81→ *   static readonly key = 'user.created'\n    82→ *   static readonly description = 'Fired when a new user is created'\n    83→ *\n    84→ *   constructor(\n    85→ *     public data: { userId: string; email: string },\n    86→ *     public metadata?: JsonRecord,\n    87→ *   ) {\n    88→ *     super()\n    89→ *   }\n    90→ * }\n    91→ * ```\n    92→ */\n    93→export abstract class MatadorEvent<T = unknown> implements Event<T> {\n    94→  static readonly key: string;\n    95→  static readonly description?: string;\n    96→  static readonly aliases?: readonly string[];\n    97→\n    98→  /** The event data/payload - must be defined by subclass */\n    99→  abstract readonly data: T;\n   100→\n   101→  /** Event-specific metadata */\n   102→  readonly metadata?: JsonRecord | undefined;\n   103→}\n   104→\n   105→/**\n   106→ * Type helper to extract the data type from an event class.\n   107→ */\n   108→export type EventData<E extends Event<unknown>> = E extends Event<infer T>\n   109→  ? T\n   110→  : never;\n   111→\n   112→/**\n   113→ * Type helper to get the event class type.\n   114→ */\n   115→export type EventClass<T = unknown> = EventStatic<T> &\n   116→  (new (\n   117→    data: T,\n   118→  ) => Event<T>);\n   119→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T15:38:27.324Z"
        },
        {
          "type": "user",
          "text": "No matches found",
          "timestamp": "2025-12-11T15:38:27.353Z"
        },
        {
          "type": "tool_use",
          "name": "Grep",
          "input": {
            "-C": 3,
            "output_mode": "content",
            "path": "/home/z/Desktop/work/matador/packages/matador/src/transport",
            "pattern": "x-message-ttl|TTL|ttl"
          },
          "timestamp": "2025-12-11T15:38:32.601Z"
        },
        {
          "type": "user",
          "text": "/home/z/Desktop/work/matador/packages/matador/src/transport/capabilities.ts-15-  /**\n/home/z/Desktop/work/matador/packages/matador/src/transport/capabilities.ts-16-   * Transport can delay message delivery natively.\npackages/matador/src/transport/capabilities.ts-17-   * - true: Use transport's native delay (BullMQ, RabbitMQ with plugin)\npackages/matador/src/transport/capabilities.ts:18:   * - false: Matador handles via retry queue with TTL or external scheduler\n/home/z/Desktop/work/matador/packages/matador/src/transport/capabilities.ts-19-   */\npackages/matador/src/transport/capabilities.ts-20-  readonly delayedMessages: boolean;\n/home/z/Desktop/work/matador/packages/matador/src/transport/capabilities.ts-21-\n--\npackages/matador/src/transport/rabbitmq/rabbitmq-transport.ts-649-      arguments: {\npackages/matador/src/transport/rabbitmq/rabbitmq-transport.ts-650-        'x-dead-letter-exchange': mainExchange,\npackages/matador/src/transport/rabbitmq/rabbitmq-transport.ts-651-        'x-dead-letter-routing-key': workQueueName,\npackages/matador/src/transport/rabbitmq/rabbitmq-transport.ts:652:        'x-message-ttl': topology.retry.defaultDelayMs,\n/home/z/Desktop/work/matador/packages/matador/src/transport/rabbitmq/rabbitmq-transport.ts-653-      } as Record<string, unknown>,\n/home/z/Desktop/work/matador/packages/matador/src/transport/rabbitmq/rabbitmq-transport.ts-654-    };\n/home/z/Desktop/work/matador/packages/matador/src/transport/rabbitmq/rabbitmq-transport.ts-655-",
          "timestamp": "2025-12-11T15:38:32.924Z"
        },
        {
          "type": "assistant",
          "text": "Now let me check the pipeline for unhandled event handling:",
          "timestamp": "2025-12-11T15:38:36.696Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/pipeline/pipeline.ts"
          },
          "timestamp": "2025-12-11T15:38:37.279Z"
        },
        {
          "type": "user",
          "text": "     1→import type { Checkpoint, CheckpointStore } from '../checkpoint/index.js';\n     2→import { NoOpCheckpointStore, ResumableContext } from '../checkpoint/index.js';\n     3→import type { Codec } from '../codec/index.js';\n     4→import { CodecDecodeError } from '../codec/index.js';\n     5→import {\n     6→  SubscriberIsStubError,\n     7→  SubscriberNotRegisteredError,\n     8→} from '../errors/index.js';\n     9→import type { SafeHooks } from '../hooks/index.js';\n    10→import type { RetryDecision, RetryPolicy } from '../retry/index.js';\n    11→import type { SchemaRegistry } from '../schema/index.js';\n    12→import type { MessageReceipt, Transport } from '../transport/index.js';\n    13→import type { Envelope, SubscriberDefinition } from '../types/index.js';\n    14→import { isResumableSubscriber } from '../types/index.js';\n    15→\n    16→/**\n    17→ * Configuration for the processing pipeline.\n    18→ */\n    19→export interface PipelineConfig {\n    20→  readonly transport: Transport;\n    21→  readonly schema: SchemaRegistry;\n    22→  readonly codec: Codec;\n    23→  readonly retryPolicy: RetryPolicy;\n    24→  readonly hooks: SafeHooks;\n    25→  /** Optional checkpoint store for resumable subscribers */\n    26→  readonly checkpointStore?: CheckpointStore | undefined;\n    27→}\n    28→\n    29→/**\n    30→ * Result of pipeline processing.\n    31→ */\n    32→export interface ProcessResult {\n    33→  readonly success: boolean;\n    34→  readonly envelope?: Envelope | undefined;\n    35→  readonly subscriber?: SubscriberDefinition | undefined;\n    36→  readonly error?: Error | undefined;\n    37→  readonly decision?: RetryDecision | undefined;\n    38→  readonly durationMs: number;\n    39→}\n    40→\n    41→/**\n    42→ * Processing pipeline for incoming messages.\n    43→ *\n    44→ * Handles the complete message lifecycle:\n    45→ * 1. Decode envelope from raw bytes\n    46→ * 2. Lookup subscriber from schema\n    47→ * 3. Execute subscriber callback with hooks\n    48→ * 4. Handle success/failure with retry policy\n    49→ */\n    50→export class ProcessingPipeline {\n    51→  private readonly transport: Transport;\n    52→  private readonly schema: SchemaRegistry;\n    53→  private readonly codec: Codec;\n    54→  private readonly retryPolicy: RetryPolicy;\n    55→  private readonly hooks: SafeHooks;\n    56→  private readonly checkpointStore: CheckpointStore;\n    57→\n    58→  constructor(config: PipelineConfig) {\n    59→    this.transport = config.transport;\n    60→    this.schema = config.schema;\n    61→    this.codec = config.codec;\n    62→    this.retryPolicy = config.retryPolicy;\n    63→    this.hooks = config.hooks;\n    64→    this.checkpointStore = config.checkpointStore ?? new NoOpCheckpointStore();\n    65→  }\n    66→\n    67→  /**\n    68→   * Processes a raw message from the transport.\n    69→   */\n    70→  async process(\n    71→    rawMessage: Uint8Array,\n    72→    receipt: MessageReceipt,\n    73→  ): Promise<ProcessResult> {\n    74→    const startTime = performance.now();\n    75→\n    76→    // 1. Decode envelope\n    77→    let envelope: Envelope;\n    78→    try {\n    79→      envelope = this.codec.decode(rawMessage);\n    80→    } catch (error) {\n    81→      const decodeError =\n    82→        error instanceof CodecDecodeError\n    83→          ? error\n    84→          : new CodecDecodeError('Unknown decode error', error);\n    85→\n    86→      await this.transport.complete(receipt);\n    87→      await this.hooks.onDecodeError({\n    88→        error: decodeError,\n    89→        rawMessage,\n    90→        sourceQueue: receipt.sourceQueue,\n    91→        transport: receipt.sourceTransport,\n    92→      });\n    93→\n    94→      return {\n    95→        success: false,\n    96→        error: decodeError,\n    97→        durationMs: performance.now() - startTime,\n    98→      };\n    99→    }\n   100→\n   101→    // 2. Lookup subscriber from schema\n   102→    const subscriberDef = this.schema.getSubscriberDefinition(\n   103→      envelope.docket.eventKey,\n   104→      envelope.docket.targetSubscriber,\n   105→    );\n   106→\n   107→    if (!subscriberDef) {\n   108→      const error = new SubscriberNotRegisteredError(\n   109→        envelope.docket.targetSubscriber,\n   110→        envelope.docket.eventKey,\n   111→      );\n   112→      await this.sendToDeadLetter(\n   113→        receipt,\n   114→        envelope,\n   115→        'unhandled',\n   116→        error.message,\n   117→      );\n   118→\n   119→      return {\n   120→        success: false,\n   121→        envelope,\n   122→        error,\n   123→        durationMs: performance.now() - startTime,\n   124→      };\n   125→    }\n   126→\n   127→    // Get executable subscriber\n   128→    const subscriber = this.schema.getExecutableSubscriber(\n   129→      envelope.docket.eventKey,\n   130→      envelope.docket.targetSubscriber,\n   131→    );\n   132→\n   133→    if (!subscriber) {\n   134→      // Subscriber is a stub (remote implementation)\n   135→      const error = new SubscriberIsStubError(envelope.docket.targetSubscriber);\n   136→      await this.sendToDeadLetter(\n   137→        receipt,\n   138→        envelope,\n   139→        'unhandled',\n   140→        error.message,\n   141→      );\n   142→\n   143→      return {\n   144→        success: false,\n   145→        envelope,\n   146→        subscriber: subscriberDef,\n   147→        error,\n   148→        durationMs: performance.now() - startTime,\n   149→      };\n   150→    }\n   151→\n   152→    // 3. Execute subscriber callback with hooks\n   153→    let result: unknown;\n   154→    let error: Error | undefined;\n   155→    let context: ResumableContext | undefined;\n   156→\n   157→    // For resumable subscribers, load existing checkpoint and create context\n   158→    const isResumable = isResumableSubscriber(subscriber);\n   159→    let existingCheckpoint: Checkpoint | undefined;\n   160→\n   161→    if (isResumable) {\n   162→      existingCheckpoint = await this.checkpointStore.get(envelope.id);\n   163→\n   164→      if (existingCheckpoint) {\n   165→        await this.hooks.onCheckpointLoaded?.({\n   166→          envelope,\n   167→          subscriber: subscriberDef,\n   168→          checkpoint: existingCheckpoint,\n   169→          cachedSteps: Object.keys(existingCheckpoint.completedSteps).length,\n   170→        });\n   171→      }\n   172→\n   173→      context = new ResumableContext({\n   174→        store: this.checkpointStore,\n   175→        envelope,\n   176→        subscriber: subscriberDef,\n   177→        existingCheckpoint,\n   178→        hooks: {\n   179→          onCheckpointHit: (ctx) => this.hooks.onCheckpointHit?.(ctx),\n   180→          onCheckpointMiss: (ctx) => this.hooks.onCheckpointMiss?.(ctx),\n   181→        },\n   182→      });\n   183→    }\n   184→\n   185→    await this.hooks.onWorkerWrap(envelope, subscriberDef, async () => {\n   186→      await this.hooks.onWorkerBeforeProcess(envelope, subscriberDef);\n   187→\n   188→      try {\n   189→        if (isResumable && context) {\n   190→          // Resumable subscriber: pass context as second argument\n   191→          // Cast needed because TypeScript can't narrow the union type based on isResumable\n   192→          const resumableCallback = subscriber.callback as (\n   193→            envelope: Envelope,\n   194→            context: ResumableContext,\n   195→          ) => Promise<void> | void;\n   196→          result = await resumableCallback(envelope, context);\n   197→        } else {\n   198→          // Standard subscriber: just pass envelope\n   199→          const standardCallback = subscriber.callback as (\n   200→            envelope: Envelope,\n   201→          ) => Promise<void> | void;\n   202→          result = await standardCallback(envelope);\n   203→        }\n   204→      } catch (e) {\n   205→        error = e instanceof Error ? e : new Error(String(e));\n   206→      }\n   207→    });\n   208→\n   209→    const durationMs = performance.now() - startTime;\n   210→\n   211→    // 4. Handle success\n   212→    if (!error) {\n   213→      // Clear checkpoint on success for resumable subscribers\n   214→      if (context) {\n   215→        await context.clear();\n   216→        await this.hooks.onCheckpointCleared?.({\n   217→          envelope,\n   218→          subscriber: subscriberDef,\n   219→          reason: 'success',\n   220→        });\n   221→      }\n   222→\n   223→      await this.transport.complete(receipt);\n   224→      await this.hooks.onWorkerSuccess({\n   225→        envelope,\n   226→        subscriber: subscriberDef,\n   227→        result,\n   228→        durationMs,\n   229→        transport: receipt.sourceTransport,\n   230→      });\n   231→\n   232→      return {\n   233→        success: true,\n   234→        envelope,\n   235→        subscriber: subscriberDef,\n   236→        durationMs,\n   237→      };\n   238→    }\n   239→\n   240→    // 5. Handle failure - consult retry policy\n   241→    const decision = this.retryPolicy.shouldRetry({\n   242→      envelope,\n   243→      error,\n   244→      subscriber: subscriberDef,\n   245→      receipt,\n   246→    });\n   247→\n   248→    // Update envelope with error info\n   249→    envelope.docket.lastError = error.message;\n   250→    envelope.docket.firstError ??= error.message;\n   251→\n   252→    // Clear checkpoint on dead-letter (terminal state)\n   253→    if (decision.action === 'dead-letter' && context) {\n   254→      await context.clear();\n   255→      await this.hooks.onCheckpointCleared?.({\n   256→        envelope,\n   257→        subscriber: subscriberDef,\n   258→        reason: 'dead-letter',\n   259→      });\n   260→    }\n   261→\n   262→    await this.handleRetryDecision(receipt, envelope, decision);\n   263→\n   264→    await this.hooks.onWorkerError({\n   265→      envelope,\n   266→      subscriber: subscriberDef,\n   267→      error,\n   268→      durationMs,\n   269→      decision,\n   270→      transport: receipt.sourceTransport,\n   271→    });\n   272→\n   273→    return {\n   274→      success: false,\n   275→      envelope,\n   276→      subscriber: subscriberDef,\n   277→      error,\n   278→      decision,\n   279→      durationMs,\n   280→    };\n   281→  }\n   282→\n   283→  private async handleRetryDecision(\n   284→    receipt: MessageReceipt,\n   285→    envelope: Envelope,\n   286→    decision: RetryDecision,\n   287→  ): Promise<void> {\n   288→    switch (decision.action) {\n   289→      case 'retry': {\n   290→        // Increment attempts and schedule retry\n   291→        envelope.docket.attempts++;\n   292→        envelope.docket.scheduledFor = new Date(\n   293→          Date.now() + decision.delay,\n   294→        ).toISOString();\n   295→\n   296→        await this.transport.send(receipt.sourceQueue, envelope, {\n   297→          delay: decision.delay,\n   298→        });\n   299→        await this.transport.complete(receipt);\n   300→        break;\n   301→      }\n   302→\n   303→      case 'dead-letter': {\n   304→        await this.sendToDeadLetter(\n   305→          receipt,\n   306→          envelope,\n   307→          decision.queue,\n   308→          decision.reason,\n   309→        );\n   310→        break;\n   311→      }\n   312→\n   313→      case 'discard': {\n   314→        await this.transport.complete(receipt);\n   315→        break;\n   316→      }\n   317→    }\n   318→  }\n   319→\n   320→  private async sendToDeadLetter(\n   321→    receipt: MessageReceipt,\n   322→    envelope: Envelope,\n   323→    dlqName: string,\n   324→    reason: string,\n   325→  ): Promise<void> {\n   326→    envelope.docket.originalQueue ??= receipt.sourceQueue;\n   327→\n   328→    if (this.transport.sendToDeadLetter) {\n   329→      await this.transport.sendToDeadLetter(receipt, dlqName, envelope, reason);\n   330→    } else {\n   331→      // Manual: send to DLQ then complete original\n   332→      const fullDlqName = `${receipt.sourceQueue}.${dlqName}`;\n   333→      await this.transport.send(fullDlqName, envelope);\n   334→      await this.transport.complete(receipt);\n   335→    }\n   336→  }\n   337→}\n   338→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-11T15:38:37.471Z"
        },
        {
          "type": "assistant",
          "text": "Now I have gathered enough information. Let me now make all the edits to the README.md file:",
          "timestamp": "2025-12-11T15:38:41.164Z"
        },
        {
          "type": "tool_use",
          "name": "Edit",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/README.md",
            "new_string": "```ts\nimport { Matador, TopologyBuilder, RabbitMQTransport } from '@meetsmore/matador-v2';\n\n// Create topology\nconst topology = TopologyBuilder.create()\n  .withNamespace('my-app')\n  .addQueue('events')\n  .build();\n\n// Create transport\nconst transport = new RabbitMQTransport({ url: 'amqp://localhost' });\n\n// Create Matador instance\nconst matador = new Matador({\n  transport,\n  topology,\n  schema: myMatadorSchema,\n  consumeFrom: ['events'],  // Queues to consume from (optional, empty = producer only)\n});\n\nawait matador.start();\n```\n\n```ts\nawait matador.send(UserLoggedInEvent, { userId: '123', username: 'john' });\n```",
            "old_string": "```ts\nconst matador = new Matador({ schema: myMatadorSchema })\n```\n\n> TODO: Make sure all required arguments for `new Matador` are included in this example.\n\n```ts\nawait matador.send(UserLoggedIn, { data: { userId: '123' }, metadata: { loginMethod: 'email' } })\n```\n\n> TODO: Check this example syntax is correct."
          },
          "timestamp": "2025-12-11T15:38:47.811Z"
        }
      ],
      "total_additions": 379,
      "total_deletions": 60,
      "accepted_lines": 366,
      "overriden_lines": 0
    }
  }
}
