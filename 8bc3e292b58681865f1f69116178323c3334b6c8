packages/matador/src/retry/standard-policy.ts
  123a3a85467387ef 2-4,6,25-32,43,49-56,66,69-83,92,101,116,125,127-130,134,138
packages/matador/src/core/matador.test.ts
  123a3a85467387ef 133-134,187-188
packages/matador/src/transport/memory/memory-transport.test.ts
  123a3a85467387ef 48-49,100-102
packages/matador/src/errors/index.ts
  123a3a85467387ef 13-56
packages/matador/src/schema/types.ts
  123a3a85467387ef 15-30,33,36,40-47
packages/matador/src/pipeline/pipeline.ts
  123a3a85467387ef 3-6,100-103,108,127,132
packages/matador/src/schema/index.ts
  123a3a85467387ef 5,10-11
packages/matador/src/errors/matador-errors.ts
  123a3a85467387ef 1-477
packages/matador/src/transport/memory/memory-transport.ts
  123a3a85467387ef 1,93,114,178,197,309
packages/matador/src/errors/retry-errors.ts
  123a3a85467387ef 3,5-13,19-37,44-46,51-52,62-64,69-71,81-83,85-87,90-92,97-111
packages/matador/src/core/matador.ts
  123a3a85467387ef 3-7,13-14,130-160,163,166,168,175-176,225,229
packages/matador/src/transport/transport.ts
  123a3a85467387ef 92-99
packages/matador/src/core/fanout.ts
  123a3a85467387ef 1,51,119,122,125,134,136
packages/matador/src/transport/rabbitmq/rabbitmq-transport.ts
  123a3a85467387ef 4-7,134,178,202,242,260,264-265,340,401,714-748
packages/matador/src/retry/standard-policy.test.ts
  123a3a85467387ef 91,186,188-189,228
packages/matador/src/transport/fallback/fallback-transport.ts
  123a3a85467387ef 1,128,136,142,148-149,156
packages/matador/src/index.ts
  123a3a85467387ef 113,119,158,162,166-210
packages/matador/src/transport/fallback/fallback-transport.test.ts
  123a3a85467387ef 152,161
---
{
  "schema_version": "authorship/3.0.0",
  "git_ai_version": "1.0.22",
  "base_commit_sha": "8bc3e292b58681865f1f69116178323c3334b6c8",
  "prompts": {
    "123a3a85467387ef": {
      "agent_id": {
        "tool": "claude",
        "id": "ab088cb4-7575-4358-8f82-0467844337f2",
        "model": "claude-opus-4-5-20251101"
      },
      "human_author": "Zachary Davison <zachary.davison@meetsmore.com>",
      "messages": [
        {
          "type": "user",
          "text": "Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to.",
          "timestamp": "2025-12-05T11:39:53.558Z"
        },
        {
          "type": "user",
          "text": "<command-name>/add-dir</command-name>\n            <command-message>add-dir</command-message>\n            <command-args>/home/z/Desktop/work/meetsmore/monorepo/@meetsmore/matador</command-args>",
          "timestamp": "2025-12-05T11:39:53.557Z"
        },
        {
          "type": "user",
          "text": "<local-command-stdout>Added \u001b[1m/home/z/Desktop/work/meetsmore/monorepo/@meetsmore/matador\u001b[22m as a working directory for this session \u001b[2m· /permissions to manage\u001b[22m</local-command-stdout>",
          "timestamp": "2025-12-05T11:39:53.557Z"
        },
        {
          "type": "user",
          "text": "ultrathink /home/z/Desktop/work/meetsmore/monorepo/@meetsmore/matador contains the old version of matador.\nanalyze it, and create a list of features / differences between it and the matador in this directory.",
          "timestamp": "2025-12-05T11:40:30.138Z"
        },
        {
          "type": "assistant",
          "text": "I'll analyze both versions of matador to understand their features and differences. Let me explore both codebases.",
          "timestamp": "2025-12-05T11:40:35.363Z"
        },
        {
          "type": "tool_use",
          "name": "Task",
          "input": {
            "description": "Analyze old matador codebase",
            "prompt": "Thoroughly analyze the matador codebase at /home/z/Desktop/work/meetsmore/monorepo/@meetsmore/matador\n\nI need you to:\n1. Understand the overall structure and architecture\n2. Identify all major features and capabilities\n3. Document the transport mechanisms used (RabbitMQ, local, etc.)\n4. Document the job/task processing approach\n5. Document configuration options\n6. Document any retry/error handling mechanisms\n7. Document logging approach\n8. Identify any decorators, utilities, or helper functions\n9. Note the testing approach\n\nReturn a comprehensive summary of all features and implementation details.",
            "subagent_type": "Explore"
          },
          "timestamp": "2025-12-05T11:40:39.659Z"
        },
        {
          "type": "tool_use",
          "name": "Task",
          "input": {
            "description": "Analyze new matador codebase",
            "prompt": "Thoroughly analyze the matador codebase at /home/z/Desktop/work/matador\n\nI need you to:\n1. Understand the overall structure and architecture (note it's a monorepo)\n2. Identify all major features and capabilities\n3. Document the transport mechanisms used (RabbitMQ, local, etc.)\n4. Document the job/task processing approach\n5. Document configuration options\n6. Document any retry/error handling mechanisms\n7. Document logging approach\n8. Identify any decorators, utilities, or helper functions\n9. Note the testing approach\n10. Document the FallbackTransport mechanism mentioned in git history\n\nReturn a comprehensive summary of all features and implementation details.",
            "subagent_type": "Explore"
          },
          "timestamp": "2025-12-05T11:40:42.421Z"
        },
        {
          "type": "assistant",
          "text": "Now I have a complete picture of both codebases. Let me compile a comprehensive comparison:\n\n---\n\n## Matador: Old vs New Version Comparison\n\n### Architecture Overview\n\n| Aspect | Old Version | New Version |\n|--------|-------------|-------------|\n| **Location** | `@meetsmore/matador` (monolithic) | `@meetsmore/matador-v2` (monorepo at `/packages/matador`) |\n| **Build Tool** | tsup + npm | Bun |\n| **Test Framework** | Jest + ts-jest | Bun's built-in test runner |\n| **Node.js** | Not specified | 18.0.0+ required |\n\n---\n\n### Key Architectural Differences\n\n#### 1. Transport Layer\n\n**Old Version - \"Backends\":**\n- `Backend` abstract class with `LocalBackend` and `RabbitMQBackend`\n- Backends tightly coupled to Matador core\n- Fallback logic baked into Matador class itself\n\n**New Version - \"Transports\":**\n- Clean `Transport` interface with explicit **capability declaration**\n- `RabbitMQTransport`, `MemoryTransport`, `FallbackTransport`\n- `FallbackTransport` is a **dedicated wrapper** that chains transports\n- Transport capabilities are explicit and queryable:\n  ```typescript\n  interface TransportCapabilities {\n    deliveryModes: DeliveryMode[];        // 'at-least-once' | 'at-most-once'\n    nativeDeadLetterRouting: boolean;\n    nativeAttemptTracking: boolean;\n    concurrencyControl: boolean;\n    messageOrdering: 'none' | 'per-queue';\n    priorities: boolean;\n    delayedMessages: 'native' | 'emulated' | 'unsupported';\n  }\n  ```\n\n#### 2. Processing Pipeline\n\n**Old Version:**\n- Processing logic mixed into `RabbitMQBackend` and `Matador` classes\n- Less explicit message lifecycle\n\n**New Version:**\n- Dedicated `ProcessingPipeline` class with explicit phases:\n  1. Decode Phase (raw bytes → Envelope)\n  2. Lookup Phase (schema validation)\n  3. Worker Execution (callback invocation)\n  4. Success/Error handling with outcome routing\n\n#### 3. Schema Management\n\n**Old Version:**\n- `MatadorSchema` as simple config object\n- Helper functions: `getEventClass()`, `getSubscribers()`\n- `legacyName()` for aliases\n\n**New Version:**\n- `SchemaRegistry` class with:\n  - Registration with validation\n  - Override support\n  - First-class alias handling\n  - Validation result objects\n\n#### 4. Configuration & Topology\n\n**Old Version:**\n```typescript\ninterface MatadorConfig {\n  namespace: string;\n  schema: MatadorSchema;\n  backends: BackendName[];\n  queues: (QueueName | QueueConfig)[];\n  rabbitmq: { uri, retryDelay, enableDelayedMessages, ... };\n}\n```\n\n**New Version - Fluent TopologyBuilder:**\n```typescript\ncreateTopology()\n  .withNamespace('my-app')\n  .addQueue('events', { concurrency: 5, priorities: true })\n  .withRetry({ enabled: true, defaultDelayMs: 1000 })\n  .withDeadLetter({ undeliverable: { maxLength: 1000 } })\n  .build()\n```\n\n#### 5. Shutdown Management\n\n**Old Version:**\n- `stopReceivingEvents()` + `waitHandlersToBeIdle()`\n- Simple timeout-based waiting\n- Returns handler state\n\n**New Version - Explicit State Machine:**\n```\ndisconnected → stopping-receive → waiting-handlers → stopping-enqueue → disconnecting → stopped\n```\n- `ShutdownManager` class with polling-based idle detection\n- Separate tracking: `eventsBeingProcessed` vs `eventsBeingEnqueued`\n\n#### 6. Connection Management\n\n**Old Version:**\n- `ConnectionManager` with retry strategy\n- 60 attempts × 10s, then 4min intervals\n\n**New Version:**\n- `ConnectionManager` with explicit **state machine**:\n  ```\n  disconnected → connecting → connected → reconnecting → failed\n  ```\n- Configurable exponential backoff\n- Max attempt limits (0 = infinite)\n- State change listeners\n\n---\n\n### Feature Comparison\n\n| Feature | Old Version | New Version |\n|---------|-------------|-------------|\n| **Fan-out Pattern** | ✅ 1:1 subscriber:envelope | ✅ Same |\n| **Idempotency Declaration** | ✅ `yes\\|no\\|unknown` | ✅ Same |\n| **Importance Levels** | ✅ 3 levels | ✅ Same |\n| **DoRetry/DontRetry Errors** | ✅ | ✅ Same |\n| **EventAssertionError** | ✅ Via `assertEvent()` | ✅ Direct throw |\n| **Universal Metadata** | ✅ Via `loadUniversalMetadata` hook | ✅ Same |\n| **Before/After States** | ✅ | ✅ Same |\n| **Subscriber Stubs** | ✅ `SubscriberStub` | ✅ `createSubscriberStub()` |\n| **Event Aliases** | ✅ `legacyName()` | ✅ `aliases` in EventStatic |\n| **Delayed Messages** | ✅ RabbitMQ plugin / setTimeout | ✅ Same |\n| **Dead-Letter Queues** | ✅ retry, unhandled, undeliverable | ✅ unhandled, undeliverable |\n| **Graceful Shutdown** | ✅ Timeout-based | ✅ State machine |\n| **Quorum Queues** | ❌ Not mentioned | ✅ Default enabled |\n| **Message Codec** | Implicit JSON | ✅ Explicit `JsonCodec` with validation |\n| **Transport Capabilities** | Implicit | ✅ Explicit interface |\n| **FallbackTransport** | Baked into core | ✅ Separate composable class |\n| **Hook Error Handling** | ✅ `SafeMatadorHooks` | ✅ `createSafeHooks()` |\n\n---\n\n### Hooks Comparison\n\n| Hook | Old Version | New Version |\n|------|-------------|-------------|\n| `getDesiredBackend()` | ✅ | ❌ (use `FallbackTransport` instead) |\n| `getConcurrency()` | ✅ | ❌ (via topology config) |\n| `getRetryDelay()` | ✅ | ❌ (via `RetryPolicy`) |\n| `getAttempts()` | ✅ | ❌ (via `RetryPolicy`) |\n| `getMaxDeliveries()` | ✅ | ❌ (via `RetryPolicy`) |\n| `loadUniversalMetadata()` | ✅ | ✅ Same |\n| `onEnqueueSuccess/Warning/Error` | ✅ | ✅ Same |\n| `onWorkerWrap` | ✅ | ✅ Same (APM integration) |\n| `onWorkerBeforeProcess` | ✅ | ✅ Same |\n| `onWorkerSuccess/Error` | ✅ | ✅ Same |\n| `onDecodeError` | ❌ | ✅ New |\n| `onConnectionStateChange` | ❌ | ✅ New |\n| `onFallback` | ❌ (in core) | ✅ Via `FallbackTransport` |\n| `logger` hook | ✅ | ✅ (via config) |\n\n---\n\n### RabbitMQ Differences\n\n| Aspect | Old Version | New Version |\n|--------|-------------|-------------|\n| **Queue Type** | Standard | Quorum (default) |\n| **Default Prefetch** | 1 | 10 |\n| **Retry Queue** | ✅ Separate retry DLX | ✅ Same pattern |\n| **Delayed Exchange** | ✅ Auto-detect plugin | ✅ Same |\n| **Connection Pool** | ✅ | ✅ |\n| **Channel per Queue** | ✅ | ✅ |\n\n---\n\n### Error Classes\n\n**Old Version (18 errors):**\n- `NotStartedError`, `InvalidBackendError`, `TimeoutError`\n- `InvalidEventError`, `InvalidSchemaError`\n- `NoSubscribersExistError`, `EventNotRegisteredError`\n- `SubscriberNotRegisteredError`, `QueueNotFoundError`\n- `BackendClosedError`, `MessageMaybePoisonedError`\n- `IdempotentMessageCannotRetryError`, `EventAssertionError`\n- `SubscriberIsStubError`, `LocalBackendCannotProcessSubscriberStubError`\n- `MatadorRoutingConfigError`, `DoRetry`, `DontRetry`\n\n**New Version (streamlined):**\n- `DoRetry`, `DontRetry`, `EventAssertionError` (retry control)\n- Codec errors for decode failures\n- Validation errors via `ValidationResult` objects\n\n---\n\n### Key New Additions in v2\n\n1. **FallbackTransport** - Composable, separate from core\n2. **TopologyBuilder** - Fluent configuration API\n3. **ProcessingPipeline** - Explicit message lifecycle\n4. **SchemaRegistry** - Proper class with validation\n5. **ConnectionManager state machine** - Explicit states\n6. **ShutdownManager** - Explicit shutdown phases\n7. **JsonCodec** - Explicit encoding/decoding with validation\n8. **Transport Capabilities** - Explicit capability declaration\n9. **Quorum Queues** - Durability by default\n10. **Higher default prefetch** (10 vs 1)\n\n---\n\n### What's Removed/Changed in v2\n\n1. **Backend naming** → Renamed to Transport\n2. **Dynamic hook-based config** (getConcurrency, getAttempts) → Static policy/topology config\n3. **`getDesiredBackend()` hook** → Use FallbackTransport composition\n4. **Jest testing** → Bun testing\n5. **`assertEvent()` helper** → Direct `throw new EventAssertionError()`\n6. **Poison message detection** (`MessageMaybePoisonedError`) → Simplified retry policy\n\n---\n\n### Summary\n\nThe new version is a **cleaner architectural rewrite** with:\n- Better separation of concerns (Transport, Pipeline, Schema, Shutdown as separate modules)\n- More explicit and composable design (FallbackTransport as wrapper, not baked-in)\n- Static configuration via builders instead of dynamic hooks\n- Modern tooling (Bun over Jest/npm)\n- Better durability defaults (quorum queues, higher prefetch)\n- Explicit capability declarations for transports",
          "timestamp": "2025-12-05T11:43:45.758Z"
        },
        {
          "type": "user",
          "text": "feedback:\n\n1. the old versions named errors were better. Check the new codebase for any throws, and any thrown error should be a unique documented error type with a description and a name (so it can be seen in DataDog). descriptions should clearly indicate ACTIONS to take to resolve the problem.\n2. we still want the poison message detection for rabbitmq\n3. we also want the old schema system for declaring events and subscriber mappings. The old schema should be compatible.",
          "timestamp": "2025-12-05T11:47:23.930Z"
        },
        {
          "type": "assistant",
          "text": "I'll analyze the new codebase to understand the current error handling, schema system, and where poison message detection should be added.",
          "timestamp": "2025-12-05T11:47:30.909Z"
        },
        {
          "type": "tool_use",
          "name": "Task",
          "input": {
            "description": "Find all throw statements in new matador",
            "prompt": "Search the new matador codebase at /home/z/Desktop/work/matador/packages/matador/src for ALL throw statements and error handling.\n\nFor each throw found, document:\n1. The file and line number\n2. What is being thrown (Error, custom error class, string, etc.)\n3. The context/reason for the throw\n4. Whether it has a descriptive name that would show up in error monitoring\n\nReturn a comprehensive list of ALL throws in the codebase, organized by file.",
            "subagent_type": "Explore"
          },
          "timestamp": "2025-12-05T11:47:34.564Z"
        },
        {
          "type": "tool_use",
          "name": "Task",
          "input": {
            "description": "Analyze old schema system",
            "prompt": "Analyze the old matador schema system at /home/z/Desktop/work/meetsmore/monorepo/@meetsmore/matador/src\n\nFocus on:\n1. How events are declared (Event class, static properties)\n2. How subscribers are declared\n3. How the MatadorSchema type/interface is structured\n4. How event-to-subscriber mappings work\n5. How legacyName/aliases work\n6. Any helper functions for schema operations\n\nReturn the complete schema system design with code examples.",
            "subagent_type": "Explore"
          },
          "timestamp": "2025-12-05T11:47:37.435Z"
        },
        {
          "type": "tool_use",
          "name": "Task",
          "input": {
            "description": "Analyze old error system",
            "prompt": "Analyze the old matador error system at /home/z/Desktop/work/meetsmore/monorepo/@meetsmore/matador/src/errors.ts\n\nDocument:\n1. All error classes defined\n2. Their structure (name, message, description patterns)\n3. How they indicate actions to resolve problems\n4. How MessageMaybePoisonedError and poison detection works\n5. How errors are used in the retry/processing logic\n\nReturn complete details on all error classes and their usage patterns.",
            "subagent_type": "Explore"
          },
          "timestamp": "2025-12-05T11:47:40.011Z"
        },
        {
          "type": "tool_use",
          "name": "Task",
          "input": {
            "description": "Analyze new schema registry",
            "prompt": "Analyze the new matador schema system at /home/z/Desktop/work/matador/packages/matador/src/schema\n\nDocument:\n1. How SchemaRegistry works\n2. How events and subscribers are registered\n3. The current type definitions\n4. How lookups work\n\nCompare this to understand what would need to change to support the old schema format.",
            "subagent_type": "Explore"
          },
          "timestamp": "2025-12-05T11:47:41.730Z"
        },
        {
          "type": "assistant",
          "text": "I have a comprehensive understanding of both codebases now. Let me create a plan for implementing your feedback.",
          "timestamp": "2025-12-05T11:48:39.658Z"
        },
        {
          "type": "tool_use",
          "name": "TodoWrite",
          "input": {
            "todos": [
              {
                "activeForm": "Creating comprehensive named error classes",
                "content": "Create comprehensive named error classes with descriptions and resolution actions",
                "status": "pending"
              },
              {
                "activeForm": "Adding poison message detection for RabbitMQ",
                "content": "Add poison message detection for RabbitMQ transport",
                "status": "pending"
              },
              {
                "activeForm": "Implementing old schema system compatibility",
                "content": "Implement old schema system compatibility (MatadorSchema type with tuple format)",
                "status": "pending"
              }
            ]
          },
          "timestamp": "2025-12-05T11:48:41.780Z"
        },
        {
          "type": "user",
          "text": "Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable",
          "timestamp": "2025-12-05T11:48:41.862Z"
        },
        {
          "type": "assistant",
          "text": "Let me read the current error files and key implementation files in the new codebase to prepare for implementation:",
          "timestamp": "2025-12-05T11:48:46.233Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/errors/index.ts"
          },
          "timestamp": "2025-12-05T11:48:46.881Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/errors/retry-errors.ts"
          },
          "timestamp": "2025-12-05T11:48:47.516Z"
        },
        {
          "type": "tool_use",
          "name": "Glob",
          "input": {
            "path": "/home/z/Desktop/work/matador",
            "pattern": "packages/matador/src/errors/*.ts"
          },
          "timestamp": "2025-12-05T11:48:47.995Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/meetsmore/monorepo/@meetsmore/matador/src/errors.ts"
          },
          "timestamp": "2025-12-05T11:48:48.624Z"
        },
        {
          "type": "user",
          "text": "     1→export type { HasDescription } from './has-description.js';\n     2→export { hasDescription } from './has-description.js';\n     3→\n     4→export {\n     5→  DontRetry,\n     6→  DoRetry,\n     7→  EventAssertionError,\n     8→  isAssertionError,\n     9→  isDontRetry,\n    10→  isDoRetry,\n    11→  RetryControlError,\n    12→} from './retry-errors.js';\n    13→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-05T11:48:48.893Z"
        },
        {
          "type": "user",
          "text": "     1→import type { HasDescription } from './has-description.js';\n     2→\n     3→/**\n     4→ * Base class for retry control errors.\n     5→ */\n     6→export abstract class RetryControlError\n     7→  extends Error\n     8→  implements HasDescription\n     9→{\n    10→  abstract readonly description: string;\n    11→\n    12→  constructor(message: string) {\n    13→    super(message);\n    14→    this.name = this.constructor.name;\n    15→  }\n    16→}\n    17→\n    18→/**\n    19→ * Forces retry regardless of subscriber idempotency setting.\n    20→ * Use when you know the operation is safe to retry.\n    21→ */\n    22→export class DoRetry extends RetryControlError {\n    23→  readonly description =\n    24→    'A subscriber explicitly requested retry by throwing DoRetry. ' +\n    25→    'This overrides the default retry behavior. Check the subscriber code ' +\n    26→    'to understand why retry was forced.';\n    27→\n    28→  constructor(message = 'Forced retry requested') {\n    29→    super(message);\n    30→  }\n    31→}\n    32→\n    33→/**\n    34→ * Prevents retry regardless of subscriber idempotency setting.\n    35→ * Use for permanent failures that should not be retried.\n    36→ */\n    37→export class DontRetry extends RetryControlError {\n    38→  readonly description =\n    39→    'A subscriber explicitly prevented retry by throwing DontRetry. ' +\n    40→    'The message will be sent to the dead-letter queue. Check the subscriber ' +\n    41→    'code to understand why retry was disabled - typically used for permanent ' +\n    42→    'failures like invalid data or business rule violations.';\n    43→\n    44→  constructor(message = 'Retry explicitly disabled') {\n    45→    super(message);\n    46→  }\n    47→}\n    48→\n    49→/**\n    50→ * Assertion error that should never be retried.\n    51→ * Use for programming errors and invariant violations.\n    52→ */\n    53→export class EventAssertionError extends Error implements HasDescription {\n    54→  readonly description =\n    55→    'An event assertion failed, indicating a programming error or invariant ' +\n    56→    'violation. These errors are never retried and go directly to the dead-letter ' +\n    57→    'queue. Review the assertion failure message to identify the bug in the ' +\n    58→    'event payload or subscriber logic.';\n    59→\n    60→  constructor(message: string) {\n    61→    super(message);\n    62→    this.name = 'EventAssertionError';\n    63→  }\n    64→}\n    65→\n    66→/**\n    67→ * Checks if an error forces a retry.\n    68→ */\n    69→export function isDoRetry(error: unknown): error is DoRetry {\n    70→  return error instanceof DoRetry;\n    71→}\n    72→\n    73→/**\n    74→ * Checks if an error prevents retry.\n    75→ */\n    76→export function isDontRetry(error: unknown): error is DontRetry {\n    77→  return error instanceof DontRetry;\n    78→}\n    79→\n    80→/**\n    81→ * Checks if an error is an assertion error (never retry).\n    82→ */\n    83→export function isAssertionError(error: unknown): error is EventAssertionError {\n    84→  return error instanceof EventAssertionError;\n    85→}\n    86→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-05T11:48:48.893Z"
        },
        {
          "type": "user",
          "text": "     1→import { Message } from 'amqplib'\n     2→import { EventKey, SubscriberKey } from './aliases'\n     3→import { BackendName } from './backends/types'\n     4→import { AnyEvent, AnyRichEvent, AnyTargetedRichEvent } from './event'\n     5→import { AnySubscriberStub } from './subscriber'\n     6→\n     7→/**\n     8→ * Matador specific error fields.\n     9→ */\n    10→interface MatadorError {\n    11→  /**\n    12→   * Additional information about an error that might be useful during debugging.\n    13→   */\n    14→  description: string\n    15→}\n    16→\n    17→/**\n    18→ * Thrown if a backend has not been started..\n    19→ * This usually means you forgot to call 'start'.\n    20→ */\n    21→export class NotStartedError extends Error implements MatadorError {\n    22→  public readonly description: string\n    23→  constructor(backend: BackendName) {\n    24→    super(\n    25→      `The backend '${backend}' has not been started, did you forget to call 'start'?`\n    26→    )\n    27→    this.name = 'NotStartedError'\n    28→    this.description = `\n    29→    Thrown if a backend has not been started, this usually means you forgot to call 'start'.\n    30→    `\n    31→  }\n    32→}\n    33→\n    34→/**\n    35→ * Thrown if a backend is not found\n    36→ * This usually means you are trying to use a backend that has not been enabled/registered in the config\n    37→ */\n    38→export class InvalidBackendError extends Error implements MatadorError {\n    39→  public readonly description: string\n    40→  constructor(backend: BackendName) {\n    41→    super(\n    42→      `The backend '${backend}' is invalid, did you forget to enable it in your config?`\n    43→    )\n    44→    this.name = 'InvalidBackendError'\n    45→    this.description = `\n    46→    Thrown if a backend is invalid, this usually means you are trying to use a backend that has not been enabled/registered in the config.\n    47→    `\n    48→  }\n    49→}\n    50→\n    51→/**\n    52→ * Thrown if an operation times out\n    53→ */\n    54→export class TimeoutError extends Error implements MatadorError {\n    55→  public readonly description: string\n    56→  constructor(\n    57→    backend: BackendName,\n    58→    operationName: string,\n    59→    timeoutDurationMs: number\n    60→  ) {\n    61→    super(\n    62→      `The operation '${operationName}' on backend '${backend}' has timed out after ${timeoutDurationMs}ms`\n    63→    )\n    64→    this.name = 'TimeoutError'\n    65→    this.description = `\n    66→    Thrown if an operation on a backend times out.\n    67→    `\n    68→  }\n    69→}\n    70→\n    71→/**\n    72→ * Thrown if an event is invalid.\n    73→ * This can occur if an event is missing required data, such as a 'targetSubscriber'.\n    74→ */\n    75→export class InvalidEventError extends Error implements MatadorError {\n    76→  public readonly description: string\n    77→  /**\n    78→   * The root cause of the error, a 'sub-description'.\n    79→   */\n    80→  public readonly cause: string\n    81→  constructor(\n    82→    event: AnyEvent | AnyRichEvent | AnyTargetedRichEvent | unknown,\n    83→    cause: string\n    84→  ) {\n    85→    super(`Invalid event: '${event}'.`)\n    86→    this.name = 'InvalidEventError'\n    87→    this.cause = cause\n    88→    this.description = `\n    89→    Thrown if an event is invalid.\n    90→    This can occur if an event is missing required data, such as a 'targetSubscriber'.\n    91→    `\n    92→  }\n    93→}\n    94→\n    95→/**\n    96→ * Occurs during enqueue.\n    97→ * When attempting to fanout the event to subscribers, no subscribers were found in the schema.\n    98→ * This should not happen in normal use cases and likely indicates a misconfiguration in the schema.\n    99→ */\n   100→export class NoSubscribersExistError extends Error implements MatadorError {\n   101→  public readonly description: string\n   102→  constructor(event: AnyRichEvent) {\n   103→    super(`No subscribers exist for event: '${event.key}'.`)\n   104→    this.name = 'NoSubscribersExistError'\n   105→    this.description = `\n   106→    Occurs during enqueue.\n   107→    When attempting to fanout the event to subscribers, no subscribers were found in the schema.\n   108→    This should not happen in normal use cases and likely indicates a misconfiguration in the schema.\n   109→    `\n   110→  }\n   111→}\n   112→\n   113→/**\n   114→ * An error that indicates a subscriber could not be found for an event.\n   115→ *\n   116→ * This can occur if a worker is trying to process an event that is not in its schema.\n   117→ *\n   118→ * This may happen when a worker is processing an event that was enqueued before the worker was deployed.\n   119→ */\n   120→export class SubscriberNotRegisteredError\n   121→  extends Error\n   122→  implements MatadorError\n   123→{\n   124→  public readonly description: string\n   125→  constructor(subscriberName: SubscriberKey) {\n   126→    super(`Subscriber not registered in schema: '${subscriberName}'.`)\n   127→    this.name = 'SubscriberNotFoundError'\n   128→    this.description = `\n   129→    An error that indicates a subscriber could not be found for an event.\n   130→    This can occur if a worker is trying to process an event that is not in its schema.\n   131→    This may happen when a worker is processing an event that was enqueued before the worker was deployed.\n   132→    `\n   133→  }\n   134→}\n   135→\n   136→/**\n   137→ * Thrown if a an event is not registered in the schema.\n   138→ *\n   139→ * This can occur if a worker is trying to process an event that is not in its schema.\n   140→ *\n   141→ * This may happen when a worker is processing an event that was enqueued before the worker was deployed.\n   142→ */\n   143→export class EventNotRegisteredError extends Error implements MatadorError {\n   144→  public readonly description: string\n   145→  constructor(key: EventKey) {\n   146→    super(`Event not registered in schema: '${key}'.`)\n   147→    this.name = 'EventNotRegisteredError'\n   148→    this.description = `\n   149→    Thrown if a an event is not registered in the schema.\n   150→    This can occur if a worker is trying to process an event that is not in its schema.\n   151→    This may happen when a worker is processing an event that was enqueued before the worker was deployed.\n   152→    `\n   153→  }\n   154→}\n   155→\n   156→/**\n   157→ * Thrown if a schema is invalid.\n   158→ * Check your schema, the following could be wrong:\n   159→ *  - You are using 'legacyNames' but passing more than 1 record to the subschema argument.\n   160→ */\n   161→export class InvalidSchemaError extends Error implements MatadorError {\n   162→  public readonly description: string\n   163→  public readonly cause: string\n   164→  constructor(cause: string) {\n   165→    super(`Schema was invalid.`)\n   166→    this.cause = cause\n   167→    this.description = `\n   168→    Thrown if a schema is invalid.\n   169→    Check your schema, the following could be wrong:\n   170→      - You are using 'legacyNames' but passing more than 1 record to the subschema argument.\n   171→    `\n   172→  }\n   173→}\n   174→\n   175→/**\n   176→ * Thrown if a queue is not found.\n   177→ * This may happen if an event is enqueued before the queue has been created.\n   178→ * Example: If RabbitMQBackend has not been initialized yet.\n   179→ */\n   180→export class QueueNotFoundError extends Error implements MatadorError {\n   181→  public readonly description: string\n   182→  constructor(queue: string | undefined) {\n   183→    super(`Queue not found: '${queue}'.`)\n   184→    this.name = 'QueueNotFoundError'\n   185→    this.description = `\n   186→    Thrown if a queue is not found.\n   187→    This may happen if an event is enqueued before the queue has been created.\n   188→    Example: If RabbitMQBackend has not been initialized yet.\n   189→    `\n   190→  }\n   191→}\n   192→\n   193→/**\n   194→ *  Thrown if a backend has been closed.\n   195→ *  This should only occur during shutdown of your application in normal use cases.\n   196→ *  Events will not be enqueued after the backend is closed and drained.\n   197→ */\n   198→export class BackendClosedError extends Error implements MatadorError {\n   199→  public readonly description: string\n   200→  constructor(backendName: BackendName) {\n   201→    super(\n   202→      `The backend '${backendName}' has been closed and will not accept enqueueing new events.`\n   203→    )\n   204→    this.name = 'BackendClosedError'\n   205→    this.description = `\n   206→    Thrown if a backend has been closed.\n   207→    This should only occur during shutdown of your application in normal use cases.\n   208→    Events will not be enqueued after the backend is closed and drained.\n   209→    `\n   210→  }\n   211→}\n   212→\n   213→/**\n   214→ *  Thrown if a RabbitMQ message was delivered multiple times without completing processing.\n   215→ *  This usually means that the message caused a crash during processing, or otherwise timed out.\n   216→ *  You should investigate logs and see if either occurred.\n   217→ *  To avoid 'crash loops', this message will not be attempted again and will be sent to the undeliverable DLQ.\n   218→ */\n   219→export class MessageMaybePoisonedError extends Error implements MatadorError {\n   220→  public readonly description: string\n   221→  constructor(queueMessage: Message) {\n   222→    super(\n   223→      `A queue message (${queueMessage.properties.headers['x-event-id']}) was potentially poisoned, it will not be processed.`\n   224→    )\n   225→    this.name = `MessageMaybePoisonedError`\n   226→    this.description = `\n   227→    Thrown if a RabbitMQ message was delivered multiple times without completing processing.\n   228→    This usually means that the message caused a crash during processing, or otherwise timed out.\n   229→    You should investigate logs and see if either occurred.\n   230→    To avoid 'crash loops', this message will not be attempted again and will be sent to the undeliverable DLQ.\n   231→    `\n   232→  }\n   233→}\n   234→\n   235→/**\n   236→ * Thrown if a non-idempotent message cannot be retried due to a previous delivery.\n   237→ * This usually means that the message was redelivered after a crash, but the subscriber\n   238→ * is marked as non-idempotent and therefore cannot be safely retried.\n   239→ * To avoid data corruption or duplicate processing, this message will not be processed.\n   240→ */\n   241→export class IdempotentMessageCannotRetryError\n   242→  extends Error\n   243→  implements MatadorError\n   244→{\n   245→  public readonly description: string\n   246→  constructor(queueMessage: Message) {\n   247→    super(\n   248→      `A non-idempotent message (${queueMessage.properties.headers['x-event-id']}) cannot be retried, it will not be processed.`\n   249→    )\n   250→    this.name = 'IdempotentMessageCannotRetryError'\n   251→    this.description = `\n   252→    Thrown if a non-idempotent message cannot be retried due to a previous delivery.\n   253→    This usually means that the message was redelivered after a crash, but the subscriber \n   254→    is marked as non-idempotent and therefore cannot be safely retried.\n   255→    To avoid data corruption or duplicate processing, this message will not be processed.\n   256→    `\n   257→  }\n   258→}\n   259→\n   260→/**\n   261→ *  Thrown by `assertEvent`in the event of a failed assertion.\n   262→ *  @see `@meetsmore/matador/src/event.ts#assertEvent`\n   263→ */\n   264→export class EventAssertionError extends Error implements MatadorError {\n   265→  public readonly description: string\n   266→  public readonly event: AnyRichEvent\n   267→  constructor(event: AnyRichEvent, message: string) {\n   268→    super(message)\n   269→    this.name = 'EventAssertionError'\n   270→    this.event = event\n   271→    this.description = `\n   272→    Thrown to indicate that an event was in an unexpected state when it reached the subscriber.\n   273→    Throwing this event will indicate to Matador NOT to retry the event.\n   274→    Matador does not throw this error, it is thrown by 'assertEvent', which you can use in your subscribers to assert properties about an event.\n   275→    This can be useful in scenarios where you would expect an event payload to contain a field based on the types, but something unexpected caused it to not be present.\n   276→    Using this instead of the NodeJS 'assert' allows Matador to not retry the event subscriber.\n   277→    `\n   278→  }\n   279→}\n   280→\n   281→/**\n   282→ * Thrown if a subscriber is found to be a stub.\n   283→ * @see `@meetsmore/matador/src/subscriber.ts#SubscriberStub`\n   284→ */\n   285→export class SubscriberIsStubError extends Error implements MatadorError {\n   286→  public readonly description: string\n   287→  public readonly subscriber: AnySubscriberStub\n   288→  constructor(subscriber: AnySubscriberStub) {\n   289→    super(\n   290→      `A stub subscriber '${subscriber.name}' was registered in a consumers schema. This is a programmer error.`\n   291→    )\n   292→    this.name = 'SubscriberIsStubError'\n   293→    this.description = `\n   294→    Thrown if a subscriber was found to be a 'SubscriberStub', instead of an actual 'Subscriber'.\n   295→    'SubscriberStub' should only be registered in the schema of producers, not consumers.\n   296→    Registering a 'SubscriberStub' into a consumers MatadorSchema is a programmer error and it should be removed.\n   297→    At this time, consuming an event and also dispatching it as a stub is unsupported.\n   298→    If you need this feature, contact the maintainers of Matador.\n   299→    `\n   300→  }\n   301→}\n   302→\n   303→export class LocalBackendCannotProcessSubscriberStubError\n   304→  extends Error\n   305→  implements MatadorError\n   306→{\n   307→  public readonly description: string\n   308→  public readonly subscriber: AnySubscriberStub\n   309→  constructor(subscriber: AnySubscriberStub) {\n   310→    super(\n   311→      `An event targeting a SubscriberStub '${subscriber.name}' was received in a 'local' backend. It will not be processed.`\n   312→    )\n   313→    this.name = 'LocalBackendCannotProcessSubscriberStubError'\n   314→    this.description = `\n   315→    Thrown if a local backend tries to process a SubscriberStub.\n   316→    SubscriberStubs do not contain callbacks, and therefore cannot be processed locally,\n   317→    as the current instance does not know how to handle them.\n   318→    This error will usually occur if enqueuing fails for an event that has a SubscriberStub registered.\n   319→    This is expected in that case, but be aware that the event will NOT be enqueued or processed.\n   320→    `\n   321→  }\n   322→}\n   323→\n   324→/**\n   325→ * Thrown manually by subscriber implementations outside of Matador.\n   326→ *\n   327→ * Throwing this event will indicate to Matador NOT to retry the event, regardless of the idempotency setting.\n   328→ *\n   329→ * This is useful in order to handle scenarios where you know that a subscriber can never succeed, or you don't want it to run its work again.\n   330→ *\n   331→ * Check the 'cause' property for the true underlying cause of the error.\n   332→ */\n   333→export class DontRetry extends Error implements MatadorError {\n   334→  public readonly cause: Error\n   335→  public readonly description: string\n   336→  constructor(cause: Error) {\n   337→    super(\n   338→      `An error occurred, and the subscriber indicated it must NOT be retried.`\n   339→    )\n   340→    this.name = 'DontRetry'\n   341→    this.description = `\n   342→    Thrown manually by subscriber implementations outside of Matador.\n   343→    Throwing this event will indicate to Matador NOT to retry the event, regardless of the idempotency setting.\n   344→    This is useful in order to handle scenarios where you know that a subscriber can never succeed, or you don't want it to run its work again.\n   345→    Check the 'cause' property for the true underlying cause of the error.\n   346→    `\n   347→    this.cause = cause\n   348→  }\n   349→}\n   350→\n   351→/**\n   352→ * Thrown manually by subscriber implementations outside of Matador.\n   353→ *\n   354→ * Throwing this event will FORCE Matador to retry the event, regardless of the idempotency setting.\n   355→ *\n   356→ * If an event has reached the maximum attempt count, it will not be retried even if this error is thrown.\n   357→ *\n   358→ * This is useful in order to handle scenarios where you know that an error is temporary, and you definitely want to retry it.\n   359→ *\n   360→ * Check the 'cause' property for the true underlying cause of the error.\n   361→ */\n   362→export class DoRetry extends Error implements MatadorError {\n   363→  public readonly cause: Error\n   364→  public readonly description: string\n   365→  constructor(cause: Error) {\n   366→    super(`An error occurred, and the subscriber indicated it must be retried.`)\n   367→    this.name = 'DoRetry'\n   368→    this.description = `\n   369→    Thrown manually by subscriber implementations outside of Matador.\n   370→    Throwing this event will FORCE Matador to retry the event, regardless of the idempotency setting.\n   371→    If an event has reached the maximum attempt count, it will not be retried even if this error is thrown.\n   372→    This is useful in order to handle scenarios where you know that an error is temporary, and you definitely want to retry it.\n   373→    Check the 'cause' property for the true underlying cause of the error.\n   374→    `\n   375→    this.cause = cause\n   376→  }\n   377→}\n   378→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-05T11:48:48.893Z"
        },
        {
          "type": "user",
          "text": "/home/z/Desktop/work/matador/packages/matador/src/errors/has-description.ts\n/home/z/Desktop/work/matador/packages/matador/src/errors/index.ts\n/home/z/Desktop/work/matador/packages/matador/src/errors/retry-errors.ts",
          "timestamp": "2025-12-05T11:48:49.048Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/errors/has-description.ts"
          },
          "timestamp": "2025-12-05T11:48:56.916Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/schema/registry.ts"
          },
          "timestamp": "2025-12-05T11:48:57.359Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/transport/rabbitmq/rabbitmq-transport.ts"
          },
          "timestamp": "2025-12-05T11:48:57.888Z"
        },
        {
          "type": "user",
          "text": "     1→/**\n     2→ * Interface for errors that provide a human-readable description.\n     3→ * The description explains what the error means and what actions\n     4→ * users should take when encountering it in logs/observability.\n     5→ */\n     6→export interface HasDescription {\n     7→  /**\n     8→   * Human-readable description of the error type.\n     9→   * Intended for logging and observability to help users understand\n    10→   * the error and determine appropriate remediation steps.\n    11→   */\n    12→  readonly description: string;\n    13→}\n    14→\n    15→/**\n    16→ * Type guard to check if an error implements HasDescription.\n    17→ */\n    18→export function hasDescription(error: unknown): error is HasDescription {\n    19→  return (\n    20→    typeof error === 'object' &&\n    21→    error !== null &&\n    22→    'description' in error &&\n    23→    typeof (error as HasDescription).description === 'string'\n    24→  );\n    25→}\n    26→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-05T11:48:58.162Z"
        },
        {
          "type": "user",
          "text": "     1→import type { HasDescription } from '../errors/index.js';\n     2→import type {\n     3→  AnySubscriber,\n     4→  EventClass,\n     5→  Subscriber,\n     6→  SubscriberDefinition,\n     7→} from '../types/index.js';\n     8→import { isSubscriber } from '../types/index.js';\n     9→import type {\n    10→  RegisterOptions,\n    11→  SchemaEntry,\n    12→  SchemaIssue,\n    13→  SchemaValidationResult,\n    14→} from './types.js';\n    15→\n    16→/**\n    17→ * Error thrown when schema operations fail.\n    18→ */\n    19→export class SchemaError extends Error implements HasDescription {\n    20→  readonly description =\n    21→    'A schema operation failed, such as registering a duplicate event or ' +\n    22→    'conflicting alias. This is a configuration error that should be fixed ' +\n    23→    'during development. Review the event and subscriber registrations to ' +\n    24→    'resolve the conflict.';\n    25→\n    26→  constructor(message: string) {\n    27→    super(message);\n    28→    this.name = 'SchemaError';\n    29→  }\n    30→}\n    31→\n    32→/**\n    33→ * Registry for managing event-subscriber relationships.\n    34→ */\n    35→export class SchemaRegistry {\n    36→  private readonly entries = new Map<string, SchemaEntry>();\n    37→  private readonly aliases = new Map<string, string>();\n    38→\n    39→  /**\n    40→   * Registers an event class with its subscribers.\n    41→   */\n    42→  register<T>(\n    43→    eventClass: EventClass<T>,\n    44→    subscribers: readonly AnySubscriber<T>[],\n    45→    options: RegisterOptions = {},\n    46→  ): void {\n    47→    const key = eventClass.key;\n    48→\n    49→    if (this.entries.has(key) && !options.override) {\n    50→      throw new SchemaError(`Event \"${key}\" is already registered`);\n    51→    }\n    52→\n    53→    this.entries.set(key, {\n    54→      eventClass,\n    55→      subscribers,\n    56→    } as SchemaEntry);\n    57→\n    58→    // Register aliases\n    59→    if (eventClass.aliases) {\n    60→      for (const alias of eventClass.aliases) {\n    61→        if (\n    62→          this.aliases.has(alias) &&\n    63→          this.aliases.get(alias) !== key &&\n    64→          !options.override\n    65→        ) {\n    66→          throw new SchemaError(\n    67→            `Alias \"${alias}\" is already registered for event \"${this.aliases.get(alias)}\"`,\n    68→          );\n    69→        }\n    70→        this.aliases.set(alias, key);\n    71→      }\n    72→    }\n    73→  }\n    74→\n    75→  /**\n    76→   * Gets the event class for a given key.\n    77→   */\n    78→  getEventClass(key: string): EventClass | undefined {\n    79→    const entry = this.entries.get(key);\n    80→    if (entry) return entry.eventClass;\n    81→\n    82→    // Check aliases\n    83→    const aliasKey = this.aliases.get(key);\n    84→    if (aliasKey) {\n    85→      return this.entries.get(aliasKey)?.eventClass;\n    86→    }\n    87→\n    88→    return undefined;\n    89→  }\n    90→\n    91→  /**\n    92→   * Gets all subscribers for an event key.\n    93→   */\n    94→  getSubscribers(eventKey: string): readonly AnySubscriber[] {\n    95→    const entry = this.getEntry(eventKey);\n    96→    return entry?.subscribers ?? [];\n    97→  }\n    98→\n    99→  /**\n   100→   * Gets a specific subscriber by event key and subscriber name.\n   101→   */\n   102→  getSubscriber(\n   103→    eventKey: string,\n   104→    subscriberName: string,\n   105→  ): AnySubscriber | undefined {\n   106→    const subscribers = this.getSubscribers(eventKey);\n   107→    return subscribers.find((s) => s.name === subscriberName);\n   108→  }\n   109→\n   110→  /**\n   111→   * Gets a subscriber definition for the pipeline.\n   112→   */\n   113→  getSubscriberDefinition(\n   114→    eventKey: string,\n   115→    subscriberName: string,\n   116→  ): SubscriberDefinition | undefined {\n   117→    const subscriber = this.getSubscriber(eventKey, subscriberName);\n   118→    if (!subscriber) return undefined;\n   119→\n   120→    const def: SubscriberDefinition = {\n   121→      name: subscriber.name,\n   122→      idempotent: subscriber.idempotent ?? 'unknown',\n   123→      importance: subscriber.importance ?? 'should-investigate',\n   124→    };\n   125→\n   126→    if (subscriber.targetQueue !== undefined) {\n   127→      (def as { targetQueue?: string }).targetQueue = subscriber.targetQueue;\n   128→    }\n   129→\n   130→    return def;\n   131→  }\n   132→\n   133→  /**\n   134→   * Gets a subscriber with callback for execution.\n   135→   */\n   136→  getExecutableSubscriber(\n   137→    eventKey: string,\n   138→    subscriberName: string,\n   139→  ): Subscriber | undefined {\n   140→    const subscriber = this.getSubscriber(eventKey, subscriberName);\n   141→    if (!subscriber || !isSubscriber(subscriber)) return undefined;\n   142→    return subscriber;\n   143→  }\n   144→\n   145→  /**\n   146→   * Gets the event class by alias.\n   147→   */\n   148→  getEventByAlias(alias: string): EventClass | undefined {\n   149→    const key = this.aliases.get(alias);\n   150→    if (!key) return undefined;\n   151→    return this.entries.get(key)?.eventClass;\n   152→  }\n   153→\n   154→  /**\n   155→   * Checks if an event key is registered.\n   156→   */\n   157→  hasEvent(key: string): boolean {\n   158→    return this.entries.has(key) || this.aliases.has(key);\n   159→  }\n   160→\n   161→  /**\n   162→   * Gets all registered event keys.\n   163→   */\n   164→  getEventKeys(): readonly string[] {\n   165→    return [...this.entries.keys()];\n   166→  }\n   167→\n   168→  /**\n   169→   * Validates the schema for issues.\n   170→   */\n   171→  validate(): SchemaValidationResult {\n   172→    const issues: SchemaIssue[] = [];\n   173→\n   174→    for (const [key, entry] of this.entries) {\n   175→      // Check for duplicate subscriber names\n   176→      const names = new Set<string>();\n   177→      for (const subscriber of entry.subscribers) {\n   178→        if (names.has(subscriber.name)) {\n   179→          issues.push({\n   180→            severity: 'error',\n   181→            eventKey: key,\n   182→            message: `Duplicate subscriber name: \"${subscriber.name}\"`,\n   183→          });\n   184→        }\n   185→        names.add(subscriber.name);\n   186→      }\n   187→\n   188→      // Check for subscribers without callbacks (stubs in consuming instance)\n   189→      const stubs = entry.subscribers.filter((s) => !isSubscriber(s));\n   190→      if (stubs.length === entry.subscribers.length && stubs.length > 0) {\n   191→        issues.push({\n   192→          severity: 'warning',\n   193→          eventKey: key,\n   194→          message: 'All subscribers are stubs, no local handlers',\n   195→        });\n   196→      }\n   197→    }\n   198→\n   199→    return {\n   200→      valid: issues.filter((i) => i.severity === 'error').length === 0,\n   201→      issues,\n   202→    };\n   203→  }\n   204→\n   205→  /**\n   206→   * Clears all registered entries.\n   207→   */\n   208→  clear(): void {\n   209→    this.entries.clear();\n   210→    this.aliases.clear();\n   211→  }\n   212→\n   213→  private getEntry(eventKey: string): SchemaEntry | undefined {\n   214→    const entry = this.entries.get(eventKey);\n   215→    if (entry) return entry;\n   216→\n   217→    const aliasKey = this.aliases.get(eventKey);\n   218→    if (aliasKey) {\n   219→      return this.entries.get(aliasKey);\n   220→    }\n   221→\n   222→    return undefined;\n   223→  }\n   224→}\n   225→\n   226→/**\n   227→ * Creates a new schema registry instance.\n   228→ */\n   229→export function createSchemaRegistry(): SchemaRegistry {\n   230→  return new SchemaRegistry();\n   231→}\n   232→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-05T11:48:58.162Z"
        },
        {
          "type": "user",
          "text": "     1→import type { Channel, ChannelModel, ConsumeMessage, Options } from 'amqplib';\n     2→import amqplib from 'amqplib';\n     3→import { JsonCodec } from '../../codec/json-codec.js';\n     4→import { type Logger, consoleLogger } from '../../hooks/index.js';\n     5→import type { QueueDefinition, Topology } from '../../topology/types.js';\n     6→import type { Envelope } from '../../types/index.js';\n     7→import type { TransportCapabilities } from '../capabilities.js';\n     8→import {\n     9→  ConnectionManager,\n    10→  type ConnectionManagerConfig,\n    11→} from '../connection-manager.js';\n    12→import type {\n    13→  MessageHandler,\n    14→  MessageReceipt,\n    15→  SendOptions,\n    16→  SubscribeOptions,\n    17→  Subscription,\n    18→  Transport,\n    19→} from '../transport.js';\n    20→\n    21→/**\n    22→ * Configuration options for the RabbitMQ transport.\n    23→ */\n    24→export interface RabbitMQTransportConfig {\n    25→  /** RabbitMQ connection URL */\n    26→  readonly url: string;\n    27→\n    28→  /** Connection manager configuration */\n    29→  readonly connection?: Partial<ConnectionManagerConfig> | undefined;\n    30→\n    31→  /** Use quorum queues for durability (default: true) */\n    32→  readonly quorumQueues?: boolean | undefined;\n    33→\n    34→  /** Default prefetch count per consumer (default: 10) */\n    35→  readonly defaultPrefetch?: number | undefined;\n    36→\n    37→  /** Enable the delayed message exchange plugin if available (default: true) */\n    38→  readonly enableDelayedMessages?: boolean | undefined;\n    39→\n    40→  /** Logger for transport events (defaults to console) */\n    41→  readonly logger?: Logger | undefined;\n    42→}\n    43→\n    44→/**\n    45→ * Internal structure for tracking a queue's dedicated channel.\n    46→ */\n    47→interface QueueChannel {\n    48→  readonly channel: Channel;\n    49→  readonly consumers: ActiveConsumer[];\n    50→}\n    51→\n    52→/**\n    53→ * Internal structure for tracking active consumers.\n    54→ */\n    55→interface ActiveConsumer {\n    56→  readonly consumerTag: string;\n    57→  readonly queue: string;\n    58→  active: boolean;\n    59→}\n    60→\n    61→/**\n    62→ * RabbitMQ transport implementation using amqplib.\n    63→ */\n    64→export class RabbitMQTransport implements Transport {\n    65→  readonly name = 'rabbitmq';\n    66→\n    67→  private _capabilities: TransportCapabilities = {\n    68→    deliveryModes: ['at-least-once'],\n    69→    delayedMessages: false,\n    70→    deadLetterRouting: 'native',\n    71→    attemptTracking: true,\n    72→    concurrencyModel: 'prefetch',\n    73→    ordering: 'none',\n    74→    priorities: true,\n    75→  };\n    76→\n    77→  get capabilities(): TransportCapabilities {\n    78→    return this._capabilities;\n    79→  }\n    80→\n    81→  private connection: ChannelModel | null = null;\n    82→  private publishChannel: Channel | null = null;\n    83→  private readonly connectionManager: ConnectionManager;\n    84→  private readonly queueChannels = new Map<string, QueueChannel>();\n    85→  private topology: Topology | null = null;\n    86→  private readonly codec = new JsonCodec();\n    87→\n    88→  private readonly config: Required<\n    89→    Omit<RabbitMQTransportConfig, 'connection' | 'logger'>\n    90→  > & {\n    91→    connection: Partial<ConnectionManagerConfig>;\n    92→  };\n    93→\n    94→  private readonly logger: Logger;\n    95→  private delayedExchangeAvailable = false;\n    96→\n    97→  constructor(config: RabbitMQTransportConfig) {\n    98→    this.logger = config.logger ?? consoleLogger;\n    99→    this.config = {\n   100→      url: config.url,\n   101→      connection: config.connection ?? {},\n   102→      quorumQueues: config.quorumQueues ?? true,\n   103→      defaultPrefetch: config.defaultPrefetch ?? 10,\n   104→      enableDelayedMessages: config.enableDelayedMessages ?? true,\n   105→    };\n   106→\n   107→    this.connectionManager = new ConnectionManager(\n   108→      () => this.doConnect(),\n   109→      () => this.doDisconnect(),\n   110→      this.config.connection,\n   111→    );\n   112→  }\n   113→\n   114→  async connect(): Promise<void> {\n   115→    await this.connectionManager.connect();\n   116→  }\n   117→\n   118→  async disconnect(): Promise<void> {\n   119→    await this.connectionManager.disconnect();\n   120→  }\n   121→\n   122→  isConnected(): boolean {\n   123→    return this.connectionManager.isConnected();\n   124→  }\n   125→\n   126→  async applyTopology(topology: Topology): Promise<void> {\n   127→    this.topology = topology;\n   128→\n   129→    if (!this.publishChannel) {\n   130→      throw new Error('Transport not connected');\n   131→    }\n   132→\n   133→    const channel = this.publishChannel;\n   134→\n   135→    // Create the main exchange for routing messages to queues\n   136→    const mainExchange = this.getMainExchangeName(topology.namespace);\n   137→    await channel.assertExchange(mainExchange, 'direct', { durable: true });\n   138→\n   139→    // Create dead-letter exchange if DLQ is enabled\n   140→    const dlxExchange = this.getDLXExchangeName(topology.namespace);\n   141→    if (\n   142→      topology.deadLetter.unhandled.enabled ||\n   143→      topology.deadLetter.undeliverable.enabled\n   144→    ) {\n   145→      await channel.assertExchange(dlxExchange, 'direct', { durable: true });\n   146→    }\n   147→\n   148→    // Check for delayed message exchange plugin\n   149→    if (this.config.enableDelayedMessages) {\n   150→      await this.setupDelayedExchange(topology.namespace);\n   151→    }\n   152→\n   153→    // Create work queues\n   154→    for (const queueDef of topology.queues) {\n   155→      await this.assertWorkQueue(channel, topology, queueDef);\n   156→    }\n   157→\n   158→    // Create DLQs\n   159→    if (topology.deadLetter.unhandled.enabled) {\n   160→      await this.assertDeadLetterQueues(channel, topology, 'unhandled');\n   161→    }\n   162→\n   163→    if (topology.deadLetter.undeliverable.enabled) {\n   164→      await this.assertDeadLetterQueues(channel, topology, 'undeliverable');\n   165→    }\n   166→  }\n   167→\n   168→  async send(\n   169→    queue: string,\n   170→    envelope: Envelope,\n   171→    options?: SendOptions,\n   172→  ): Promise<void> {\n   173→    if (!this.publishChannel || !this.topology) {\n   174→      throw new Error('Transport not connected or topology not applied');\n   175→    }\n   176→\n   177→    const buffer = Buffer.from(this.codec.encode(envelope));\n   178→\n   179→    const publishOptions: Options.Publish = {\n   180→      persistent: true,\n   181→      contentType: this.codec.contentType,\n   182→      messageId: envelope.id,\n   183→      timestamp: Date.now(),\n   184→      headers: {\n   185→        'x-matador-attempts': envelope.attempts,\n   186→        'x-matador-event-key': envelope.docket.eventKey,\n   187→        'x-matador-subscriber': envelope.docket.targetSubscriber,\n   188→      },\n   189→    };\n   190→\n   191→    if (options?.priority !== undefined) {\n   192→      publishOptions.priority = options.priority;\n   193→    }\n   194→\n   195→    // Handle delayed messages\n   196→    if (options?.delay !== undefined && options.delay > 0) {\n   197→      if (!this.delayedExchangeAvailable) {\n   198→        throw new Error(\n   199→          'Delayed messages require the RabbitMQ delayed message exchange plugin. ' +\n   200→            'Install rabbitmq_delayed_message_exchange or disable delayed messages.',\n   201→        );\n   202→      }\n   203→\n   204→      const delayedExchange = this.getDelayedExchangeName(\n   205→        this.topology.namespace,\n   206→      );\n   207→      publishOptions.headers = {\n   208→        ...publishOptions.headers,\n   209→        'x-delay': options.delay,\n   210→      };\n   211→      this.publishChannel.publish(\n   212→        delayedExchange,\n   213→        queue,\n   214→        buffer,\n   215→        publishOptions,\n   216→      );\n   217→      return;\n   218→    }\n   219→\n   220→    // Transport-specific options\n   221→    if (options?.transport?.rabbitmq?.expiration !== undefined) {\n   222→      publishOptions.expiration = String(options.transport.rabbitmq.expiration);\n   223→    }\n   224→\n   225→    if (options?.transport?.rabbitmq?.persistent !== undefined) {\n   226→      publishOptions.persistent = options.transport.rabbitmq.persistent;\n   227→    }\n   228→\n   229→    const routingKey = options?.transport?.rabbitmq?.routingKey ?? queue;\n   230→    const exchange = this.getMainExchangeName(this.topology.namespace);\n   231→\n   232→    this.publishChannel.publish(exchange, routingKey, buffer, publishOptions);\n   233→  }\n   234→\n   235→  async subscribe(\n   236→    queue: string,\n   237→    handler: MessageHandler,\n   238→    options: SubscribeOptions = {},\n   239→  ): Promise<Subscription> {\n   240→    if (!this.connection || !this.topology) {\n   241→      throw new Error('Transport not connected or topology not applied');\n   242→    }\n   243→\n   244→    // Get or create a dedicated channel for this queue\n   245→    const queueChannel = await this.getOrCreateQueueChannel(queue, options);\n   246→    const { channel } = queueChannel;\n   247→\n   248→    const consumer: ActiveConsumer = {\n   249→      consumerTag: '',\n   250→      queue,\n   251→      active: true,\n   252→    };\n   253→\n   254→    const { consumerTag } = await channel.consume(\n   255→      queue,\n   256→      async (msg: ConsumeMessage | null) => {\n   257→        if (!msg || !consumer.active) return;\n   258→\n   259→        const receipt: MessageReceipt = {\n   260→          handle: { channel, msg },\n   261→          redelivered: msg.fields.redelivered,\n   262→          attemptNumber: this.getAttemptNumber(msg),\n   263→          sourceQueue: queue,\n   264→        };\n   265→\n   266→        try {\n   267→          const envelope = this.codec.decode(new Uint8Array(msg.content));\n   268→          await handler(envelope, receipt);\n   269→        } catch (error) {\n   270→          // Handler errors should be caught in the pipeline\n   271→          this.logger.error(\n   272→            '[Matador] 🔴 Handler error in message processing',\n   273→            error,\n   274→          );\n   275→        }\n   276→      },\n   277→      { noAck: false }, // Always manually ack\n   278→    );\n   279→\n   280→    // Update the consumer tag\n   281→    (consumer as { consumerTag: string }).consumerTag = consumerTag;\n   282→\n   283→    // Track the consumer\n   284→    queueChannel.consumers.push(consumer);\n   285→\n   286→    return {\n   287→      unsubscribe: async () => {\n   288→        consumer.active = false;\n   289→        try {\n   290→          await channel.cancel(consumerTag);\n   291→        } catch {\n   292→          // Channel may already be closed\n   293→        }\n   294→\n   295→        // Remove consumer from tracking\n   296→        const idx = queueChannel.consumers.indexOf(consumer);\n   297→        if (idx !== -1) {\n   298→          queueChannel.consumers.splice(idx, 1);\n   299→        }\n   300→\n   301→        // Close channel if no more consumers on this queue\n   302→        if (queueChannel.consumers.length === 0) {\n   303→          try {\n   304→            await channel.close();\n   305→          } catch {\n   306→            // Ignore\n   307→          }\n   308→          this.queueChannels.delete(queue);\n   309→        }\n   310→      },\n   311→      get isActive() {\n   312→        return consumer.active;\n   313→      },\n   314→    };\n   315→  }\n   316→\n   317→  async complete(receipt: MessageReceipt): Promise<void> {\n   318→    const { channel, msg } = receipt.handle as {\n   319→      channel: Channel;\n   320→      msg: ConsumeMessage;\n   321→    };\n   322→\n   323→    try {\n   324→      channel.ack(msg);\n   325→    } catch {\n   326→      // Channel may be closed, ignore\n   327→    }\n   328→  }\n   329→\n   330→  async sendToDeadLetter(\n   331→    receipt: MessageReceipt,\n   332→    dlqName: string,\n   333→    envelope: Envelope,\n   334→    reason: string,\n   335→  ): Promise<void> {\n   336→    if (!this.publishChannel || !this.topology) {\n   337→      throw new Error('Transport not connected');\n   338→    }\n   339→\n   340→    // Add error info to envelope\n   341→    const dlqEnvelope: Envelope = {\n   342→      ...envelope,\n   343→      docket: {\n   344→        ...envelope.docket,\n   345→        lastError: reason,\n   346→        firstError: envelope.docket.firstError ?? reason,\n   347→        originalQueue: receipt.sourceQueue,\n   348→      },\n   349→    };\n   350→\n   351→    const buffer = Buffer.from(this.codec.encode(dlqEnvelope));\n   352→    const dlxExchange = this.getDLXExchangeName(this.topology.namespace);\n   353→    const dlqQueueName = `${receipt.sourceQueue}.${dlqName}`;\n   354→\n   355→    const publishOptions: Options.Publish = {\n   356→      persistent: true,\n   357→      contentType: this.codec.contentType,\n   358→      messageId: envelope.id,\n   359→      timestamp: Date.now(),\n   360→      headers: {\n   361→        'x-matador-attempts': envelope.attempts,\n   362→        'x-matador-event-key': envelope.docket.eventKey,\n   363→        'x-matador-subscriber': envelope.docket.targetSubscriber,\n   364→        'x-matador-dead-letter-reason': reason,\n   365→        'x-matador-original-queue': receipt.sourceQueue,\n   366→      },\n   367→    };\n   368→\n   369→    this.publishChannel.publish(\n   370→      dlxExchange,\n   371→      dlqQueueName,\n   372→      buffer,\n   373→      publishOptions,\n   374→    );\n   375→\n   376→    // Complete the original message\n   377→    await this.complete(receipt);\n   378→  }\n   379→\n   380→  // Private methods\n   381→\n   382→  /**\n   383→   * Gets or creates a dedicated channel for a queue subscription.\n   384→   *\n   385→   * We create separate channels per subscribed queue to enable independent\n   386→   * prefetch/concurrency control.\n   387→   */\n   388→  private async getOrCreateQueueChannel(\n   389→    queue: string,\n   390→    options: SubscribeOptions,\n   391→  ): Promise<QueueChannel> {\n   392→    const existing = this.queueChannels.get(queue);\n   393→    if (existing) {\n   394→      return existing;\n   395→    }\n   396→\n   397→    if (!this.connection) {\n   398→      throw new Error('Transport not connected');\n   399→    }\n   400→\n   401→    // Create a dedicated channel for this queue to control prefetch independently\n   402→    const channel = await this.connection.createChannel();\n   403→\n   404→    const prefetch =\n   405→      options.transport?.rabbitmq?.prefetch ??\n   406→      options.concurrency ??\n   407→      this.config.defaultPrefetch ??\n   408→      10;\n   409→\n   410→    await channel.prefetch(prefetch);\n   411→\n   412→    const queueChannel: QueueChannel = {\n   413→      channel,\n   414→      consumers: [],\n   415→    };\n   416→\n   417→    this.queueChannels.set(queue, queueChannel);\n   418→\n   419→    return queueChannel;\n   420→  }\n   421→\n   422→  private async doConnect(): Promise<void> {\n   423→    const connection = await amqplib.connect(this.config.url);\n   424→    this.connection = connection;\n   425→\n   426→    // Handle connection errors - let ConnectionManager handle reconnection\n   427→    connection.on('error', (err: Error) => {\n   428→      this.logger.error('[Matador] 🔴 RabbitMQ connection error', err);\n   429→    });\n   430→\n   431→    connection.on('close', () => {\n   432→      if (this.connectionManager.isConnected()) {\n   433→        // Unexpected close, trigger reconnection\n   434→        this.connectionManager.handleConnectionLost(\n   435→          new Error('Connection closed unexpectedly'),\n   436→        );\n   437→      }\n   438→    });\n   439→\n   440→    // Create the publish channel\n   441→    this.publishChannel = await connection.createChannel();\n   442→\n   443→    // Handle publish channel errors to prevent unhandled error events\n   444→    this.publishChannel.on('error', (err: Error) => {\n   445→      this.logger.error('[Matador] 🔴 RabbitMQ publish channel error', err);\n   446→    });\n   447→\n   448→    // Re-apply topology if we have one (reconnection scenario)\n   449→    if (this.topology) {\n   450→      await this.applyTopology(this.topology);\n   451→    }\n   452→  }\n   453→\n   454→  private async doDisconnect(): Promise<void> {\n   455→    // Cancel all consumers and close queue channels\n   456→    for (const queueChannel of this.queueChannels.values()) {\n   457→      for (const consumer of queueChannel.consumers) {\n   458→        consumer.active = false;\n   459→        try {\n   460→          await queueChannel.channel.cancel(consumer.consumerTag);\n   461→        } catch {\n   462→          // Ignore errors during cleanup\n   463→        }\n   464→      }\n   465→      try {\n   466→        await queueChannel.channel.close();\n   467→      } catch {\n   468→        // Ignore\n   469→      }\n   470→    }\n   471→    this.queueChannels.clear();\n   472→\n   473→    // Close publish channel\n   474→    if (this.publishChannel) {\n   475→      try {\n   476→        await this.publishChannel.close();\n   477→      } catch {\n   478→        // Ignore\n   479→      }\n   480→      this.publishChannel = null;\n   481→    }\n   482→\n   483→    // Close connection\n   484→    if (this.connection) {\n   485→      try {\n   486→        await this.connection.close();\n   487→      } catch {\n   488→        // Ignore\n   489→      }\n   490→      this.connection = null;\n   491→    }\n   492→\n   493→    // Reset capabilities\n   494→    this.delayedExchangeAvailable = false;\n   495→    this._capabilities = {\n   496→      ...this._capabilities,\n   497→      delayedMessages: false,\n   498→    };\n   499→  }\n   500→\n   501→  private async setupDelayedExchange(namespace: string): Promise<void> {\n   502→    if (!this.connection) {\n   503→      return;\n   504→    }\n   505→\n   506→    // Default to disabled\n   507→    this.delayedExchangeAvailable = false;\n   508→\n   509→    const delayedExchange = this.getDelayedExchangeName(namespace);\n   510→    const connection = this.connection;\n   511→\n   512→    // Use a promise-based approach to ensure all error paths resolve cleanly\n   513→    // This prevents any error from propagating and affecting other channels\n   514→    return new Promise<void>((resolve) => {\n   515→      let resolved = false;\n   516→      const safeResolve = () => {\n   517→        if (!resolved) {\n   518→          resolved = true;\n   519→          resolve();\n   520→        }\n   521→      };\n   522→\n   523→      connection\n   524→        .createChannel()\n   525→        .then((probeChannel) => {\n   526→          // Handle channel errors - this fires when RabbitMQ closes the channel\n   527→          probeChannel.on('error', () => {\n   528→            safeResolve();\n   529→          });\n   530→\n   531→          // Handle channel close\n   532→          probeChannel.on('close', () => {\n   533→            safeResolve();\n   534→          });\n   535→\n   536→          // Try to declare a delayed exchange\n   537→          // This will fail if the plugin is not installed\n   538→          probeChannel\n   539→            .assertExchange(delayedExchange, 'x-delayed-message', {\n   540→              durable: true,\n   541→              arguments: { 'x-delayed-type': 'direct' },\n   542→            })\n   543→            .then(() => {\n   544→              this.delayedExchangeAvailable = true;\n   545→              this._capabilities = {\n   546→                ...this._capabilities,\n   547→                delayedMessages: true,\n   548→              };\n   549→              this.logger.debug(\n   550→                '[Matador] 🔌 Delayed message exchange plugin detected',\n   551→              );\n   552→              // Close the probe channel gracefully\n   553→              probeChannel.close().catch(() => {});\n   554→              safeResolve();\n   555→            })\n   556→            .catch(() => {\n   557→              // assertExchange failed - plugin not available\n   558→              // Channel is already closed by RabbitMQ, no need to close\n   559→              this.logger.warn(\n   560→                '[Matador] 🟡 RabbitMQ delayed message exchange plugin not available. ' +\n   561→                  'Delayed messages will not be supported.',\n   562→              );\n   563→              safeResolve();\n   564→            });\n   565→        })\n   566→        .catch(() => {\n   567→          // Failed to create channel - shouldn't happen but handle it\n   568→          safeResolve();\n   569→        });\n   570→    });\n   571→  }\n   572→\n   573→  private async assertWorkQueue(\n   574→    channel: Channel,\n   575→    topology: Topology,\n   576→    queueDef: QueueDefinition,\n   577→  ): Promise<void> {\n   578→    const queueName = queueDef.exact\n   579→      ? queueDef.name\n   580→      : `${topology.namespace}.${queueDef.name}`;\n   581→\n   582→    const queueOptions: Options.AssertQueue = {\n   583→      durable: true,\n   584→      arguments: {} as Record<string, unknown>,\n   585→    };\n   586→\n   587→    // Use quorum queues for durability\n   588→    if (this.config.quorumQueues && !queueDef.exact) {\n   589→      queueOptions.arguments['x-queue-type'] = 'quorum';\n   590→    }\n   591→\n   592→    // Set up dead-letter exchange routing\n   593→    const dlxExchange = this.getDLXExchangeName(topology.namespace);\n   594→    if (\n   595→      topology.deadLetter.unhandled.enabled ||\n   596→      topology.deadLetter.undeliverable.enabled\n   597→    ) {\n   598→      queueOptions.arguments['x-dead-letter-exchange'] = dlxExchange;\n   599→    }\n   600→\n   601→    // Enable priority if requested\n   602→    if (queueDef.priorities) {\n   603→      queueOptions.arguments['x-max-priority'] = 10;\n   604→    }\n   605→\n   606→    // Set consumer timeout if specified\n   607→    if (queueDef.consumerTimeout) {\n   608→      queueOptions.arguments['x-consumer-timeout'] = queueDef.consumerTimeout;\n   609→    }\n   610→\n   611→    await channel.assertQueue(queueName, queueOptions);\n   612→\n   613→    // Bind queue to main exchange\n   614→    const mainExchange = this.getMainExchangeName(topology.namespace);\n   615→    await channel.bindQueue(queueName, mainExchange, queueName);\n   616→\n   617→    // Bind to delayed exchange if available\n   618→    if (this.delayedExchangeAvailable) {\n   619→      const delayedExchange = this.getDelayedExchangeName(topology.namespace);\n   620→      await channel.bindQueue(queueName, delayedExchange, queueName);\n   621→    }\n   622→\n   623→    // Create retry queue if retry is enabled\n   624→    if (topology.retry.enabled) {\n   625→      await this.assertRetryQueue(channel, topology, queueName);\n   626→    }\n   627→  }\n   628→\n   629→  private async assertRetryQueue(\n   630→    channel: Channel,\n   631→    topology: Topology,\n   632→    workQueueName: string,\n   633→  ): Promise<void> {\n   634→    const retryQueueName = `${workQueueName}.retry`;\n   635→    const mainExchange = this.getMainExchangeName(topology.namespace);\n   636→\n   637→    const retryQueueOptions: Options.AssertQueue = {\n   638→      durable: true,\n   639→      arguments: {\n   640→        'x-dead-letter-exchange': mainExchange,\n   641→        'x-dead-letter-routing-key': workQueueName,\n   642→        'x-message-ttl': topology.retry.defaultDelayMs,\n   643→      } as Record<string, unknown>,\n   644→    };\n   645→\n   646→    if (this.config.quorumQueues) {\n   647→      retryQueueOptions.arguments['x-queue-type'] = 'quorum';\n   648→    }\n   649→\n   650→    await channel.assertQueue(retryQueueName, retryQueueOptions);\n   651→    await channel.bindQueue(retryQueueName, mainExchange, retryQueueName);\n   652→  }\n   653→\n   654→  private async assertDeadLetterQueues(\n   655→    channel: Channel,\n   656→    topology: Topology,\n   657→    dlqType: 'unhandled' | 'undeliverable',\n   658→  ): Promise<void> {\n   659→    const dlxExchange = this.getDLXExchangeName(topology.namespace);\n   660→    const dlConfig = topology.deadLetter[dlqType];\n   661→\n   662→    for (const queueDef of topology.queues) {\n   663→      if (queueDef.exact) continue;\n   664→\n   665→      const workQueueName = `${topology.namespace}.${queueDef.name}`;\n   666→      const dlqName = `${workQueueName}.${dlqType}`;\n   667→\n   668→      const dlqOptions: Options.AssertQueue = {\n   669→        durable: true,\n   670→        arguments: {} as Record<string, unknown>,\n   671→      };\n   672→\n   673→      if (dlConfig.maxLength) {\n   674→        dlqOptions.arguments['x-max-length'] = dlConfig.maxLength;\n   675→      }\n   676→\n   677→      // DLQs use classic queues (not quorum) for simplicity\n   678→      await channel.assertQueue(dlqName, dlqOptions);\n   679→      await channel.bindQueue(dlqName, dlxExchange, dlqName);\n   680→    }\n   681→  }\n   682→\n   683→  private getMainExchangeName(namespace: string): string {\n   684→    return `${namespace}.exchange`;\n   685→  }\n   686→\n   687→  private getDLXExchangeName(namespace: string): string {\n   688→    return `${namespace}.dlx`;\n   689→  }\n   690→\n   691→  private getDelayedExchangeName(namespace: string): string {\n   692→    return `${namespace}.delayed`;\n   693→  }\n   694→\n   695→  private getAttemptNumber(msg: ConsumeMessage): number {\n   696→    const headerValue = msg.properties.headers?.['x-matador-attempts'];\n   697→    if (typeof headerValue === 'number') {\n   698→      return headerValue;\n   699→    }\n   700→    // Check for x-death header (native DLX redelivery count)\n   701→    const xDeath = msg.properties.headers?.['x-death'];\n   702→    if (Array.isArray(xDeath) && xDeath.length > 0) {\n   703→      const deathCount = xDeath.reduce(\n   704→        (sum: number, death: { count?: number }) => sum + (death.count ?? 0),\n   705→        0,\n   706→      );\n   707→      return deathCount + 1;\n   708→    }\n   709→    return 1;\n   710→  }\n   711→}\n   712→\n   713→/**\n   714→ * Creates a new RabbitMQ transport instance.\n   715→ */\n   716→export function createRabbitMQTransport(\n   717→  config: RabbitMQTransportConfig,\n   718→): RabbitMQTransport {\n   719→  return new RabbitMQTransport(config);\n   720→}\n   721→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-05T11:48:58.162Z"
        },
        {
          "type": "assistant",
          "text": "Let me also read the pipeline and types to understand the full picture:",
          "timestamp": "2025-12-05T11:49:03.940Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/pipeline/pipeline.ts"
          },
          "timestamp": "2025-12-05T11:49:04.770Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/types/index.ts"
          },
          "timestamp": "2025-12-05T11:49:05.217Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/schema/types.ts"
          },
          "timestamp": "2025-12-05T11:49:05.785Z"
        },
        {
          "type": "user",
          "text": "     1→import type { Codec } from '../codec/index.js';\n     2→import { CodecDecodeError } from '../codec/index.js';\n     3→import type { SafeHooks } from '../hooks/index.js';\n     4→import type { RetryDecision, RetryPolicy } from '../retry/index.js';\n     5→import type { SchemaRegistry } from '../schema/index.js';\n     6→import type { MessageReceipt, Transport } from '../transport/index.js';\n     7→import type { Envelope, SubscriberDefinition } from '../types/index.js';\n     8→\n     9→/**\n    10→ * Configuration for the processing pipeline.\n    11→ */\n    12→export interface PipelineConfig {\n    13→  readonly transport: Transport;\n    14→  readonly schema: SchemaRegistry;\n    15→  readonly codec: Codec;\n    16→  readonly retryPolicy: RetryPolicy;\n    17→  readonly hooks: SafeHooks;\n    18→}\n    19→\n    20→/**\n    21→ * Result of pipeline processing.\n    22→ */\n    23→export interface ProcessResult {\n    24→  readonly success: boolean;\n    25→  readonly envelope?: Envelope | undefined;\n    26→  readonly subscriber?: SubscriberDefinition | undefined;\n    27→  readonly error?: Error | undefined;\n    28→  readonly decision?: RetryDecision | undefined;\n    29→  readonly durationMs: number;\n    30→}\n    31→\n    32→/**\n    33→ * Processing pipeline for incoming messages.\n    34→ *\n    35→ * Handles the complete message lifecycle:\n    36→ * 1. Decode envelope from raw bytes\n    37→ * 2. Lookup subscriber from schema\n    38→ * 3. Execute subscriber callback with hooks\n    39→ * 4. Handle success/failure with retry policy\n    40→ */\n    41→export class ProcessingPipeline {\n    42→  private readonly transport: Transport;\n    43→  private readonly schema: SchemaRegistry;\n    44→  private readonly codec: Codec;\n    45→  private readonly retryPolicy: RetryPolicy;\n    46→  private readonly hooks: SafeHooks;\n    47→\n    48→  constructor(config: PipelineConfig) {\n    49→    this.transport = config.transport;\n    50→    this.schema = config.schema;\n    51→    this.codec = config.codec;\n    52→    this.retryPolicy = config.retryPolicy;\n    53→    this.hooks = config.hooks;\n    54→  }\n    55→\n    56→  /**\n    57→   * Processes a raw message from the transport.\n    58→   */\n    59→  async process(\n    60→    rawMessage: Uint8Array,\n    61→    receipt: MessageReceipt,\n    62→  ): Promise<ProcessResult> {\n    63→    const startTime = performance.now();\n    64→\n    65→    // 1. Decode envelope\n    66→    let envelope: Envelope;\n    67→    try {\n    68→      envelope = this.codec.decode(rawMessage);\n    69→    } catch (error) {\n    70→      const decodeError =\n    71→        error instanceof CodecDecodeError\n    72→          ? error\n    73→          : new CodecDecodeError('Unknown decode error', error);\n    74→\n    75→      await this.transport.complete(receipt);\n    76→      await this.hooks.onDecodeError({\n    77→        error: decodeError,\n    78→        rawMessage,\n    79→        sourceQueue: receipt.sourceQueue,\n    80→      });\n    81→\n    82→      return {\n    83→        success: false,\n    84→        error: decodeError,\n    85→        durationMs: performance.now() - startTime,\n    86→      };\n    87→    }\n    88→\n    89→    // 2. Lookup subscriber from schema\n    90→    const subscriberDef = this.schema.getSubscriberDefinition(\n    91→      envelope.docket.eventKey,\n    92→      envelope.docket.targetSubscriber,\n    93→    );\n    94→\n    95→    if (!subscriberDef) {\n    96→      await this.sendToDeadLetter(\n    97→        receipt,\n    98→        envelope,\n    99→        'unhandled',\n   100→        `subscriber \"${envelope.docket.targetSubscriber}\" not found for event \"${envelope.docket.eventKey}\"`,\n   101→      );\n   102→\n   103→      return {\n   104→        success: false,\n   105→        envelope,\n   106→        error: new Error('Subscriber not found in schema'),\n   107→        durationMs: performance.now() - startTime,\n   108→      };\n   109→    }\n   110→\n   111→    // Get executable subscriber\n   112→    const subscriber = this.schema.getExecutableSubscriber(\n   113→      envelope.docket.eventKey,\n   114→      envelope.docket.targetSubscriber,\n   115→    );\n   116→\n   117→    if (!subscriber) {\n   118→      // Subscriber is a stub (remote implementation)\n   119→      await this.sendToDeadLetter(\n   120→        receipt,\n   121→        envelope,\n   122→        'unhandled',\n   123→        `subscriber \"${envelope.docket.targetSubscriber}\" is a stub with no local implementation`,\n   124→      );\n   125→\n   126→      return {\n   127→        success: false,\n   128→        envelope,\n   129→        subscriber: subscriberDef,\n   130→        error: new Error('Subscriber is a stub'),\n   131→        durationMs: performance.now() - startTime,\n   132→      };\n   133→    }\n   134→\n   135→    // 3. Execute subscriber callback with hooks\n   136→    let result: unknown;\n   137→    let error: Error | undefined;\n   138→\n   139→    await this.hooks.onWorkerWrap(envelope, subscriberDef, async () => {\n   140→      await this.hooks.onWorkerBeforeProcess(envelope, subscriberDef);\n   141→\n   142→      try {\n   143→        result = await subscriber.callback(\n   144→          envelope.payload.data,\n   145→          envelope.docket,\n   146→        );\n   147→      } catch (e) {\n   148→        error = e instanceof Error ? e : new Error(String(e));\n   149→      }\n   150→    });\n   151→\n   152→    const durationMs = performance.now() - startTime;\n   153→\n   154→    // 4. Handle success\n   155→    if (!error) {\n   156→      await this.transport.complete(receipt);\n   157→      await this.hooks.onWorkerSuccess({\n   158→        envelope,\n   159→        subscriber: subscriberDef,\n   160→        result,\n   161→        durationMs,\n   162→      });\n   163→\n   164→      return {\n   165→        success: true,\n   166→        envelope,\n   167→        subscriber: subscriberDef,\n   168→        durationMs,\n   169→      };\n   170→    }\n   171→\n   172→    // 5. Handle failure - consult retry policy\n   173→    const decision = this.retryPolicy.shouldRetry({\n   174→      envelope,\n   175→      error,\n   176→      subscriber: subscriberDef,\n   177→      receipt,\n   178→    });\n   179→\n   180→    // Update envelope with error info\n   181→    envelope.docket.lastError = error.message;\n   182→    envelope.docket.firstError ??= error.message;\n   183→\n   184→    await this.handleRetryDecision(receipt, envelope, decision);\n   185→\n   186→    await this.hooks.onWorkerError({\n   187→      envelope,\n   188→      subscriber: subscriberDef,\n   189→      error,\n   190→      durationMs,\n   191→      decision,\n   192→    });\n   193→\n   194→    return {\n   195→      success: false,\n   196→      envelope,\n   197→      subscriber: subscriberDef,\n   198→      error,\n   199→      decision,\n   200→      durationMs,\n   201→    };\n   202→  }\n   203→\n   204→  private async handleRetryDecision(\n   205→    receipt: MessageReceipt,\n   206→    envelope: Envelope,\n   207→    decision: RetryDecision,\n   208→  ): Promise<void> {\n   209→    switch (decision.action) {\n   210→      case 'retry': {\n   211→        // Increment attempts and schedule retry\n   212→        envelope.attempts++;\n   213→        envelope.scheduledFor = new Date(\n   214→          Date.now() + decision.delay,\n   215→        ).toISOString();\n   216→\n   217→        await this.transport.send(receipt.sourceQueue, envelope, {\n   218→          delay: decision.delay,\n   219→        });\n   220→        await this.transport.complete(receipt);\n   221→        break;\n   222→      }\n   223→\n   224→      case 'dead-letter': {\n   225→        await this.sendToDeadLetter(\n   226→          receipt,\n   227→          envelope,\n   228→          decision.queue,\n   229→          decision.reason,\n   230→        );\n   231→        break;\n   232→      }\n   233→\n   234→      case 'discard': {\n   235→        await this.transport.complete(receipt);\n   236→        break;\n   237→      }\n   238→    }\n   239→  }\n   240→\n   241→  private async sendToDeadLetter(\n   242→    receipt: MessageReceipt,\n   243→    envelope: Envelope,\n   244→    dlqName: string,\n   245→    reason: string,\n   246→  ): Promise<void> {\n   247→    envelope.docket.originalQueue ??= receipt.sourceQueue;\n   248→\n   249→    if (this.transport.sendToDeadLetter) {\n   250→      await this.transport.sendToDeadLetter(receipt, dlqName, envelope, reason);\n   251→    } else {\n   252→      // Manual: send to DLQ then complete original\n   253→      const fullDlqName = `${receipt.sourceQueue}.${dlqName}`;\n   254→      await this.transport.send(fullDlqName, envelope);\n   255→      await this.transport.complete(receipt);\n   256→    }\n   257→  }\n   258→}\n   259→\n   260→/**\n   261→ * Creates a new processing pipeline.\n   262→ */\n   263→export function createPipeline(config: PipelineConfig): ProcessingPipeline {\n   264→  return new ProcessingPipeline(config);\n   265→}\n   266→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-05T11:49:06.061Z"
        },
        {
          "type": "user",
          "text": "     1→export type {\n     2→  DeliveryMode,\n     3→  Idempotency,\n     4→  Importance,\n     5→  ValidationError,\n     6→  ValidationResult,\n     7→} from './common.js';\n     8→export { invalidResult, validResult } from './common.js';\n     9→\n    10→export type {\n    11→  CreateEnvelopeOptions,\n    12→  Docket,\n    13→  Envelope,\n    14→  EnvelopePayload,\n    15→} from './envelope.js';\n    16→export { createEnvelope } from './envelope.js';\n    17→\n    18→export type {\n    19→  Event,\n    20→  EventClass,\n    21→  EventData,\n    22→  EventOptions,\n    23→  EventStatic,\n    24→} from './event.js';\n    25→export { BaseEvent } from './event.js';\n    26→\n    27→export type {\n    28→  AnySubscriber,\n    29→  Subscriber,\n    30→  SubscriberCallback,\n    31→  SubscriberDefinition,\n    32→  SubscriberOptions,\n    33→  SubscriberStub,\n    34→} from './subscriber.js';\n    35→export {\n    36→  createSubscriber,\n    37→  createSubscriberStub,\n    38→  isSubscriber,\n    39→  isSubscriberStub,\n    40→} from './subscriber.js';\n    41→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-05T11:49:06.062Z"
        },
        {
          "type": "user",
          "text": "     1→import type { AnySubscriber, EventClass } from '../types/index.js';\n     2→\n     3→/**\n     4→ * Schema entry for a single event type.\n     5→ */\n     6→export interface SchemaEntry<T = unknown> {\n     7→  /** The event class */\n     8→  readonly eventClass: EventClass<T>;\n     9→\n    10→  /** Subscribers for this event */\n    11→  readonly subscribers: readonly AnySubscriber<T>[];\n    12→}\n    13→\n    14→/**\n    15→ * Matador schema mapping event keys to their definitions.\n    16→ * This is the type-safe way to define event-subscriber relationships.\n    17→ */\n    18→export type MatadorSchema = {\n    19→  readonly [eventKey: string]: SchemaEntry;\n    20→};\n    21→\n    22→/**\n    23→ * Options for schema registration.\n    24→ */\n    25→export interface RegisterOptions {\n    26→  /** Override existing registration if present */\n    27→  readonly override?: boolean;\n    28→}\n    29→\n    30→/**\n    31→ * Result of schema validation.\n    32→ */\n    33→export interface SchemaValidationResult {\n    34→  readonly valid: boolean;\n    35→  readonly issues: readonly SchemaIssue[];\n    36→}\n    37→\n    38→/**\n    39→ * Individual schema issue.\n    40→ */\n    41→export interface SchemaIssue {\n    42→  readonly severity: 'error' | 'warning';\n    43→  readonly eventKey: string;\n    44→  readonly message: string;\n    45→}\n    46→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-05T11:49:06.062Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/retry/standard-policy.ts"
          },
          "timestamp": "2025-12-05T11:49:11.331Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/core/matador.ts"
          },
          "timestamp": "2025-12-05T11:49:11.836Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/types/event.ts"
          },
          "timestamp": "2025-12-05T11:49:12.279Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/types/subscriber.ts"
          },
          "timestamp": "2025-12-05T11:49:12.616Z"
        },
        {
          "type": "user",
          "text": "     1→import { isAssertionError, isDoRetry, isDontRetry } from '../errors/index.js';\n     2→import type { RetryContext, RetryDecision, RetryPolicy } from './policy.js';\n     3→\n     4→/**\n     5→ * Configuration for the standard retry policy.\n     6→ */\n     7→export interface StandardRetryPolicyConfig {\n     8→  /** Maximum number of attempts before dead-lettering */\n     9→  readonly maxAttempts: number;\n    10→\n    11→  /** Base delay between retries in milliseconds */\n    12→  readonly baseDelay: number;\n    13→\n    14→  /** Maximum delay between retries in milliseconds */\n    15→  readonly maxDelay: number;\n    16→\n    17→  /** Multiplier for exponential backoff */\n    18→  readonly backoffMultiplier: number;\n    19→}\n    20→\n    21→/**\n    22→ * Default configuration values.\n    23→ */\n    24→export const defaultRetryConfig: StandardRetryPolicyConfig = {\n    25→  maxAttempts: 3,\n    26→  baseDelay: 1000,\n    27→  maxDelay: 300000, // 5 minutes\n    28→  backoffMultiplier: 2,\n    29→};\n    30→\n    31→/**\n    32→ * Standard retry policy implementing Matador v1 behavior.\n    33→ *\n    34→ * Decision logic:\n    35→ * 1. EventAssertionError → dead-letter (never retry)\n    36→ * 2. DontRetry → dead-letter (explicit no-retry)\n    37→ * 3. DoRetry → retry if under max attempts\n    38→ * 4. Max attempts exceeded → dead-letter\n    39→ * 5. Non-idempotent subscriber on redelivery → dead-letter\n    40→ * 6. Default → retry with exponential backoff\n    41→ */\n    42→export class StandardRetryPolicy implements RetryPolicy {\n    43→  private readonly config: StandardRetryPolicyConfig;\n    44→\n    45→  constructor(config: Partial<StandardRetryPolicyConfig> = {}) {\n    46→    this.config = { ...defaultRetryConfig, ...config };\n    47→  }\n    48→\n    49→  shouldRetry(context: RetryContext): RetryDecision {\n    50→    const { error, subscriber, receipt } = context;\n    51→    const errorMessage = error.message;\n    52→\n    53→    // 1. Assertion errors never retry\n    54→    if (isAssertionError(error)) {\n    55→      return {\n    56→        action: 'dead-letter',\n    57→        queue: 'undeliverable',\n    58→        reason: `assertion error: ${errorMessage}`,\n    59→      };\n    60→    }\n    61→\n    62→    // 2. Explicit no-retry\n    63→    if (isDontRetry(error)) {\n    64→      return {\n    65→        action: 'dead-letter',\n    66→        queue: 'undeliverable',\n    67→        reason: errorMessage,\n    68→      };\n    69→    }\n    70→\n    71→    // 3. Explicit retry request\n    72→    if (isDoRetry(error)) {\n    73→      if (receipt.attemptNumber >= this.config.maxAttempts) {\n    74→        return {\n    75→          action: 'dead-letter',\n    76→          queue: 'undeliverable',\n    77→          reason: `max attempts exceeded (${this.config.maxAttempts}) with forced retry`,\n    78→        };\n    79→      }\n    80→      return {\n    81→        action: 'retry',\n    82→        delay: this.getDelay(context),\n    83→      };\n    84→    }\n    85→\n    86→    // 4. Max attempts exceeded\n    87→    if (receipt.attemptNumber >= this.config.maxAttempts) {\n    88→      return {\n    89→        action: 'dead-letter',\n    90→        queue: 'undeliverable',\n    91→        reason: `max attempts exceeded (${this.config.maxAttempts})`,\n    92→      };\n    93→    }\n    94→\n    95→    // 5. Non-idempotent subscriber on redelivery\n    96→    if (receipt.redelivered && subscriber.idempotent === 'no') {\n    97→      return {\n    98→        action: 'dead-letter',\n    99→        queue: 'undeliverable',\n   100→        reason: 'non-idempotent subscriber cannot be retried after redelivery',\n   101→      };\n   102→    }\n   103→\n   104→    // 6. Default: retry with backoff\n   105→    return {\n   106→      action: 'retry',\n   107→      delay: this.getDelay(context),\n   108→    };\n   109→  }\n   110→\n   111→  getDelay(context: RetryContext): number {\n   112→    const attempt = context.receipt.attemptNumber;\n   113→    const delay =\n   114→      this.config.baseDelay *\n   115→      Math.pow(this.config.backoffMultiplier, attempt - 1);\n   116→    return Math.min(delay, this.config.maxDelay);\n   117→  }\n   118→}\n   119→\n   120→/**\n   121→ * Creates a new standard retry policy.\n   122→ */\n   123→export function createRetryPolicy(\n   124→  config?: Partial<StandardRetryPolicyConfig>,\n   125→): StandardRetryPolicy {\n   126→  return new StandardRetryPolicy(config);\n   127→}\n   128→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-05T11:49:12.858Z"
        },
        {
          "type": "user",
          "text": "     1→import type { Codec } from '../codec/index.js';\n     2→import { createJsonCodec } from '../codec/index.js';\n     3→import type { MatadorHooks } from '../hooks/index.js';\n     4→import { createSafeHooks } from '../hooks/index.js';\n     5→import { createPipeline } from '../pipeline/index.js';\n     6→import type { RetryPolicy } from '../retry/index.js';\n     7→import { createRetryPolicy } from '../retry/index.js';\n     8→import { createSchemaRegistry } from '../schema/index.js';\n     9→import type { Topology } from '../topology/index.js';\n    10→import { getQualifiedQueueName } from '../topology/index.js';\n    11→import type { Subscription, Transport } from '../transport/index.js';\n    12→import type {\n    13→  AnySubscriber,\n    14→  Event,\n    15→  EventClass,\n    16→  EventOptions,\n    17→} from '../types/index.js';\n    18→import type { DispatchResult } from './fanout.js';\n    19→import { createFanoutEngine } from './fanout.js';\n    20→import type { HandlersState, ShutdownConfig } from './shutdown.js';\n    21→import { createShutdownManager } from './shutdown.js';\n    22→\n    23→/**\n    24→ * Configuration for Matador.\n    25→ */\n    26→export interface MatadorConfig {\n    27→  /** Transport for message delivery */\n    28→  readonly transport: Transport;\n    29→\n    30→  /** Topology configuration */\n    31→  readonly topology: Topology;\n    32→\n    33→  /** Queues to consume from (empty = no consumption) */\n    34→  readonly consumeFrom?: readonly string[] | undefined;\n    35→\n    36→  /** Custom hooks */\n    37→  readonly hooks?: MatadorHooks | undefined;\n    38→\n    39→  /** Custom codec (defaults to JSON) */\n    40→  readonly codec?: Codec | undefined;\n    41→\n    42→  /** Custom retry policy */\n    43→  readonly retryPolicy?: RetryPolicy | undefined;\n    44→\n    45→  /** Shutdown configuration */\n    46→  readonly shutdownConfig?: Partial<ShutdownConfig> | undefined;\n    47→}\n    48→\n    49→/**\n    50→ * Matador - Transport-agnostic event processing library.\n    51→ *\n    52→ * Main orchestrator that wires together:\n    53→ * - Transport: Message delivery\n    54→ * - Schema: Event-subscriber registry\n    55→ * - Pipeline: Message processing\n    56→ * - Fanout: Event dispatch\n    57→ * - Shutdown: Graceful termination\n    58→ */\n    59→export class Matador {\n    60→  private readonly transport: Transport;\n    61→  private readonly topology: Topology;\n    62→  private readonly schema;\n    63→  private readonly codec: Codec;\n    64→  private readonly retryPolicy: RetryPolicy;\n    65→  private readonly hooks;\n    66→  private readonly pipeline;\n    67→  private readonly fanout;\n    68→  private readonly shutdownManager;\n    69→  private readonly consumeFrom: readonly string[];\n    70→  private readonly subscriptions: Subscription[] = [];\n    71→  private started = false;\n    72→\n    73→  constructor(config: MatadorConfig) {\n    74→    this.transport = config.transport;\n    75→    this.topology = config.topology;\n    76→    this.consumeFrom = config.consumeFrom ?? [];\n    77→\n    78→    // Initialize components\n    79→    this.schema = createSchemaRegistry();\n    80→    this.codec = config.codec ?? createJsonCodec();\n    81→    this.retryPolicy = config.retryPolicy ?? createRetryPolicy();\n    82→    this.hooks = createSafeHooks(config.hooks);\n    83→\n    84→    // Create pipeline\n    85→    this.pipeline = createPipeline({\n    86→      transport: this.transport,\n    87→      schema: this.schema,\n    88→      codec: this.codec,\n    89→      retryPolicy: this.retryPolicy,\n    90→      hooks: this.hooks,\n    91→    });\n    92→\n    93→    // Create fanout engine\n    94→    const defaultQueue = this.topology.queues[0]?.name ?? 'default';\n    95→    this.fanout = createFanoutEngine({\n    96→      transport: this.transport,\n    97→      schema: this.schema,\n    98→      hooks: this.hooks,\n    99→      namespace: this.topology.namespace,\n   100→      defaultQueue,\n   101→    });\n   102→\n   103→    // Create shutdown manager\n   104→    this.shutdownManager = createShutdownManager(\n   105→      () => this.fanout.eventsBeingEnqueuedCount,\n   106→      () => this.stopReceiving(),\n   107→      () => this.transport.disconnect(),\n   108→      config.shutdownConfig,\n   109→    );\n   110→  }\n   111→\n   112→  /**\n   113→   * Registers an event class with its subscribers.\n   114→   */\n   115→  register<T>(\n   116→    eventClass: EventClass<T>,\n   117→    subscribers: readonly AnySubscriber<T>[],\n   118→  ): this {\n   119→    this.schema.register(eventClass, subscribers);\n   120→    return this;\n   121→  }\n   122→\n   123→  /**\n   124→   * Starts Matador - connects transport and begins consuming.\n   125→   */\n   126→  async start(): Promise<void> {\n   127→    if (this.started) {\n   128→      throw new Error('Matador is already started');\n   129→    }\n   130→\n   131→    // Validate schema\n   132→    const validation = this.schema.validate();\n   133→    if (!validation.valid) {\n   134→      const errors = validation.issues.filter((i) => i.severity === 'error');\n   135→      throw new Error(\n   136→        `Schema validation failed: ${errors.map((e) => e.message).join(', ')}`,\n   137→      );\n   138→    }\n   139→\n   140→    // Connect transport\n   141→    await this.transport.connect();\n   142→\n   143→    // Apply topology\n   144→    await this.transport.applyTopology(this.topology);\n   145→\n   146→    // Subscribe to queues\n   147→    for (const queueName of this.consumeFrom) {\n   148→      const qualifiedName = getQualifiedQueueName(\n   149→        this.topology.namespace,\n   150→        queueName,\n   151→      );\n   152→      const queueDef = this.topology.queues.find((q) => q.name === queueName);\n   153→\n   154→      const subscription = await this.transport.subscribe(\n   155→        qualifiedName,\n   156→        async (envelope, receipt) => {\n   157→          this.shutdownManager.incrementProcessing();\n   158→          try {\n   159→            const rawMessage = this.codec.encode(envelope);\n   160→            await this.pipeline.process(rawMessage, receipt);\n   161→          } finally {\n   162→            this.shutdownManager.decrementProcessing();\n   163→          }\n   164→        },\n   165→        queueDef?.concurrency !== undefined\n   166→          ? { concurrency: queueDef.concurrency }\n   167→          : undefined,\n   168→      );\n   169→\n   170→      this.subscriptions.push(subscription);\n   171→    }\n   172→\n   173→    this.started = true;\n   174→  }\n   175→\n   176→  /**\n   177→   * Dispatches an event to all registered subscribers.\n   178→   */\n   179→  async dispatch<T>(\n   180→    event: Event<T>,\n   181→    options?: EventOptions,\n   182→  ): Promise<DispatchResult> {\n   183→    if (!this.started) {\n   184→      throw new Error('Matador is not started');\n   185→    }\n   186→\n   187→    if (!this.shutdownManager.isEnqueueAllowed) {\n   188→      throw new Error('Matador is shutting down, dispatch not allowed');\n   189→    }\n   190→\n   191→    // Get event class from the event's constructor\n   192→    const eventClass = event.constructor as EventClass<T>;\n   193→\n   194→    return this.fanout.dispatch(eventClass, event, options);\n   195→  }\n   196→\n   197→  /**\n   198→   * Gets current handler state.\n   199→   */\n   200→  getHandlersState(): HandlersState {\n   201→    return this.shutdownManager.getHandlersState();\n   202→  }\n   203→\n   204→  /**\n   205→   * Checks if Matador is idle (no processing or enqueuing).\n   206→   */\n   207→  isIdle(): boolean {\n   208→    return this.shutdownManager.getHandlersState().isIdle;\n   209→  }\n   210→\n   211→  /**\n   212→   * Waits for all handlers to become idle.\n   213→   */\n   214→  async waitForIdle(timeoutMs = 30000): Promise<boolean> {\n   215→    const deadline = Date.now() + timeoutMs;\n   216→\n   217→    while (!this.isIdle()) {\n   218→      if (Date.now() > deadline) {\n   219→        return false;\n   220→      }\n   221→      await new Promise((resolve) => setTimeout(resolve, 100));\n   222→    }\n   223→\n   224→    return true;\n   225→  }\n   226→\n   227→  /**\n   228→   * Gracefully shuts down Matador.\n   229→   */\n   230→  async shutdown(): Promise<void> {\n   231→    if (!this.started) {\n   232→      return;\n   233→    }\n   234→\n   235→    await this.shutdownManager.shutdown();\n   236→    this.started = false;\n   237→  }\n   238→\n   239→  /**\n   240→   * Checks if transport is connected.\n   241→   */\n   242→  isConnected(): boolean {\n   243→    return this.transport.isConnected();\n   244→  }\n   245→\n   246→  private async stopReceiving(): Promise<void> {\n   247→    for (const subscription of this.subscriptions) {\n   248→      await subscription.unsubscribe();\n   249→    }\n   250→    this.subscriptions.length = 0;\n   251→  }\n   252→}\n   253→\n   254→/**\n   255→ * Creates a new Matador instance.\n   256→ */\n   257→export function createMatador(config: MatadorConfig): Matador {\n   258→  return new Matador(config);\n   259→}\n   260→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-05T11:49:12.858Z"
        },
        {
          "type": "user",
          "text": "     1→/**\n     2→ * Static properties required on Event classes for schema registration.\n     3→ */\n     4→export interface EventStatic<T = unknown> {\n     5→  /** Unique routing key for the event */\n     6→  readonly key: string;\n     7→\n     8→  /** Human-readable description of the event */\n     9→  readonly description: string;\n    10→\n    11→  /** Alternative names/keys for backwards compatibility */\n    12→  readonly aliases?: readonly string[];\n    13→\n    14→  /** Create an instance from data (for deserialization) */\n    15→  new (data: T, before?: T | undefined): Event<T>;\n    16→}\n    17→\n    18→/**\n    19→ * Base interface for all events.\n    20→ * Events represent something that happened in the system.\n    21→ */\n    22→export interface Event<T = unknown> {\n    23→  /** The event data/payload */\n    24→  readonly data: T;\n    25→\n    26→  /** Previous state for change-type events */\n    27→  readonly before?: T | undefined;\n    28→}\n    29→\n    30→/**\n    31→ * Options for dispatching an event.\n    32→ */\n    33→export interface EventOptions {\n    34→  /** Delay processing by this many milliseconds */\n    35→  readonly delayMs?: number | undefined;\n    36→\n    37→  /** Correlation ID for request tracing */\n    38→  readonly correlationId?: string | undefined;\n    39→\n    40→  /**\n    41→   * Event-specific metadata to include in the docket.\n    42→   * This metadata will be merged with universal metadata from the\n    43→   * loadUniversalMetadata hook, with these values taking precedence\n    44→   * when keys conflict.\n    45→   */\n    46→  readonly metadata?: Record<string, unknown> | undefined;\n    47→}\n    48→\n    49→/**\n    50→ * Abstract base class for creating event types.\n    51→ * Extend this class to define custom events.\n    52→ *\n    53→ * @example\n    54→ * ```typescript\n    55→ * class UserCreatedEvent extends BaseEvent<{ userId: string; email: string }> {\n    56→ *   static readonly key = 'user.created';\n    57→ *   static readonly description = 'Fired when a new user is created';\n    58→ * }\n    59→ * ```\n    60→ */\n    61→export abstract class BaseEvent<T> implements Event<T> {\n    62→  static readonly key: string;\n    63→  static readonly description: string;\n    64→  static readonly aliases?: readonly string[];\n    65→\n    66→  readonly before?: T | undefined;\n    67→\n    68→  constructor(\n    69→    public readonly data: T,\n    70→    before?: T | undefined,\n    71→  ) {\n    72→    this.before = before;\n    73→  }\n    74→}\n    75→\n    76→/**\n    77→ * Type helper to extract the data type from an event class.\n    78→ */\n    79→export type EventData<E extends Event<unknown>> = E extends Event<infer T>\n    80→  ? T\n    81→  : never;\n    82→\n    83→/**\n    84→ * Type helper to get the event class type.\n    85→ */\n    86→export type EventClass<T = unknown> = EventStatic<T> &\n    87→  (new (\n    88→    data: T,\n    89→    before?: T | undefined,\n    90→  ) => Event<T>);\n    91→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-05T11:49:12.859Z"
        },
        {
          "type": "user",
          "text": "     1→import type { Idempotency, Importance } from './common.js';\n     2→import type { Docket } from './envelope.js';\n     3→import type { EventClass } from './event.js';\n     4→\n     5→/**\n     6→ * Callback function executed when an event is received.\n     7→ */\n     8→export type SubscriberCallback<T = unknown> = (\n     9→  data: T,\n    10→  docket: Docket,\n    11→) => Promise<void> | void;\n    12→\n    13→/**\n    14→ * Configuration options for a subscriber.\n    15→ */\n    16→export interface SubscriberOptions {\n    17→  /** Route this subscriber's events to a specific queue */\n    18→  readonly targetQueue?: string | undefined;\n    19→\n    20→  /** Idempotency declaration for retry handling */\n    21→  readonly idempotent?: Idempotency | undefined;\n    22→\n    23→  /** Importance level for monitoring and alerting */\n    24→  readonly importance?: Importance | undefined;\n    25→\n    26→  /** Feature flag function to conditionally enable/disable the subscriber */\n    27→  readonly enabled?: (() => boolean | Promise<boolean>) | undefined;\n    28→}\n    29→\n    30→/**\n    31→ * Full subscriber definition with callback.\n    32→ */\n    33→export interface Subscriber<T = unknown> extends SubscriberOptions {\n    34→  /** Human-readable name for the subscriber */\n    35→  readonly name: string;\n    36→\n    37→  /** The event class this subscriber handles */\n    38→  readonly eventClass: EventClass<T>;\n    39→\n    40→  /** Callback function to execute when event is received */\n    41→  readonly callback: SubscriberCallback<T>;\n    42→}\n    43→\n    44→/**\n    45→ * Subscriber stub for multi-codebase scenarios where subscriber implementation\n    46→ * is in a remote service. Declares the subscriber contract without providing\n    47→ * the callback.\n    48→ */\n    49→export interface SubscriberStub<T = unknown> extends SubscriberOptions {\n    50→  /** Human-readable name for the subscriber */\n    51→  readonly name: string;\n    52→\n    53→  /** The event class this subscriber handles */\n    54→  readonly eventClass: EventClass<T>;\n    55→\n    56→  /** Indicates this is a stub without implementation */\n    57→  readonly isStub: true;\n    58→}\n    59→\n    60→/**\n    61→ * Union type for any subscriber definition (full or stub).\n    62→ */\n    63→export type AnySubscriber<T = unknown> = Subscriber<T> | SubscriberStub<T>;\n    64→\n    65→/**\n    66→ * Type guard to check if a subscriber is a stub.\n    67→ */\n    68→export function isSubscriberStub<T>(\n    69→  subscriber: AnySubscriber<T>,\n    70→): subscriber is SubscriberStub<T> {\n    71→  return 'isStub' in subscriber && subscriber.isStub === true;\n    72→}\n    73→\n    74→/**\n    75→ * Type guard to check if a subscriber has a callback implementation.\n    76→ */\n    77→export function isSubscriber<T>(\n    78→  subscriber: AnySubscriber<T>,\n    79→): subscriber is Subscriber<T> {\n    80→  return 'callback' in subscriber && typeof subscriber.callback === 'function';\n    81→}\n    82→\n    83→/**\n    84→ * Creates a subscriber definition.\n    85→ */\n    86→export function createSubscriber<T>(\n    87→  name: string,\n    88→  eventClass: EventClass<T>,\n    89→  callback: SubscriberCallback<T>,\n    90→  options: SubscriberOptions = {},\n    91→): Subscriber<T> {\n    92→  return {\n    93→    name,\n    94→    eventClass,\n    95→    callback,\n    96→    idempotent: options.idempotent ?? 'unknown',\n    97→    importance: options.importance ?? 'should-investigate',\n    98→    ...(options.targetQueue !== undefined && {\n    99→      targetQueue: options.targetQueue,\n   100→    }),\n   101→    ...(options.enabled !== undefined && { enabled: options.enabled }),\n   102→  };\n   103→}\n   104→\n   105→/**\n   106→ * Creates a subscriber stub for remote implementations.\n   107→ */\n   108→export function createSubscriberStub<T>(\n   109→  name: string,\n   110→  eventClass: EventClass<T>,\n   111→  options: SubscriberOptions = {},\n   112→): SubscriberStub<T> {\n   113→  return {\n   114→    name,\n   115→    eventClass,\n   116→    isStub: true,\n   117→    idempotent: options.idempotent ?? 'unknown',\n   118→    importance: options.importance ?? 'should-investigate',\n   119→    ...(options.targetQueue !== undefined && {\n   120→      targetQueue: options.targetQueue,\n   121→    }),\n   122→    ...(options.enabled !== undefined && { enabled: options.enabled }),\n   123→  };\n   124→}\n   125→\n   126→/**\n   127→ * Definition interface used by the pipeline (excludes event class reference).\n   128→ */\n   129→export interface SubscriberDefinition {\n   130→  readonly name: string;\n   131→  readonly idempotent: Idempotency;\n   132→  readonly importance: Importance;\n   133→  readonly targetQueue?: string | undefined;\n   134→}\n   135→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-05T11:49:12.859Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/index.ts"
          },
          "timestamp": "2025-12-05T11:49:17.394Z"
        },
        {
          "type": "user",
          "text": "     1→// Core\n     2→export type {\n     3→  DispatchError,\n     4→  DispatchResult,\n     5→  FanoutConfig,\n     6→  HandlersState,\n     7→  MatadorConfig,\n     8→  ShutdownConfig,\n     9→  ShutdownState,\n    10→} from './core/index.js';\n    11→export {\n    12→  createFanoutEngine,\n    13→  createMatador,\n    14→  createShutdownManager,\n    15→  defaultShutdownConfig,\n    16→  FanoutEngine,\n    17→  Matador,\n    18→  ShutdownManager,\n    19→} from './core/index.js';\n    20→\n    21→// Types\n    22→export type {\n    23→  AnySubscriber,\n    24→  CreateEnvelopeOptions,\n    25→  DeliveryMode,\n    26→  Docket,\n    27→  Envelope,\n    28→  EnvelopePayload,\n    29→  Event,\n    30→  EventClass,\n    31→  EventData,\n    32→  EventOptions,\n    33→  EventStatic,\n    34→  Idempotency,\n    35→  Importance,\n    36→  Subscriber,\n    37→  SubscriberCallback,\n    38→  SubscriberDefinition,\n    39→  SubscriberOptions,\n    40→  SubscriberStub,\n    41→  ValidationError,\n    42→  ValidationResult,\n    43→} from './types/index.js';\n    44→export {\n    45→  BaseEvent,\n    46→  createEnvelope,\n    47→  createSubscriber,\n    48→  createSubscriberStub,\n    49→  invalidResult,\n    50→  isSubscriber,\n    51→  isSubscriberStub,\n    52→  validResult,\n    53→} from './types/index.js';\n    54→\n    55→// Transport\n    56→export type {\n    57→  ConnectFn,\n    58→  ConnectionManagerConfig,\n    59→  ConnectionState,\n    60→  DisconnectFn,\n    61→  MessageHandler,\n    62→  MessageReceipt,\n    63→  RabbitMQSendOptions,\n    64→  RabbitMQSubscribeOptions,\n    65→  RabbitMQTransportConfig,\n    66→  SendOptions,\n    67→  StateChangeCallback,\n    68→  SubscribeOptions,\n    69→  Subscription,\n    70→  Transport,\n    71→  TransportCapabilities,\n    72→  TransportSendOptions,\n    73→  TransportSubscribeOptions,\n    74→} from './transport/index.js';\n    75→export {\n    76→  ConnectionManager,\n    77→  createRabbitMQTransport,\n    78→  defaultConnectionConfig,\n    79→  hasNativeDeadLetter,\n    80→  MemoryTransport,\n    81→  RabbitMQTransport,\n    82→  supportsDeliveryMode,\n    83→  supportsDelayedMessages,\n    84→} from './transport/index.js';\n    85→\n    86→// Topology\n    87→export type {\n    88→  DeadLetterConfig,\n    89→  DeadLetterQueueConfig,\n    90→  QueueDefinition,\n    91→  QueueOptions,\n    92→  RetryConfig,\n    93→  Topology,\n    94→} from './topology/index.js';\n    95→export {\n    96→  createTopology,\n    97→  getDeadLetterQueueName,\n    98→  getQualifiedQueueName,\n    99→  getRetryQueueName,\n   100→  TopologyBuilder,\n   101→  TopologyValidationError,\n   102→} from './topology/index.js';\n   103→\n   104→// Codec\n   105→export type { Codec } from './codec/index.js';\n   106→export { CodecDecodeError, createJsonCodec, JsonCodec } from './codec/index.js';\n   107→\n   108→// Schema\n   109→export type {\n   110→  MatadorSchema,\n   111→  RegisterOptions,\n   112→  SchemaEntry,\n   113→  SchemaIssue,\n   114→  SchemaValidationResult,\n   115→} from './schema/index.js';\n   116→export {\n   117→  createSchemaRegistry,\n   118→  SchemaError,\n   119→  SchemaRegistry,\n   120→} from './schema/index.js';\n   121→\n   122→// Retry\n   123→export type {\n   124→  RetryContext,\n   125→  RetryDecision,\n   126→  RetryPolicy,\n   127→  StandardRetryPolicyConfig,\n   128→} from './retry/index.js';\n   129→export {\n   130→  createRetryPolicy,\n   131→  defaultRetryConfig,\n   132→  StandardRetryPolicy,\n   133→} from './retry/index.js';\n   134→\n   135→// Hooks\n   136→export type {\n   137→  DecodeErrorContext,\n   138→  EnqueueErrorContext,\n   139→  EnqueueSuccessContext,\n   140→  EnqueueWarningContext,\n   141→  Logger,\n   142→  MatadorHooks,\n   143→  WorkerErrorContext,\n   144→  WorkerExecuteFn,\n   145→  WorkerSuccessContext,\n   146→} from './hooks/index.js';\n   147→export { consoleLogger, createSafeHooks, SafeHooks } from './hooks/index.js';\n   148→\n   149→// Pipeline\n   150→export type { PipelineConfig, ProcessResult } from './pipeline/index.js';\n   151→export { createPipeline, ProcessingPipeline } from './pipeline/index.js';\n   152→\n   153→// Errors\n   154→export type { HasDescription } from './errors/index.js';\n   155→export {\n   156→  DontRetry,\n   157→  DoRetry,\n   158→  EventAssertionError,\n   159→  hasDescription,\n   160→  isAssertionError,\n   161→  isDontRetry,\n   162→  isDoRetry,\n   163→  RetryControlError,\n   164→} from './errors/index.js';\n   165→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-05T11:49:17.503Z"
        },
        {
          "type": "assistant",
          "text": "Now I have a complete picture. Let me create a comprehensive implementation plan and start implementing.",
          "timestamp": "2025-12-05T11:49:34.419Z"
        },
        {
          "type": "tool_use",
          "name": "TodoWrite",
          "input": {
            "todos": [
              {
                "activeForm": "Creating comprehensive named error classes",
                "content": "Create comprehensive named error classes with descriptions and resolution actions",
                "status": "in_progress"
              },
              {
                "activeForm": "Adding poison message detection for RabbitMQ",
                "content": "Add poison message detection for RabbitMQ transport",
                "status": "pending"
              },
              {
                "activeForm": "Implementing old schema system compatibility",
                "content": "Implement old schema system compatibility (MatadorSchema type with tuple format)",
                "status": "pending"
              }
            ]
          },
          "timestamp": "2025-12-05T11:49:34.674Z"
        },
        {
          "type": "user",
          "text": "Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable",
          "timestamp": "2025-12-05T11:49:34.780Z"
        },
        {
          "type": "assistant",
          "text": "Let me start by creating the comprehensive error classes file:",
          "timestamp": "2025-12-05T11:49:39.239Z"
        },
        {
          "type": "tool_use",
          "name": "Write",
          "input": {
            "content": "import type { HasDescription } from './has-description.js';\n\n/**\n * Base class for all Matador errors.\n * All errors have a unique name that appears in monitoring tools (e.g., DataDog)\n * and a description explaining the error and actions to resolve it.\n */\nexport abstract class MatadorError extends Error implements HasDescription {\n  abstract readonly description: string;\n\n  constructor(message: string) {\n    super(message);\n    this.name = this.constructor.name;\n  }\n}\n\n// ============================================================================\n// Lifecycle Errors\n// ============================================================================\n\n/**\n * Thrown when attempting to use Matador before calling start().\n */\nexport class NotStartedError extends MatadorError {\n  readonly description =\n    'Matador has not been started. ' +\n    'ACTION: Call matador.start() before dispatching events or performing other operations. ' +\n    'Ensure start() completes successfully before using other methods.';\n\n  constructor(operation = 'operation') {\n    super(\n      `Cannot perform ${operation}: Matador has not been started. Call start() first.`,\n    );\n  }\n}\n\n/**\n * Thrown when attempting to dispatch events during shutdown.\n */\nexport class ShutdownInProgressError extends MatadorError {\n  readonly description =\n    'Matador is shutting down and will not accept new events. ' +\n    'ACTION: Do not dispatch events after calling shutdown(). ' +\n    'If you need to send events, do so before initiating shutdown. ' +\n    'Consider implementing a pre-shutdown event flush if needed.';\n\n  constructor() {\n    super('Cannot dispatch events: Matador is shutting down.');\n  }\n}\n\n/**\n * Thrown when Matador is already started and start() is called again.\n */\nexport class AlreadyStartedError extends MatadorError {\n  readonly description =\n    'Matador has already been started and cannot be started again. ' +\n    'ACTION: Remove the duplicate start() call. ' +\n    'If you need to restart, call shutdown() first then start() again.';\n\n  constructor() {\n    super('Matador is already started. Call shutdown() before restarting.');\n  }\n}\n\n// ============================================================================\n// Transport Errors\n// ============================================================================\n\n/**\n * Thrown when a transport operation is attempted but the transport is not connected.\n */\nexport class TransportNotConnectedError extends MatadorError {\n  readonly description =\n    'The transport is not connected to the message broker. ' +\n    'ACTION: Ensure the transport is connected by calling transport.connect() or matador.start(). ' +\n    'Check that the broker (e.g., RabbitMQ) is running and accessible. ' +\n    'Verify connection settings (URL, credentials, network access).';\n\n  constructor(\n    public readonly transportName: string,\n    operation = 'operation',\n  ) {\n    super(\n      `Cannot perform ${operation}: Transport \"${transportName}\" is not connected. ` +\n        `Ensure connect() was called and the broker is accessible.`,\n    );\n  }\n}\n\n/**\n * Thrown when the transport has been closed (during shutdown).\n */\nexport class TransportClosedError extends MatadorError {\n  readonly description =\n    'The transport has been closed and will not accept new operations. ' +\n    'ACTION: This typically occurs during application shutdown. ' +\n    'If unexpected, check for early shutdown triggers. ' +\n    'Events sent after transport closure will be lost.';\n\n  constructor(public readonly transportName: string) {\n    super(\n      `Transport \"${transportName}\" has been closed and will not accept new operations.`,\n    );\n  }\n}\n\n/**\n * Thrown when all transports in a fallback chain fail.\n */\nexport class AllTransportsFailedError extends MatadorError {\n  readonly description =\n    'All transports failed to send the message. ' +\n    'ACTION: Check the health of all configured transports (primary and fallbacks). ' +\n    'Review the errors array for specific failure reasons. ' +\n    'Ensure at least one transport is properly configured and reachable. ' +\n    'Consider adding a MemoryTransport as a last-resort fallback.';\n\n  constructor(\n    public readonly queue: string,\n    public readonly errors: readonly Error[],\n  ) {\n    super(\n      `All transports failed to send message to queue \"${queue}\". ` +\n        `Errors: ${errors.map((e) => e.message).join('; ')}`,\n    );\n  }\n}\n\n/**\n * Thrown when delayed messages are requested but the plugin is not available.\n */\nexport class DelayedMessagesNotSupportedError extends MatadorError {\n  readonly description =\n    'Delayed messages were requested but the transport does not support them. ' +\n    'ACTION: For RabbitMQ, install the rabbitmq_delayed_message_exchange plugin. ' +\n    'Run: rabbitmq-plugins enable rabbitmq_delayed_message_exchange ' +\n    'Then restart RabbitMQ and reconnect. ' +\n    'Alternatively, remove delayMs from your event options if delays are not required.';\n\n  constructor(public readonly transportName: string) {\n    super(\n      `Delayed messages require the RabbitMQ delayed message exchange plugin. ` +\n        `Install rabbitmq_delayed_message_exchange or remove delayMs from event options.`,\n    );\n  }\n}\n\n// ============================================================================\n// Schema & Configuration Errors\n// ============================================================================\n\n/**\n * Thrown when an event is not registered in the schema.\n */\nexport class EventNotRegisteredError extends MatadorError {\n  readonly description =\n    'The event type is not registered in the schema. ' +\n    'ACTION: Register the event using matador.register(EventClass, subscribers) before dispatching. ' +\n    'If this occurs during message consumption, it may indicate schema drift between services. ' +\n    'Ensure all services have matching schema registrations for shared events.';\n\n  constructor(public readonly eventKey: string) {\n    super(\n      `Event \"${eventKey}\" is not registered in schema. ` +\n        `Register it using matador.register(EventClass, subscribers).`,\n    );\n  }\n}\n\n/**\n * Thrown when a subscriber is not found for an event.\n */\nexport class SubscriberNotRegisteredError extends MatadorError {\n  readonly description =\n    'The subscriber is not registered for this event in the schema. ' +\n    'ACTION: Ensure the subscriber is included in the registration for this event. ' +\n    'This may occur if: (1) The subscriber was removed from the schema but messages still exist, ' +\n    '(2) Schema drift between producer and consumer services, ' +\n    '(3) A deployment is in progress with different schema versions. ' +\n    'Check the dead-letter queue for affected messages.';\n\n  constructor(\n    public readonly subscriberName: string,\n    public readonly eventKey?: string,\n  ) {\n    super(\n      `Subscriber \"${subscriberName}\" is not registered` +\n        (eventKey ? ` for event \"${eventKey}\"` : '') +\n        '. Check schema registration.',\n    );\n  }\n}\n\n/**\n * Thrown when no subscribers exist for an event during fanout.\n */\nexport class NoSubscribersExistError extends MatadorError {\n  readonly description =\n    'The event has no subscribers registered. ' +\n    'ACTION: Register at least one subscriber for this event type. ' +\n    'If subscribers were intentionally removed, consider also removing the event dispatch. ' +\n    'Events without subscribers are not useful and may indicate configuration issues.';\n\n  constructor(public readonly eventKey: string) {\n    super(\n      `No subscribers registered for event \"${eventKey}\". ` +\n        `Add subscribers using matador.register(EventClass, [subscriber1, subscriber2]).`,\n    );\n  }\n}\n\n/**\n * Thrown when the schema configuration is invalid.\n */\nexport class InvalidSchemaError extends MatadorError {\n  readonly description =\n    'The schema configuration is invalid. ' +\n    'ACTION: Review the schema registration for issues. Common problems: ' +\n    '(1) Duplicate subscriber names for the same event, ' +\n    '(2) Missing required fields on event class (key, description), ' +\n    '(3) Invalid alias configuration. ' +\n    'Check the cause property for specific details.';\n\n  constructor(\n    message: string,\n    public readonly cause?: string,\n  ) {\n    super(`Invalid schema: ${message}` + (cause ? `. Cause: ${cause}` : ''));\n  }\n}\n\n/**\n * Thrown when a subscriber is a stub but is being processed locally.\n */\nexport class SubscriberIsStubError extends MatadorError {\n  readonly description =\n    'A SubscriberStub was registered in a consuming schema. ' +\n    'ACTION: SubscriberStubs should only be used in producer schemas to declare ' +\n    'that a subscriber exists in another service. ' +\n    'In the consumer service, provide a full Subscriber with a callback function. ' +\n    'Remove the stub from the consumer schema and add the actual implementation.';\n\n  constructor(public readonly subscriberName: string) {\n    super(\n      `Subscriber \"${subscriberName}\" is a stub and cannot be processed locally. ` +\n        `Replace with a full Subscriber implementation in the consumer schema.`,\n    );\n  }\n}\n\n/**\n * Thrown when a MemoryTransport tries to process a stub subscriber.\n */\nexport class MemoryTransportCannotProcessStubError extends MatadorError {\n  readonly description =\n    'The MemoryTransport cannot process events for SubscriberStubs. ' +\n    'ACTION: SubscriberStubs represent remote implementations that only RabbitMQ can route. ' +\n    'If using MemoryTransport for testing, provide mock implementations instead of stubs. ' +\n    'For production fallback scenarios, be aware that stub-targeted events will be dropped.';\n\n  constructor(public readonly subscriberName: string) {\n    super(\n      `MemoryTransport cannot process stub subscriber \"${subscriberName}\". ` +\n        `Stub subscribers require a distributed transport like RabbitMQ.`,\n    );\n  }\n}\n\n// ============================================================================\n// Queue Errors\n// ============================================================================\n\n/**\n * Thrown when a queue is not found or not created.\n */\nexport class QueueNotFoundError extends MatadorError {\n  readonly description =\n    'The specified queue does not exist or has not been created. ' +\n    'ACTION: Ensure the queue is defined in the topology configuration. ' +\n    'Call transport.applyTopology() or matador.start() to create queues. ' +\n    'Check that the queue name matches the topology definition.';\n\n  constructor(public readonly queueName: string) {\n    super(\n      `Queue \"${queueName}\" not found. ` +\n        `Ensure it is defined in topology and applyTopology() was called.`,\n    );\n  }\n}\n\n// ============================================================================\n// Event Validation Errors\n// ============================================================================\n\n/**\n * Thrown when an event is invalid or malformed.\n */\nexport class InvalidEventError extends MatadorError {\n  readonly description =\n    'The event is invalid or missing required fields. ' +\n    'ACTION: Ensure the event has all required properties. ' +\n    'Common issues: missing targetSubscriber during processing, ' +\n    'null/undefined data when the event type requires data, ' +\n    'malformed event structure from codec decode failure.';\n\n  constructor(\n    message: string,\n    public readonly cause?: string,\n  ) {\n    super(`Invalid event: ${message}` + (cause ? `. Cause: ${cause}` : ''));\n  }\n}\n\n// ============================================================================\n// Message Processing Errors\n// ============================================================================\n\n/**\n * Thrown when a message has been redelivered too many times (poison message).\n */\nexport class MessageMaybePoisonedError extends MatadorError {\n  readonly description =\n    'A message was redelivered multiple times without successful processing. ' +\n    'This usually indicates the message causes a crash or timeout during processing. ' +\n    'ACTION: (1) Check application logs for errors/crashes during message processing, ' +\n    '(2) Inspect the message in the dead-letter queue for malformed data, ' +\n    '(3) Review the subscriber code for bugs that cause crashes, ' +\n    '(4) Consider increasing processing timeout if the operation is legitimately slow. ' +\n    'This message will NOT be retried to prevent crash loops.';\n\n  constructor(\n    public readonly eventId: string,\n    public readonly deliveryCount: number,\n    public readonly maxDeliveries: number,\n  ) {\n    super(\n      `Message \"${eventId}\" delivered ${deliveryCount} times (max: ${maxDeliveries}). ` +\n        `Possible poison message - will not be retried.`,\n    );\n  }\n}\n\n/**\n * Thrown when a non-idempotent message cannot be retried after redelivery.\n */\nexport class IdempotentMessageCannotRetryError extends MatadorError {\n  readonly description =\n    'A non-idempotent subscriber received a redelivered message. ' +\n    'Retrying would risk duplicate side effects (e.g., double payments, duplicate emails). ' +\n    'ACTION: (1) Mark the subscriber as idempotent if it safely handles duplicates, ' +\n    '(2) Implement idempotency keys in the subscriber logic, ' +\n    '(3) Manually inspect and replay the message from the dead-letter queue after verification. ' +\n    'The message will be sent to the dead-letter queue for manual review.';\n\n  constructor(\n    public readonly eventId: string,\n    public readonly subscriberName: string,\n  ) {\n    super(\n      `Non-idempotent subscriber \"${subscriberName}\" cannot retry redelivered message \"${eventId}\". ` +\n        `Mark subscriber as idempotent='yes' or implement idempotency handling.`,\n    );\n  }\n}\n\n// ============================================================================\n// Timeout Errors\n// ============================================================================\n\n/**\n * Thrown when an operation times out.\n */\nexport class TimeoutError extends MatadorError {\n  readonly description =\n    'An operation timed out before completing. ' +\n    'ACTION: (1) Increase the timeout if the operation legitimately needs more time, ' +\n    '(2) Optimize the operation to complete faster, ' +\n    '(3) Check for deadlocks or blocking operations, ' +\n    '(4) Verify external service dependencies are responsive.';\n\n  constructor(\n    public readonly operation: string,\n    public readonly timeoutMs: number,\n  ) {\n    super(`Operation \"${operation}\" timed out after ${timeoutMs}ms.`);\n  }\n}\n\n// ============================================================================\n// Type Guards\n// ============================================================================\n\nexport function isMatadorError(error: unknown): error is MatadorError {\n  return error instanceof MatadorError;\n}\n\nexport function isNotStartedError(error: unknown): error is NotStartedError {\n  return error instanceof NotStartedError;\n}\n\nexport function isTransportNotConnectedError(\n  error: unknown,\n): error is TransportNotConnectedError {\n  return error instanceof TransportNotConnectedError;\n}\n\nexport function isEventNotRegisteredError(\n  error: unknown,\n): error is EventNotRegisteredError {\n  return error instanceof EventNotRegisteredError;\n}\n\nexport function isSubscriberNotRegisteredError(\n  error: unknown,\n): error is SubscriberNotRegisteredError {\n  return error instanceof SubscriberNotRegisteredError;\n}\n\nexport function isMessageMaybePoisonedError(\n  error: unknown,\n): error is MessageMaybePoisonedError {\n  return error instanceof MessageMaybePoisonedError;\n}\n\nexport function isIdempotentMessageCannotRetryError(\n  error: unknown,\n): error is IdempotentMessageCannotRetryError {\n  return error instanceof IdempotentMessageCannotRetryError;\n}\n",
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/errors/matador-errors.ts"
          },
          "timestamp": "2025-12-05T11:50:36.307Z"
        }
      ],
      "total_additions": 1136,
      "total_deletions": 183,
      "accepted_lines": 1068,
      "overriden_lines": 0
    }
  }
}
