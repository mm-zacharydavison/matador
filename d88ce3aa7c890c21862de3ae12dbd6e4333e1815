packages/matador/examples/event.ts
  6611448a8b696bcd 1-26
packages/matador/cli.ts
  6611448a8b696bcd 1-18,20-26,29-156,158-178,180-182,184-203,205-252,254-333
packages/matador/examples/order-event.json
  6611448a8b696bcd 1-19
packages/matador/examples/config.ts
  6611448a8b696bcd 1-11,13,16-107
packages/matador/package.json
  6611448a8b696bcd 25-27
---
{
  "schema_version": "authorship/3.0.0",
  "git_ai_version": "1.0.22",
  "base_commit_sha": "d88ce3aa7c890c21862de3ae12dbd6e4333e1815",
  "prompts": {
    "6611448a8b696bcd": {
      "agent_id": {
        "tool": "claude",
        "id": "5c7137a3-2631-4225-8ffa-71d539d433bb",
        "model": "claude-opus-4-5-20251101"
      },
      "human_author": "Zachary Davison <zachary.davison@meetsmore.com>",
      "messages": [
        {
          "type": "user",
          "text": "old matador had a cli utility for sending events and testing your schema\n\n# CLI\n\nMatador provides a `cli` utility for quick local testing of your Matador config.\n\nYou can call it via `./cli.ts <path-to-config-file> <path-to-event-file>`.\n\nIf all you need to do is quickly send a test event, you can use `yarn send-test-event`\n\n> ğŸ“ Note: You need `bun` installed.\n\nrecreate this functionality, it's useful\nwe don't need yarn compatibility of course, keep using bun",
          "timestamp": "2025-12-05T12:13:35.894Z"
        },
        {
          "type": "assistant",
          "text": "I'll explore the codebase to understand the current structure and how events are handled, then recreate the CLI utility.",
          "timestamp": "2025-12-05T12:13:49.222Z"
        },
        {
          "type": "tool_use",
          "name": "Task",
          "input": {
            "description": "Explore Matador codebase",
            "prompt": "Explore the Matador codebase to understand:\n1. The overall project structure (it's a monorepo)\n2. How events and handlers are configured\n3. What types/interfaces exist for events and configuration\n4. How the Matador client works\n\nFocus on finding:\n- The main Matador package location\n- Event handler types and interfaces\n- Configuration types\n- How events are published/consumed\n\nReturn a summary of the key files and their purposes, along with the relevant types/interfaces I'll need for creating a CLI tool.",
            "subagent_type": "Explore"
          },
          "timestamp": "2025-12-05T12:13:53.344Z"
        },
        {
          "type": "assistant",
          "text": "Excellent! Now I have a good understanding of the codebase. Let me check the package.json for scripts and the exports from the main package:",
          "timestamp": "2025-12-05T12:18:26.308Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/package.json"
          },
          "timestamp": "2025-12-05T12:18:26.870Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/src/index.ts"
          },
          "timestamp": "2025-12-05T12:18:27.275Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/package.json"
          },
          "timestamp": "2025-12-05T12:18:27.687Z"
        },
        {
          "type": "user",
          "text": "     1â†’{\n     2â†’  \"name\": \"@meetsmore/matador-v2\",\n     3â†’  \"version\": \"2.0.0\",\n     4â†’  \"description\": \"Transport-agnostic event processing library\",\n     5â†’  \"type\": \"module\",\n     6â†’  \"main\": \"./dist/index.js\",\n     7â†’  \"types\": \"./dist/index.d.ts\",\n     8â†’  \"exports\": {\n     9â†’    \".\": {\n    10â†’      \"import\": \"./dist/index.js\",\n    11â†’      \"types\": \"./dist/index.d.ts\"\n    12â†’    }\n    13â†’  },\n    14â†’  \"scripts\": {\n    15â†’    \"build\": \"bun build ./src/index.ts --outdir ./dist --target node && tsc --emitDeclarationOnly\",\n    16â†’    \"test\": \"bun test\",\n    17â†’    \"test:watch\": \"bun test --watch\",\n    18â†’    \"test:integration\": \"bun test --grep integration\",\n    19â†’    \"lint\": \"bunx biome check .\",\n    20â†’    \"lint:fix\": \"bunx biome check . --fix\",\n    21â†’    \"typecheck\": \"tsc --noEmit\",\n    22â†’    \"clean\": \"rm -rf dist\"\n    23â†’  },\n    24â†’  \"dependencies\": {\n    25â†’    \"amqplib\": \"^0.10.4\"\n    26â†’  },\n    27â†’  \"devDependencies\": {\n    28â†’    \"@testcontainers/rabbitmq\": \"^10.16.0\",\n    29â†’    \"@types/amqplib\": \"^0.10.5\",\n    30â†’    \"testcontainers\": \"^10.16.0\"\n    31â†’  },\n    32â†’  \"peerDependencies\": {\n    33â†’    \"zod\": \"^3.0.0\"\n    34â†’  },\n    35â†’  \"peerDependenciesMeta\": {\n    36â†’    \"zod\": {\n    37â†’      \"optional\": true\n    38â†’    }\n    39â†’  },\n    40â†’  \"engines\": {\n    41â†’    \"node\": \">=18.0.0\"\n    42â†’  },\n    43â†’  \"keywords\": [\n    44â†’    \"events\",\n    45â†’    \"messaging\",\n    46â†’    \"queue\",\n    47â†’    \"rabbitmq\",\n    48â†’    \"bullmq\",\n    49â†’    \"kafka\",\n    50â†’    \"transport\"\n    51â†’  ],\n    52â†’  \"license\": \"MIT\"\n    53â†’}\n    54â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-05T12:18:27.814Z"
        },
        {
          "type": "user",
          "text": "     1â†’// Core\n     2â†’export type {\n     3â†’  DispatchError,\n     4â†’  DispatchResult,\n     5â†’  FanoutConfig,\n     6â†’  HandlersState,\n     7â†’  MatadorConfig,\n     8â†’  ShutdownConfig,\n     9â†’  ShutdownState,\n    10â†’} from './core/index.js';\n    11â†’export {\n    12â†’  createFanoutEngine,\n    13â†’  createMatador,\n    14â†’  createShutdownManager,\n    15â†’  defaultShutdownConfig,\n    16â†’  FanoutEngine,\n    17â†’  Matador,\n    18â†’  ShutdownManager,\n    19â†’} from './core/index.js';\n    20â†’\n    21â†’// Types\n    22â†’export type {\n    23â†’  AnySubscriber,\n    24â†’  CreateEnvelopeOptions,\n    25â†’  DeliveryMode,\n    26â†’  Docket,\n    27â†’  Envelope,\n    28â†’  EnvelopePayload,\n    29â†’  Event,\n    30â†’  EventClass,\n    31â†’  EventData,\n    32â†’  EventOptions,\n    33â†’  EventStatic,\n    34â†’  Idempotency,\n    35â†’  Importance,\n    36â†’  Subscriber,\n    37â†’  SubscriberCallback,\n    38â†’  SubscriberDefinition,\n    39â†’  SubscriberOptions,\n    40â†’  SubscriberStub,\n    41â†’  ValidationError,\n    42â†’  ValidationResult,\n    43â†’} from './types/index.js';\n    44â†’export {\n    45â†’  BaseEvent,\n    46â†’  createEnvelope,\n    47â†’  createSubscriber,\n    48â†’  createSubscriberStub,\n    49â†’  invalidResult,\n    50â†’  isSubscriber,\n    51â†’  isSubscriberStub,\n    52â†’  validResult,\n    53â†’} from './types/index.js';\n    54â†’\n    55â†’// Transport\n    56â†’export type {\n    57â†’  ConnectFn,\n    58â†’  ConnectionManagerConfig,\n    59â†’  ConnectionState,\n    60â†’  DisconnectFn,\n    61â†’  MessageHandler,\n    62â†’  MessageReceipt,\n    63â†’  RabbitMQSendOptions,\n    64â†’  RabbitMQSubscribeOptions,\n    65â†’  RabbitMQTransportConfig,\n    66â†’  SendOptions,\n    67â†’  StateChangeCallback,\n    68â†’  SubscribeOptions,\n    69â†’  Subscription,\n    70â†’  Transport,\n    71â†’  TransportCapabilities,\n    72â†’  TransportSendOptions,\n    73â†’  TransportSubscribeOptions,\n    74â†’} from './transport/index.js';\n    75â†’export {\n    76â†’  ConnectionManager,\n    77â†’  createRabbitMQTransport,\n    78â†’  defaultConnectionConfig,\n    79â†’  hasNativeDeadLetter,\n    80â†’  MemoryTransport,\n    81â†’  RabbitMQTransport,\n    82â†’  supportsDeliveryMode,\n    83â†’  supportsDelayedMessages,\n    84â†’} from './transport/index.js';\n    85â†’\n    86â†’// Topology\n    87â†’export type {\n    88â†’  DeadLetterConfig,\n    89â†’  DeadLetterQueueConfig,\n    90â†’  QueueDefinition,\n    91â†’  QueueOptions,\n    92â†’  RetryConfig,\n    93â†’  Topology,\n    94â†’} from './topology/index.js';\n    95â†’export {\n    96â†’  createTopology,\n    97â†’  getDeadLetterQueueName,\n    98â†’  getQualifiedQueueName,\n    99â†’  getRetryQueueName,\n   100â†’  TopologyBuilder,\n   101â†’  TopologyValidationError,\n   102â†’} from './topology/index.js';\n   103â†’\n   104â†’// Codec\n   105â†’export type { Codec } from './codec/index.js';\n   106â†’export { CodecDecodeError, createJsonCodec, JsonCodec } from './codec/index.js';\n   107â†’\n   108â†’// Schema\n   109â†’export type {\n   110â†’  MatadorSchema,\n   111â†’  RegisterOptions,\n   112â†’  SchemaEntry,\n   113â†’  SchemaEntryTuple,\n   114â†’  SchemaIssue,\n   115â†’  SchemaValidationResult,\n   116â†’} from './schema/index.js';\n   117â†’export {\n   118â†’  createSchemaRegistry,\n   119â†’  isSchemaEntryTuple,\n   120â†’  SchemaError,\n   121â†’  SchemaRegistry,\n   122â†’} from './schema/index.js';\n   123â†’\n   124â†’// Retry\n   125â†’export type {\n   126â†’  RetryContext,\n   127â†’  RetryDecision,\n   128â†’  RetryPolicy,\n   129â†’  StandardRetryPolicyConfig,\n   130â†’} from './retry/index.js';\n   131â†’export {\n   132â†’  createRetryPolicy,\n   133â†’  defaultRetryConfig,\n   134â†’  StandardRetryPolicy,\n   135â†’} from './retry/index.js';\n   136â†’\n   137â†’// Hooks\n   138â†’export type {\n   139â†’  DecodeErrorContext,\n   140â†’  EnqueueErrorContext,\n   141â†’  EnqueueSuccessContext,\n   142â†’  EnqueueWarningContext,\n   143â†’  Logger,\n   144â†’  MatadorHooks,\n   145â†’  WorkerErrorContext,\n   146â†’  WorkerExecuteFn,\n   147â†’  WorkerSuccessContext,\n   148â†’} from './hooks/index.js';\n   149â†’export { consoleLogger, createSafeHooks, SafeHooks } from './hooks/index.js';\n   150â†’\n   151â†’// Pipeline\n   152â†’export type { PipelineConfig, ProcessResult } from './pipeline/index.js';\n   153â†’export { createPipeline, ProcessingPipeline } from './pipeline/index.js';\n   154â†’\n   155â†’// Errors\n   156â†’export type { HasDescription } from './errors/index.js';\n   157â†’export {\n   158â†’  // Retry control errors\n   159â†’  DontRetry,\n   160â†’  DoRetry,\n   161â†’  EventAssertionError,\n   162â†’  RetryControlError,\n   163â†’  isAssertionError,\n   164â†’  isDontRetry,\n   165â†’  isDoRetry,\n   166â†’\n   167â†’  // Matador errors with descriptions\n   168â†’  MatadorError,\n   169â†’  isMatadorError,\n   170â†’\n   171â†’  // Lifecycle errors\n   172â†’  NotStartedError,\n   173â†’  isNotStartedError,\n   174â†’  ShutdownInProgressError,\n   175â†’\n   176â†’  // Transport errors\n   177â†’  TransportNotConnectedError,\n   178â†’  isTransportNotConnectedError,\n   179â†’  TransportClosedError,\n   180â†’  TransportSendError,\n   181â†’  AllTransportsFailedError,\n   182â†’  DelayedMessagesNotSupportedError,\n   183â†’\n   184â†’  // Schema & configuration errors\n   185â†’  EventNotRegisteredError,\n   186â†’  isEventNotRegisteredError,\n   187â†’  SubscriberNotRegisteredError,\n   188â†’  isSubscriberNotRegisteredError,\n   189â†’  NoSubscribersExistError,\n   190â†’  InvalidSchemaError,\n   191â†’  SubscriberIsStubError,\n   192â†’  MemoryTransportCannotProcessStubError,\n   193â†’\n   194â†’  // Queue errors\n   195â†’  QueueNotFoundError,\n   196â†’\n   197â†’  // Event validation errors\n   198â†’  InvalidEventError,\n   199â†’\n   200â†’  // Message processing errors\n   201â†’  MessageMaybePoisonedError,\n   202â†’  isMessageMaybePoisonedError,\n   203â†’  IdempotentMessageCannotRetryError,\n   204â†’  isIdempotentMessageCannotRetryError,\n   205â†’\n   206â†’  // Timeout errors\n   207â†’  TimeoutError,\n   208â†’\n   209â†’  // Utility\n   210â†’  hasDescription,\n   211â†’} from './errors/index.js';\n   212â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-05T12:18:27.814Z"
        },
        {
          "type": "user",
          "text": "     1â†’{\n     2â†’  \"name\": \"matador-monorepo\",\n     3â†’  \"private\": true,\n     4â†’  \"workspaces\": [\"packages/*\"],\n     5â†’  \"scripts\": {\n     6â†’    \"build\": \"bun run --filter '*' build\",\n     7â†’    \"test\": \"bun run --filter '*' test\",\n     8â†’    \"lint\": \"bunx biome check .\",\n     9â†’    \"lint:fix\": \"bunx biome check . --fix\",\n    10â†’    \"typecheck\": \"bun run --filter '*' typecheck\",\n    11â†’    \"clean\": \"bun run --filter '*' clean\"\n    12â†’  },\n    13â†’  \"devDependencies\": {\n    14â†’    \"@biomejs/biome\": \"^1.9.0\",\n    15â†’    \"@types/bun\": \"^1.1.0\",\n    16â†’    \"typescript\": \"^5.6.0\"\n    17â†’  }\n    18â†’}\n    19â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-05T12:18:27.815Z"
        },
        {
          "type": "assistant",
          "text": "Let me check the test files to see how events and configs are typically structured:",
          "timestamp": "2025-12-05T12:18:36.408Z"
        },
        {
          "type": "tool_use",
          "name": "Glob",
          "input": {
            "pattern": "packages/matador/test/**/*.ts"
          },
          "timestamp": "2025-12-05T12:18:36.679Z"
        },
        {
          "type": "user",
          "text": "/home/z/Desktop/work/matador/packages/matador/test/integration/matador.integration.test.ts\n/home/z/Desktop/work/matador/packages/matador/test/e2e/rabbitmq-transport.e2e.test.ts\n/home/z/Desktop/work/matador/packages/matador/test/e2e/transport-compliance.e2e.test.ts\n/home/z/Desktop/work/matador/packages/matador/test/e2e/fallback-transport.e2e.test.ts",
          "timestamp": "2025-12-05T12:18:36.792Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/matador/packages/matador/test/integration/matador.integration.test.ts"
          },
          "timestamp": "2025-12-05T12:18:41.136Z"
        },
        {
          "type": "user",
          "text": "     1â†’import { afterEach, beforeEach, describe, expect, it } from 'bun:test';\n     2â†’import {\n     3â†’  BaseEvent,\n     4â†’  DoRetry,\n     5â†’  DontRetry,\n     6â†’  type Matador,\n     7â†’  MemoryTransport,\n     8â†’  createMatador,\n     9â†’  createSubscriber,\n    10â†’  createTopology,\n    11â†’} from '../../src/index.js';\n    12â†’\n    13â†’class UserCreatedEvent extends BaseEvent<{ userId: string; email: string }> {\n    14â†’  static readonly key = 'user.created';\n    15â†’  static readonly description = 'Fired when a new user is created';\n    16â†’}\n    17â†’\n    18â†’class OrderPlacedEvent extends BaseEvent<{\n    19â†’  orderId: string;\n    20â†’  amount: number;\n    21â†’  userId: string;\n    22â†’}> {\n    23â†’  static readonly key = 'order.placed';\n    24â†’  static readonly description = 'Fired when an order is placed';\n    25â†’}\n    26â†’\n    27â†’class PaymentProcessedEvent extends BaseEvent<{\n    28â†’  paymentId: string;\n    29â†’  orderId: string;\n    30â†’  status: 'success' | 'failed';\n    31â†’}> {\n    32â†’  static readonly key = 'payment.processed';\n    33â†’  static readonly description = 'Fired when a payment is processed';\n    34â†’}\n    35â†’\n    36â†’describe('Matador Integration Tests', () => {\n    37â†’  let transport: MemoryTransport;\n    38â†’  let matador: Matador;\n    39â†’\n    40â†’  beforeEach(() => {\n    41â†’    transport = new MemoryTransport();\n    42â†’  });\n    43â†’\n    44â†’  afterEach(async () => {\n    45â†’    if (matador) {\n    46â†’      await matador.shutdown();\n    47â†’    }\n    48â†’  });\n    49â†’\n    50â†’  describe('full message flow', () => {\n    51â†’    it('should dispatch event and process successfully', async () => {\n    52â†’      const processedUsers: string[] = [];\n    53â†’\n    54â†’      const topology = createTopology()\n    55â†’        .withNamespace('int-test')\n    56â†’        .addQueue('events')\n    57â†’        .build();\n    58â†’\n    59â†’      const subscriber = createSubscriber(\n    60â†’        'process-user',\n    61â†’        UserCreatedEvent,\n    62â†’        async (data) => {\n    63â†’          processedUsers.push(data.userId);\n    64â†’        },\n    65â†’      );\n    66â†’\n    67â†’      matador = createMatador({\n    68â†’        transport,\n    69â†’        topology,\n    70â†’        consumeFrom: ['events'],\n    71â†’      }).register(UserCreatedEvent, [subscriber]);\n    72â†’\n    73â†’      await matador.start();\n    74â†’\n    75â†’      const event = new UserCreatedEvent({\n    76â†’        userId: 'user-123',\n    77â†’        email: 'test@example.com',\n    78â†’      });\n    79â†’\n    80â†’      const result = await matador.dispatch(event);\n    81â†’\n    82â†’      // Wait for processing\n    83â†’      await matador.waitForIdle(5000);\n    84â†’\n    85â†’      expect(result.subscribersDispatched).toBe(1);\n    86â†’      expect(result.errors).toHaveLength(0);\n    87â†’      expect(processedUsers).toContain('user-123');\n    88â†’    });\n    89â†’\n    90â†’    it('should fan out to multiple subscribers', async () => {\n    91â†’      const notifications: string[] = [];\n    92â†’      const analytics: string[] = [];\n    93â†’      const emails: string[] = [];\n    94â†’\n    95â†’      const topology = createTopology()\n    96â†’        .withNamespace('int-fanout')\n    97â†’        .addQueue('events')\n    98â†’        .build();\n    99â†’\n   100â†’      const notifySub = createSubscriber(\n   101â†’        'send-notification',\n   102â†’        UserCreatedEvent,\n   103â†’        async (data) => {\n   104â†’          notifications.push(data.userId);\n   105â†’        },\n   106â†’      );\n   107â†’\n   108â†’      const analyticsSub = createSubscriber(\n   109â†’        'track-analytics',\n   110â†’        UserCreatedEvent,\n   111â†’        async (data) => {\n   112â†’          analytics.push(data.userId);\n   113â†’        },\n   114â†’      );\n   115â†’\n   116â†’      const emailSub = createSubscriber(\n   117â†’        'send-welcome-email',\n   118â†’        UserCreatedEvent,\n   119â†’        async (data) => {\n   120â†’          emails.push(data.email);\n   121â†’        },\n   122â†’      );\n   123â†’\n   124â†’      matador = createMatador({\n   125â†’        transport,\n   126â†’        topology,\n   127â†’        consumeFrom: ['events'],\n   128â†’      }).register(UserCreatedEvent, [notifySub, analyticsSub, emailSub]);\n   129â†’\n   130â†’      await matador.start();\n   131â†’\n   132â†’      const event = new UserCreatedEvent({\n   133â†’        userId: 'user-456',\n   134â†’        email: 'fan@out.com',\n   135â†’      });\n   136â†’\n   137â†’      const result = await matador.dispatch(event);\n   138â†’      await matador.waitForIdle(5000);\n   139â†’\n   140â†’      expect(result.subscribersDispatched).toBe(3);\n   141â†’      expect(notifications).toContain('user-456');\n   142â†’      expect(analytics).toContain('user-456');\n   143â†’      expect(emails).toContain('fan@out.com');\n   144â†’    });\n   145â†’\n   146â†’    it('should handle multiple event types', async () => {\n   147â†’      const users: string[] = [];\n   148â†’      const orders: string[] = [];\n   149â†’\n   150â†’      const topology = createTopology()\n   151â†’        .withNamespace('int-multi-event')\n   152â†’        .addQueue('events')\n   153â†’        .build();\n   154â†’\n   155â†’      const userSub = createSubscriber(\n   156â†’        'process-user',\n   157â†’        UserCreatedEvent,\n   158â†’        async (data) => {\n   159â†’          users.push(data.userId);\n   160â†’        },\n   161â†’      );\n   162â†’\n   163â†’      const orderSub = createSubscriber(\n   164â†’        'process-order',\n   165â†’        OrderPlacedEvent,\n   166â†’        async (data) => {\n   167â†’          orders.push(data.orderId);\n   168â†’        },\n   169â†’      );\n   170â†’\n   171â†’      matador = createMatador({\n   172â†’        transport,\n   173â†’        topology,\n   174â†’        consumeFrom: ['events'],\n   175â†’      })\n   176â†’        .register(UserCreatedEvent, [userSub])\n   177â†’        .register(OrderPlacedEvent, [orderSub]);\n   178â†’\n   179â†’      await matador.start();\n   180â†’\n   181â†’      await matador.dispatch(\n   182â†’        new UserCreatedEvent({ userId: 'u1', email: 'u1@test.com' }),\n   183â†’      );\n   184â†’      await matador.dispatch(\n   185â†’        new OrderPlacedEvent({ orderId: 'o1', amount: 100, userId: 'u1' }),\n   186â†’      );\n   187â†’      await matador.dispatch(\n   188â†’        new UserCreatedEvent({ userId: 'u2', email: 'u2@test.com' }),\n   189â†’      );\n   190â†’\n   191â†’      await matador.waitForIdle(5000);\n   192â†’\n   193â†’      expect(users).toEqual(['u1', 'u2']);\n   194â†’      expect(orders).toEqual(['o1']);\n   195â†’    });\n   196â†’  });\n   197â†’\n   198â†’  describe('retry behavior', () => {\n   199â†’    it('should retry failed subscribers', async () => {\n   200â†’      let attempts = 0;\n   201â†’      const maxAttempts = 3;\n   202â†’\n   203â†’      const topology = createTopology()\n   204â†’        .withNamespace('int-retry')\n   205â†’        .addQueue('events')\n   206â†’        .withRetry({ enabled: true, defaultDelayMs: 10, maxDelayMs: 100 })\n   207â†’        .build();\n   208â†’\n   209â†’      const subscriber = createSubscriber(\n   210â†’        'flaky-subscriber',\n   211â†’        UserCreatedEvent,\n   212â†’        async () => {\n   213â†’          attempts++;\n   214â†’          if (attempts < maxAttempts) {\n   215â†’            throw new DoRetry('Temporary failure');\n   216â†’          }\n   217â†’        },\n   218â†’      );\n   219â†’\n   220â†’      matador = createMatador({\n   221â†’        transport,\n   222â†’        topology,\n   223â†’        consumeFrom: ['events'],\n   224â†’        retry: {\n   225â†’          maxAttempts: 5,\n   226â†’          baseDelayMs: 10,\n   227â†’          maxDelayMs: 100,\n   228â†’        },\n   229â†’      }).register(UserCreatedEvent, [subscriber]);\n   230â†’\n   231â†’      await matador.start();\n   232â†’\n   233â†’      await matador.dispatch(\n   234â†’        new UserCreatedEvent({ userId: 'retry-user', email: 'retry@test.com' }),\n   235â†’      );\n   236â†’\n   237â†’      // Wait for retries\n   238â†’      await waitFor(() => attempts >= maxAttempts, 5000);\n   239â†’\n   240â†’      expect(attempts).toBe(maxAttempts);\n   241â†’    });\n   242â†’\n   243â†’    it('should not retry when DontRetry is thrown', async () => {\n   244â†’      let attempts = 0;\n   245â†’\n   246â†’      const topology = createTopology()\n   247â†’        .withNamespace('int-dont-retry')\n   248â†’        .addQueue('events')\n   249â†’        .build();\n   250â†’\n   251â†’      const subscriber = createSubscriber(\n   252â†’        'permanent-fail-subscriber',\n   253â†’        UserCreatedEvent,\n   254â†’        async () => {\n   255â†’          attempts++;\n   256â†’          throw new DontRetry('Permanent failure');\n   257â†’        },\n   258â†’      );\n   259â†’\n   260â†’      matador = createMatador({\n   261â†’        transport,\n   262â†’        topology,\n   263â†’        consumeFrom: ['events'],\n   264â†’      }).register(UserCreatedEvent, [subscriber]);\n   265â†’\n   266â†’      await matador.start();\n   267â†’\n   268â†’      await matador.dispatch(\n   269â†’        new UserCreatedEvent({\n   270â†’          userId: 'no-retry-user',\n   271â†’          email: 'noretry@test.com',\n   272â†’        }),\n   273â†’      );\n   274â†’\n   275â†’      await matador.waitForIdle(2000);\n   276â†’\n   277â†’      // Should only try once\n   278â†’      expect(attempts).toBe(1);\n   279â†’    });\n   280â†’  });\n   281â†’\n   282â†’  describe('correlation ID propagation', () => {\n   283â†’    it('should propagate correlation ID through event chain', async () => {\n   284â†’      const correlationIds: string[] = [];\n   285â†’\n   286â†’      const topology = createTopology()\n   287â†’        .withNamespace('int-correlation')\n   288â†’        .addQueue('events')\n   289â†’        .build();\n   290â†’\n   291â†’      const subscriber = createSubscriber(\n   292â†’        'track-correlation',\n   293â†’        UserCreatedEvent,\n   294â†’        async (_data, docket) => {\n   295â†’          if (docket.correlationId) {\n   296â†’            correlationIds.push(docket.correlationId);\n   297â†’          }\n   298â†’        },\n   299â†’      );\n   300â†’\n   301â†’      matador = createMatador({\n   302â†’        transport,\n   303â†’        topology,\n   304â†’        consumeFrom: ['events'],\n   305â†’      }).register(UserCreatedEvent, [subscriber]);\n   306â†’\n   307â†’      await matador.start();\n   308â†’\n   309â†’      await matador.dispatch(\n   310â†’        new UserCreatedEvent({ userId: 'corr-user', email: 'corr@test.com' }),\n   311â†’        { correlationId: 'request-abc-123' },\n   312â†’      );\n   313â†’\n   314â†’      await matador.waitForIdle(2000);\n   315â†’\n   316â†’      expect(correlationIds).toContain('request-abc-123');\n   317â†’    });\n   318â†’  });\n   319â†’\n   320â†’  describe('metadata handling', () => {\n   321â†’    it('should include metadata in docket', async () => {\n   322â†’      const receivedMetadata: Record<string, unknown>[] = [];\n   323â†’\n   324â†’      const topology = createTopology()\n   325â†’        .withNamespace('int-metadata')\n   326â†’        .addQueue('events')\n   327â†’        .build();\n   328â†’\n   329â†’      const subscriber = createSubscriber(\n   330â†’        'capture-metadata',\n   331â†’        UserCreatedEvent,\n   332â†’        async (_data, docket) => {\n   333â†’          if (docket.metadata) {\n   334â†’            receivedMetadata.push(docket.metadata);\n   335â†’          }\n   336â†’        },\n   337â†’      );\n   338â†’\n   339â†’      matador = createMatador({\n   340â†’        transport,\n   341â†’        topology,\n   342â†’        consumeFrom: ['events'],\n   343â†’      }).register(UserCreatedEvent, [subscriber]);\n   344â†’\n   345â†’      await matador.start();\n   346â†’\n   347â†’      await matador.dispatch(\n   348â†’        new UserCreatedEvent({\n   349â†’          userId: 'meta-user',\n   350â†’          email: 'meta@test.com',\n   351â†’        }),\n   352â†’        {\n   353â†’          metadata: {\n   354â†’            source: 'api',\n   355â†’            requestId: 'req-123',\n   356â†’            userAgent: 'test-client',\n   357â†’          },\n   358â†’        },\n   359â†’      );\n   360â†’\n   361â†’      await matador.waitForIdle(2000);\n   362â†’\n   363â†’      expect(receivedMetadata.length).toBe(1);\n   364â†’      expect(receivedMetadata[0]).toMatchObject({\n   365â†’        source: 'api',\n   366â†’        requestId: 'req-123',\n   367â†’      });\n   368â†’    });\n   369â†’  });\n   370â†’\n   371â†’  describe('graceful shutdown', () => {\n   372â†’    it('should complete in-flight processing during shutdown', async () => {\n   373â†’      const processed: string[] = [];\n   374â†’      let processingStarted = false;\n   375â†’\n   376â†’      const topology = createTopology()\n   377â†’        .withNamespace('int-shutdown')\n   378â†’        .addQueue('events')\n   379â†’        .build();\n   380â†’\n   381â†’      const subscriber = createSubscriber(\n   382â†’        'slow-subscriber',\n   383â†’        UserCreatedEvent,\n   384â†’        async (data) => {\n   385â†’          processingStarted = true;\n   386â†’          // Simulate slow processing\n   387â†’          await new Promise((resolve) => setTimeout(resolve, 500));\n   388â†’          processed.push(data.userId);\n   389â†’        },\n   390â†’      );\n   391â†’\n   392â†’      matador = createMatador({\n   393â†’        transport,\n   394â†’        topology,\n   395â†’        consumeFrom: ['events'],\n   396â†’        shutdown: {\n   397â†’          gracefulTimeoutMs: 5000,\n   398â†’          pollIntervalMs: 50,\n   399â†’        },\n   400â†’      }).register(UserCreatedEvent, [subscriber]);\n   401â†’\n   402â†’      await matador.start();\n   403â†’\n   404â†’      // Dispatch event\n   405â†’      await matador.dispatch(\n   406â†’        new UserCreatedEvent({\n   407â†’          userId: 'shutdown-user',\n   408â†’          email: 'shutdown@test.com',\n   409â†’        }),\n   410â†’      );\n   411â†’\n   412â†’      // Wait for processing to start\n   413â†’      await waitFor(() => processingStarted, 1000);\n   414â†’\n   415â†’      // Initiate shutdown while processing\n   416â†’      await matador.shutdown();\n   417â†’\n   418â†’      // Processing should have completed\n   419â†’      expect(processed).toContain('shutdown-user');\n   420â†’    });\n   421â†’\n   422â†’    it('should reject new dispatches during shutdown', async () => {\n   423â†’      const topology = createTopology()\n   424â†’        .withNamespace('int-shutdown-reject')\n   425â†’        .addQueue('events')\n   426â†’        .build();\n   427â†’\n   428â†’      const subscriber = createSubscriber(\n   429â†’        'test-subscriber',\n   430â†’        UserCreatedEvent,\n   431â†’        async () => {},\n   432â†’      );\n   433â†’\n   434â†’      matador = createMatador({\n   435â†’        transport,\n   436â†’        topology,\n   437â†’        consumeFrom: ['events'],\n   438â†’      }).register(UserCreatedEvent, [subscriber]);\n   439â†’\n   440â†’      await matador.start();\n   441â†’\n   442â†’      // Start shutdown\n   443â†’      const shutdownPromise = matador.shutdown();\n   444â†’\n   445â†’      // Try to dispatch after shutdown started\n   446â†’      await shutdownPromise;\n   447â†’\n   448â†’      await expect(\n   449â†’        matador.dispatch(\n   450â†’          new UserCreatedEvent({ userId: 'late', email: 'late@test.com' }),\n   451â†’        ),\n   452â†’      ).rejects.toThrow();\n   453â†’    });\n   454â†’  });\n   455â†’\n   456â†’  describe('subscriber filtering', () => {\n   457â†’    it('should filter subscribers based on enabled hook', async () => {\n   458â†’      const processed: string[] = [];\n   459â†’\n   460â†’      const topology = createTopology()\n   461â†’        .withNamespace('int-filter')\n   462â†’        .addQueue('events')\n   463â†’        .build();\n   464â†’\n   465â†’      const enabledSub = createSubscriber(\n   466â†’        'enabled-subscriber',\n   467â†’        UserCreatedEvent,\n   468â†’        async (data) => {\n   469â†’          processed.push(`enabled:${data.userId}`);\n   470â†’        },\n   471â†’        { enabled: () => true },\n   472â†’      );\n   473â†’\n   474â†’      const disabledSub = createSubscriber(\n   475â†’        'disabled-subscriber',\n   476â†’        UserCreatedEvent,\n   477â†’        async (data) => {\n   478â†’          processed.push(`disabled:${data.userId}`);\n   479â†’        },\n   480â†’        { enabled: () => false },\n   481â†’      );\n   482â†’\n   483â†’      matador = createMatador({\n   484â†’        transport,\n   485â†’        topology,\n   486â†’        consumeFrom: ['events'],\n   487â†’      }).register(UserCreatedEvent, [enabledSub, disabledSub]);\n   488â†’\n   489â†’      await matador.start();\n   490â†’\n   491â†’      const result = await matador.dispatch(\n   492â†’        new UserCreatedEvent({\n   493â†’          userId: 'filter-user',\n   494â†’          email: 'filter@test.com',\n   495â†’        }),\n   496â†’      );\n   497â†’\n   498â†’      await matador.waitForIdle(2000);\n   499â†’\n   500â†’      // Only enabled subscriber should be dispatched\n   501â†’      expect(result.subscribersDispatched).toBe(1);\n   502â†’      expect(processed).toContain('enabled:filter-user');\n   503â†’      expect(processed).not.toContain('disabled:filter-user');\n   504â†’    });\n   505â†’  });\n   506â†’\n   507â†’  describe('handlers state', () => {\n   508â†’    it('should track handlers state during processing', async () => {\n   509â†’      let wasNotIdle = false;\n   510â†’\n   511â†’      const topology = createTopology()\n   512â†’        .withNamespace('int-state')\n   513â†’        .addQueue('events')\n   514â†’        .build();\n   515â†’\n   516â†’      const subscriber = createSubscriber(\n   517â†’        'state-subscriber',\n   518â†’        UserCreatedEvent,\n   519â†’        async () => {\n   520â†’          // Check state while processing\n   521â†’          const state = matador.getHandlersState();\n   522â†’          if (state.eventsBeingProcessed > 0) {\n   523â†’            wasNotIdle = true;\n   524â†’          }\n   525â†’          await new Promise((resolve) => setTimeout(resolve, 100));\n   526â†’        },\n   527â†’      );\n   528â†’\n   529â†’      matador = createMatador({\n   530â†’        transport,\n   531â†’        topology,\n   532â†’        consumeFrom: ['events'],\n   533â†’      }).register(UserCreatedEvent, [subscriber]);\n   534â†’\n   535â†’      await matador.start();\n   536â†’\n   537â†’      expect(matador.isIdle()).toBe(true);\n   538â†’\n   539â†’      await matador.dispatch(\n   540â†’        new UserCreatedEvent({ userId: 'state-user', email: 'state@test.com' }),\n   541â†’      );\n   542â†’\n   543â†’      await matador.waitForIdle(5000);\n   544â†’\n   545â†’      expect(wasNotIdle).toBe(true);\n   546â†’      expect(matador.isIdle()).toBe(true);\n   547â†’    });\n   548â†’  });\n   549â†’});\n   550â†’\n   551â†’/**\n   552â†’ * Waits for a condition to be true, with timeout.\n   553â†’ */\n   554â†’async function waitFor(\n   555â†’  condition: () => boolean,\n   556â†’  timeoutMs: number,\n   557â†’  intervalMs = 50,\n   558â†’): Promise<void> {\n   559â†’  const startTime = Date.now();\n   560â†’  while (!condition()) {\n   561â†’    if (Date.now() - startTime > timeoutMs) {\n   562â†’      throw new Error(`Timeout waiting for condition after ${timeoutMs}ms`);\n   563â†’    }\n   564â†’    await new Promise((resolve) => setTimeout(resolve, intervalMs));\n   565â†’  }\n   566â†’}\n   567â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-05T12:18:41.231Z"
        },
        {
          "type": "assistant",
          "text": "Now I have a complete picture. Let me create the CLI utility:",
          "timestamp": "2025-12-05T12:18:49.112Z"
        },
        {
          "type": "tool_use",
          "name": "TodoWrite",
          "input": {
            "todos": [
              {
                "activeForm": "Creating CLI script",
                "content": "Create CLI script (cli.ts)",
                "status": "in_progress"
              },
              {
                "activeForm": "Adding scripts to package.json",
                "content": "Add scripts to package.json",
                "status": "pending"
              },
              {
                "activeForm": "Creating example files",
                "content": "Create example config and event files",
                "status": "pending"
              }
            ]
          },
          "timestamp": "2025-12-05T12:18:50.800Z"
        },
        {
          "type": "user",
          "text": "Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable",
          "timestamp": "2025-12-05T12:18:50.855Z"
        },
        {
          "type": "tool_use",
          "name": "Write",
          "input": {
            "content": "#!/usr/bin/env bun\n/**\n * Matador CLI - Quick local testing of your Matador config\n *\n * Usage: ./cli.ts <path-to-config-file> <path-to-event-file>\n *\n * Config file should export:\n *   - events: Record<string, EventClass> - Map of event keys to event classes\n *   - subscribers: Record<string, AnySubscriber[]> - Map of event keys to subscribers\n *   - topology?: Topology - Optional topology (defaults to simple 'events' queue)\n *\n * Event file should export:\n *   - eventKey: string - The key of the event to dispatch\n *   - data: unknown - The event data payload\n *   - before?: unknown - Optional 'before' data for change events\n *   - options?: EventOptions - Optional dispatch options (correlationId, metadata, delayMs)\n */\n\nimport { resolve, dirname } from 'node:path';\nimport { parseArgs } from 'node:util';\nimport {\n  type AnySubscriber,\n  type EventClass,\n  type EventOptions,\n  type Topology,\n  type MatadorHooks,\n  MemoryTransport,\n  createMatador,\n  createTopology,\n  consoleLogger,\n} from './src/index.js';\n\n// Colors for terminal output\nconst colors = {\n  reset: '\\x1b[0m',\n  bold: '\\x1b[1m',\n  dim: '\\x1b[2m',\n  red: '\\x1b[31m',\n  green: '\\x1b[32m',\n  yellow: '\\x1b[33m',\n  blue: '\\x1b[34m',\n  magenta: '\\x1b[35m',\n  cyan: '\\x1b[36m',\n};\n\nfunction log(message: string, color: keyof typeof colors = 'reset'): void {\n  console.log(`${colors[color]}${message}${colors.reset}`);\n}\n\nfunction logSection(title: string): void {\n  console.log();\n  log(`â”â”â” ${title} â”â”â”`, 'cyan');\n}\n\nfunction logSuccess(message: string): void {\n  log(`âœ“ ${message}`, 'green');\n}\n\nfunction logError(message: string): void {\n  log(`âœ— ${message}`, 'red');\n}\n\nfunction logInfo(message: string): void {\n  log(`â„¹ ${message}`, 'blue');\n}\n\nfunction logWarning(message: string): void {\n  log(`âš  ${message}`, 'yellow');\n}\n\ninterface ConfigExport {\n  events: Record<string, EventClass>;\n  subscribers: Record<string, AnySubscriber[]>;\n  topology?: Topology;\n  hooks?: MatadorHooks;\n}\n\ninterface EventExport {\n  eventKey: string;\n  data: unknown;\n  before?: unknown;\n  options?: EventOptions;\n}\n\nfunction printUsage(): void {\n  console.log(`\n${colors.bold}Matador CLI${colors.reset} - Quick local testing of your Matador config\n\n${colors.cyan}Usage:${colors.reset}\n  ./cli.ts <config-file> <event-file>\n  bun cli.ts <config-file> <event-file>\n\n${colors.cyan}Arguments:${colors.reset}\n  config-file   Path to your Matador config file (TypeScript/JavaScript)\n  event-file    Path to your event file (TypeScript/JavaScript/JSON)\n\n${colors.cyan}Options:${colors.reset}\n  --help, -h    Show this help message\n  --dry-run     Validate config and event without dispatching\n  --timeout     Timeout in milliseconds for processing (default: 5000)\n  --verbose     Show verbose output including all hook logs\n\n${colors.cyan}Config file exports:${colors.reset}\n  events        Record<string, EventClass> - Map of event keys to event classes\n  subscribers   Record<string, AnySubscriber[]> - Map of event keys to subscribers\n  topology?     Topology - Optional topology config\n  hooks?        MatadorHooks - Optional hooks for logging\n\n${colors.cyan}Event file exports:${colors.reset}\n  eventKey      string - The key of the event to dispatch\n  data          unknown - The event data payload\n  before?       unknown - Optional 'before' data for change events\n  options?      EventOptions - Optional dispatch options\n\n${colors.cyan}Examples:${colors.reset}\n  ./cli.ts ./my-config.ts ./test-event.ts\n  bun cli.ts ./config/matador.ts ./events/user-created.json --verbose\n`);\n}\n\nasync function loadModule<T>(filePath: string): Promise<T> {\n  const absolutePath = resolve(process.cwd(), filePath);\n\n  if (filePath.endsWith('.json')) {\n    const file = Bun.file(absolutePath);\n    return (await file.json()) as T;\n  }\n\n  const module = await import(absolutePath);\n  return module.default ?? module;\n}\n\nasync function main(): Promise<void> {\n  const { values, positionals } = parseArgs({\n    args: Bun.argv.slice(2),\n    options: {\n      help: { type: 'boolean', short: 'h' },\n      'dry-run': { type: 'boolean' },\n      timeout: { type: 'string', default: '5000' },\n      verbose: { type: 'boolean' },\n    },\n    allowPositionals: true,\n  });\n\n  if (values.help) {\n    printUsage();\n    process.exit(0);\n  }\n\n  if (positionals.length < 2) {\n    logError('Missing required arguments');\n    printUsage();\n    process.exit(1);\n  }\n\n  const [configPath, eventPath] = positionals;\n  const timeout = parseInt(values.timeout ?? '5000', 10);\n  const dryRun = values['dry-run'] ?? false;\n  const verbose = values.verbose ?? false;\n\n  logSection('Loading Configuration');\n\n  // Load config file\n  let config: ConfigExport;\n  try {\n    logInfo(`Loading config from: ${configPath}`);\n    config = await loadModule<ConfigExport>(configPath);\n\n    if (!config.events || typeof config.events !== 'object') {\n      throw new Error('Config must export an \"events\" object');\n    }\n    if (!config.subscribers || typeof config.subscribers !== 'object') {\n      throw new Error('Config must export a \"subscribers\" object');\n    }\n\n    const eventCount = Object.keys(config.events).length;\n    const subscriberCount = Object.values(config.subscribers).flat().length;\n    logSuccess(`Loaded ${eventCount} event(s) and ${subscriberCount} subscriber(s)`);\n  } catch (err) {\n    logError(`Failed to load config: ${err instanceof Error ? err.message : err}`);\n    process.exit(1);\n  }\n\n  // Load event file\n  let eventSpec: EventExport;\n  try {\n    logInfo(`Loading event from: ${eventPath}`);\n    eventSpec = await loadModule<EventExport>(eventPath);\n\n    if (!eventSpec.eventKey || typeof eventSpec.eventKey !== 'string') {\n      throw new Error('Event file must export an \"eventKey\" string');\n    }\n    if (eventSpec.data === undefined) {\n      throw new Error('Event file must export a \"data\" property');\n    }\n\n    logSuccess(`Event key: ${eventSpec.eventKey}`);\n  } catch (err) {\n    logError(`Failed to load event: ${err instanceof Error ? err.message : err}`);\n    process.exit(1);\n  }\n\n  // Validate event exists in config\n  const EventClass = config.events[eventSpec.eventKey];\n  if (!EventClass) {\n    logError(`Event \"${eventSpec.eventKey}\" not found in config`);\n    logInfo(`Available events: ${Object.keys(config.events).join(', ')}`);\n    process.exit(1);\n  }\n\n  const subscribers = config.subscribers[eventSpec.eventKey];\n  if (!subscribers || subscribers.length === 0) {\n    logWarning(`No subscribers registered for event \"${eventSpec.eventKey}\"`);\n  } else {\n    logInfo(`Subscribers: ${subscribers.map((s) => s.name).join(', ')}`);\n  }\n\n  if (dryRun) {\n    logSection('Dry Run Complete');\n    logSuccess('Config and event validated successfully');\n    logInfo('Use without --dry-run to actually dispatch the event');\n    process.exit(0);\n  }\n\n  logSection('Dispatching Event');\n\n  // Create topology\n  const topology =\n    config.topology ??\n    createTopology().withNamespace('cli-test').addQueue('events').withoutDeadLetter().build();\n\n  // Create transport\n  const transport = new MemoryTransport();\n\n  // Create hooks for logging\n  const hooks: MatadorHooks = {\n    logger: verbose ? consoleLogger : undefined,\n    onWorkerSuccess: (ctx) => {\n      logSuccess(`[${ctx.subscriber.name}] processed in ${ctx.durationMs}ms`);\n    },\n    onWorkerError: (ctx) => {\n      logError(`[${ctx.subscriber.name}] failed after ${ctx.durationMs}ms: ${ctx.error.message}`);\n    },\n    ...config.hooks,\n  };\n\n  // Create Matador instance\n  const matador = createMatador({\n    transport,\n    topology,\n    consumeFrom: topology.queues.map((q) => q.name),\n    hooks,\n  });\n\n  // Register all events and subscribers\n  for (const [eventKey, eventClass] of Object.entries(config.events)) {\n    const subs = config.subscribers[eventKey] ?? [];\n    matador.register(eventClass, subs);\n  }\n\n  try {\n    await matador.start();\n    logSuccess('Matador started');\n\n    // Create and dispatch the event\n    const event = new EventClass(eventSpec.data, eventSpec.before);\n    logInfo(`Dispatching: ${eventSpec.eventKey}`);\n\n    if (verbose) {\n      logInfo(`Data: ${JSON.stringify(eventSpec.data, null, 2)}`);\n      if (eventSpec.before) {\n        logInfo(`Before: ${JSON.stringify(eventSpec.before, null, 2)}`);\n      }\n      if (eventSpec.options) {\n        logInfo(`Options: ${JSON.stringify(eventSpec.options, null, 2)}`);\n      }\n    }\n\n    const result = await matador.dispatch(event, eventSpec.options);\n\n    logSection('Dispatch Result');\n    logInfo(`Event key: ${result.eventKey}`);\n    logInfo(`Subscribers dispatched: ${result.subscribersDispatched}`);\n    logInfo(`Subscribers skipped: ${result.subscribersSkipped}`);\n\n    if (result.errors.length > 0) {\n      logWarning(`Dispatch errors: ${result.errors.length}`);\n      for (const err of result.errors) {\n        logError(`  [${err.subscriberName}] ${err.error.message}`);\n      }\n    }\n\n    // Wait for processing\n    logSection('Processing');\n    const idle = await matador.waitForIdle(timeout);\n\n    if (idle) {\n      logSuccess('All subscribers finished processing');\n    } else {\n      logWarning(`Timed out after ${timeout}ms waiting for processing`);\n    }\n\n    await matador.shutdown();\n    logSuccess('Matador shutdown complete');\n\n    logSection('Summary');\n    if (result.errors.length === 0 && idle) {\n      logSuccess('Event dispatched and processed successfully!');\n      process.exit(0);\n    } else {\n      logWarning('Event dispatched with issues');\n      process.exit(1);\n    }\n  } catch (err) {\n    logError(`Error: ${err instanceof Error ? err.message : err}`);\n    await matador.shutdown().catch(() => {});\n    process.exit(1);\n  }\n}\n\nmain();\n",
            "file_path": "/home/z/Desktop/work/matador/packages/matador/cli.ts"
          },
          "timestamp": "2025-12-05T12:19:34.013Z"
        }
      ],
      "total_additions": 476,
      "total_deletions": 1,
      "accepted_lines": 477,
      "overriden_lines": 6
    }
  }
}
